2025-05-13 14:18:56 [main] WARN  c.l.s.impl.HnswVectorStoreService - Error generating embedding for text (attempt 1/3): class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
2025-05-13 14:18:56 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrying in 100 ms
2025-05-13 14:18:57 [main] WARN  c.l.s.impl.HnswVectorStoreService - Error generating embedding for text (attempt 2/3): class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
2025-05-13 14:18:57 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrying in 200 ms
2025-05-13 14:18:59 [main] WARN  c.l.s.impl.HnswVectorStoreService - Error generating embedding for text (attempt 3/3): class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
2025-05-13 14:18:59 [main] ERROR c.l.s.impl.HnswVectorStoreService - Failed to generate embedding after 3 attempts
java.lang.ClassCastException: class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
	at com.l3agent.service.impl.HnswVectorStoreService.callGainsightEmbeddingApi(HnswVectorStoreService.java:636)
	at com.l3agent.service.impl.HnswVectorStoreService.generateEmbedding(HnswVectorStoreService.java:551)
	at com.l3agent.service.impl.VectorBasedCodeRepositoryService.indexCodeRepository(VectorBasedCodeRepositoryService.java:118)
	at com.l3agent.service.impl.VectorBasedCodeRepositoryService.init(VectorBasedCodeRepositoryService.java:68)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMethod.invoke(InitDestroyAnnotationBeanPostProcessor.java:457)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMetadata.invokeInitMethods(InitDestroyAnnotationBeanPostProcessor.java:401)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor.postProcessBeforeInitialization(InitDestroyAnnotationBeanPostProcessor.java:219)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsBeforeInitialization(AbstractAutowireCapableBeanFactory.java:419)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1762)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:598)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:254)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1417)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1337)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:713)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:696)
	at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:145)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:483)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1416)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:597)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:254)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1417)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1337)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:713)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:696)
	at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:145)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:483)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1416)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:597)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:973)
	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:942)
	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:608)
	at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:146)
	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:734)
	at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:436)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:312)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1306)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1295)
	at com.l3agent.Application.main(Application.java:13)
2025-05-13 14:18:59 [main] WARN  c.l.s.impl.HnswVectorStoreService - Continuous failure count: 169/5
2025-05-13 14:19:01 [main] WARN  c.l.s.impl.HnswVectorStoreService - Error generating embedding for text (attempt 1/3): class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
2025-05-13 14:19:01 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrying in 100 ms
2025-05-13 14:19:02 [main] WARN  c.l.s.impl.HnswVectorStoreService - Error generating embedding for text (attempt 2/3): class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
2025-05-13 14:19:02 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrying in 200 ms
2025-05-13 14:19:04 [main] WARN  c.l.s.impl.HnswVectorStoreService - Error generating embedding for text (attempt 3/3): class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
2025-05-13 14:19:04 [main] ERROR c.l.s.impl.HnswVectorStoreService - Failed to generate embedding after 3 attempts
java.lang.ClassCastException: class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
	at com.l3agent.service.impl.HnswVectorStoreService.callGainsightEmbeddingApi(HnswVectorStoreService.java:636)
	at com.l3agent.service.impl.HnswVectorStoreService.generateEmbedding(HnswVectorStoreService.java:551)
	at com.l3agent.service.impl.VectorBasedCodeRepositoryService.indexCodeRepository(VectorBasedCodeRepositoryService.java:118)
	at com.l3agent.service.impl.VectorBasedCodeRepositoryService.init(VectorBasedCodeRepositoryService.java:68)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMethod.invoke(InitDestroyAnnotationBeanPostProcessor.java:457)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMetadata.invokeInitMethods(InitDestroyAnnotationBeanPostProcessor.java:401)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor.postProcessBeforeInitialization(InitDestroyAnnotationBeanPostProcessor.java:219)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsBeforeInitialization(AbstractAutowireCapableBeanFactory.java:419)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1762)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:598)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:254)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1417)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1337)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:713)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:696)
	at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:145)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:483)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1416)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:597)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:254)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1417)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1337)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:713)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:696)
	at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:145)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:483)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1416)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:597)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:973)
	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:942)
	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:608)
	at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:146)
	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:734)
	at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:436)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:312)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1306)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1295)
	at com.l3agent.Application.main(Application.java:13)
2025-05-13 14:19:04 [main] WARN  c.l.s.impl.HnswVectorStoreService - Continuous failure count: 170/5
2025-05-13 14:19:05 [main] WARN  c.l.s.impl.HnswVectorStoreService - Error generating embedding for text (attempt 1/3): class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
2025-05-13 14:19:05 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrying in 100 ms
2025-05-13 14:19:07 [main] WARN  c.l.s.impl.HnswVectorStoreService - Error generating embedding for text (attempt 2/3): class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
2025-05-13 14:19:07 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrying in 200 ms
2025-05-13 14:19:08 [main] WARN  c.l.s.impl.HnswVectorStoreService - Error generating embedding for text (attempt 3/3): class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
2025-05-13 14:19:08 [main] ERROR c.l.s.impl.HnswVectorStoreService - Failed to generate embedding after 3 attempts
java.lang.ClassCastException: class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
	at com.l3agent.service.impl.HnswVectorStoreService.callGainsightEmbeddingApi(HnswVectorStoreService.java:636)
	at com.l3agent.service.impl.HnswVectorStoreService.generateEmbedding(HnswVectorStoreService.java:551)
	at com.l3agent.service.impl.VectorBasedCodeRepositoryService.indexCodeRepository(VectorBasedCodeRepositoryService.java:118)
	at com.l3agent.service.impl.VectorBasedCodeRepositoryService.init(VectorBasedCodeRepositoryService.java:68)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMethod.invoke(InitDestroyAnnotationBeanPostProcessor.java:457)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMetadata.invokeInitMethods(InitDestroyAnnotationBeanPostProcessor.java:401)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor.postProcessBeforeInitialization(InitDestroyAnnotationBeanPostProcessor.java:219)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsBeforeInitialization(AbstractAutowireCapableBeanFactory.java:419)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1762)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:598)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:254)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1417)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1337)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:713)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:696)
	at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:145)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:483)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1416)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:597)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:254)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1417)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1337)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:713)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:696)
	at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:145)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:483)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1416)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:597)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:973)
	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:942)
	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:608)
	at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:146)
	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:734)
	at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:436)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:312)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1306)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1295)
	at com.l3agent.Application.main(Application.java:13)
2025-05-13 14:19:08 [main] WARN  c.l.s.impl.HnswVectorStoreService - Continuous failure count: 171/5
2025-05-13 14:19:09 [main] WARN  c.l.s.impl.HnswVectorStoreService - Error generating embedding for text (attempt 1/3): class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
2025-05-13 14:19:09 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrying in 100 ms
2025-05-13 14:19:11 [main] WARN  c.l.s.impl.HnswVectorStoreService - Error generating embedding for text (attempt 2/3): class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
2025-05-13 14:19:11 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrying in 200 ms
2025-05-13 14:19:12 [main] WARN  c.l.s.impl.HnswVectorStoreService - Error generating embedding for text (attempt 3/3): class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
2025-05-13 14:19:12 [main] ERROR c.l.s.impl.HnswVectorStoreService - Failed to generate embedding after 3 attempts
java.lang.ClassCastException: class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
	at com.l3agent.service.impl.HnswVectorStoreService.callGainsightEmbeddingApi(HnswVectorStoreService.java:636)
	at com.l3agent.service.impl.HnswVectorStoreService.generateEmbedding(HnswVectorStoreService.java:551)
	at com.l3agent.service.impl.VectorBasedCodeRepositoryService.indexCodeRepository(VectorBasedCodeRepositoryService.java:118)
	at com.l3agent.service.impl.VectorBasedCodeRepositoryService.init(VectorBasedCodeRepositoryService.java:68)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMethod.invoke(InitDestroyAnnotationBeanPostProcessor.java:457)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMetadata.invokeInitMethods(InitDestroyAnnotationBeanPostProcessor.java:401)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor.postProcessBeforeInitialization(InitDestroyAnnotationBeanPostProcessor.java:219)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsBeforeInitialization(AbstractAutowireCapableBeanFactory.java:419)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1762)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:598)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:254)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1417)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1337)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:713)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:696)
	at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:145)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:483)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1416)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:597)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:254)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1417)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1337)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:713)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:696)
	at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:145)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:483)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1416)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:597)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:973)
	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:942)
	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:608)
	at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:146)
	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:734)
	at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:436)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:312)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1306)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1295)
	at com.l3agent.Application.main(Application.java:13)
2025-05-13 14:19:12 [main] WARN  c.l.s.impl.HnswVectorStoreService - Continuous failure count: 172/5
2025-05-13 14:19:14 [main] WARN  c.l.s.impl.HnswVectorStoreService - Error generating embedding for text (attempt 1/3): class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
2025-05-13 14:19:14 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrying in 100 ms
2025-05-13 14:19:15 [main] WARN  c.l.s.impl.HnswVectorStoreService - Error generating embedding for text (attempt 2/3): class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
2025-05-13 14:19:15 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrying in 200 ms
2025-05-13 14:19:17 [main] WARN  c.l.s.impl.HnswVectorStoreService - Error generating embedding for text (attempt 3/3): class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
2025-05-13 14:19:17 [main] ERROR c.l.s.impl.HnswVectorStoreService - Failed to generate embedding after 3 attempts
java.lang.ClassCastException: class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
	at com.l3agent.service.impl.HnswVectorStoreService.callGainsightEmbeddingApi(HnswVectorStoreService.java:636)
	at com.l3agent.service.impl.HnswVectorStoreService.generateEmbedding(HnswVectorStoreService.java:551)
	at com.l3agent.service.impl.VectorBasedCodeRepositoryService.indexCodeRepository(VectorBasedCodeRepositoryService.java:118)
	at com.l3agent.service.impl.VectorBasedCodeRepositoryService.init(VectorBasedCodeRepositoryService.java:68)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMethod.invoke(InitDestroyAnnotationBeanPostProcessor.java:457)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMetadata.invokeInitMethods(InitDestroyAnnotationBeanPostProcessor.java:401)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor.postProcessBeforeInitialization(InitDestroyAnnotationBeanPostProcessor.java:219)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsBeforeInitialization(AbstractAutowireCapableBeanFactory.java:419)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1762)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:598)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:254)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1417)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1337)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:713)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:696)
	at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:145)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:483)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1416)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:597)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:254)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1417)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1337)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:713)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:696)
	at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:145)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:483)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1416)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:597)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:973)
	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:942)
	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:608)
	at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:146)
	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:734)
	at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:436)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:312)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1306)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1295)
	at com.l3agent.Application.main(Application.java:13)
2025-05-13 14:19:17 [main] WARN  c.l.s.impl.HnswVectorStoreService - Continuous failure count: 173/5
2025-05-13 14:19:19 [main] WARN  c.l.s.impl.HnswVectorStoreService - Error generating embedding for text (attempt 1/3): class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
2025-05-13 14:19:19 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrying in 100 ms
2025-05-13 14:19:20 [main] WARN  c.l.s.impl.HnswVectorStoreService - Error generating embedding for text (attempt 2/3): class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
2025-05-13 14:19:20 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrying in 200 ms
2025-05-13 14:19:22 [main] WARN  c.l.s.impl.HnswVectorStoreService - Error generating embedding for text (attempt 3/3): class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
2025-05-13 14:19:22 [main] ERROR c.l.s.impl.HnswVectorStoreService - Failed to generate embedding after 3 attempts
java.lang.ClassCastException: class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
	at com.l3agent.service.impl.HnswVectorStoreService.callGainsightEmbeddingApi(HnswVectorStoreService.java:636)
	at com.l3agent.service.impl.HnswVectorStoreService.generateEmbedding(HnswVectorStoreService.java:551)
	at com.l3agent.service.impl.VectorBasedCodeRepositoryService.indexCodeRepository(VectorBasedCodeRepositoryService.java:118)
	at com.l3agent.service.impl.VectorBasedCodeRepositoryService.init(VectorBasedCodeRepositoryService.java:68)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMethod.invoke(InitDestroyAnnotationBeanPostProcessor.java:457)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMetadata.invokeInitMethods(InitDestroyAnnotationBeanPostProcessor.java:401)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor.postProcessBeforeInitialization(InitDestroyAnnotationBeanPostProcessor.java:219)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsBeforeInitialization(AbstractAutowireCapableBeanFactory.java:419)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1762)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:598)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:254)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1417)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1337)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:713)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:696)
	at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:145)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:483)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1416)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:597)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:254)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1417)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1337)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:713)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:696)
	at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:145)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:483)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1416)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:597)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:973)
	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:942)
	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:608)
	at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:146)
	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:734)
	at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:436)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:312)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1306)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1295)
	at com.l3agent.Application.main(Application.java:13)
2025-05-13 14:19:22 [main] WARN  c.l.s.impl.HnswVectorStoreService - Continuous failure count: 174/5
2025-05-13 14:19:23 [main] WARN  c.l.s.impl.HnswVectorStoreService - Error generating embedding for text (attempt 1/3): class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
2025-05-13 14:19:23 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrying in 100 ms
2025-05-13 14:19:25 [main] WARN  c.l.s.impl.HnswVectorStoreService - Error generating embedding for text (attempt 2/3): class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
2025-05-13 14:19:25 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrying in 200 ms
2025-05-13 14:19:26 [main] WARN  c.l.s.impl.HnswVectorStoreService - Error generating embedding for text (attempt 3/3): class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
2025-05-13 14:19:26 [main] ERROR c.l.s.impl.HnswVectorStoreService - Failed to generate embedding after 3 attempts
java.lang.ClassCastException: class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
	at com.l3agent.service.impl.HnswVectorStoreService.callGainsightEmbeddingApi(HnswVectorStoreService.java:636)
	at com.l3agent.service.impl.HnswVectorStoreService.generateEmbedding(HnswVectorStoreService.java:551)
	at com.l3agent.service.impl.VectorBasedCodeRepositoryService.indexCodeRepository(VectorBasedCodeRepositoryService.java:118)
	at com.l3agent.service.impl.VectorBasedCodeRepositoryService.init(VectorBasedCodeRepositoryService.java:68)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMethod.invoke(InitDestroyAnnotationBeanPostProcessor.java:457)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMetadata.invokeInitMethods(InitDestroyAnnotationBeanPostProcessor.java:401)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor.postProcessBeforeInitialization(InitDestroyAnnotationBeanPostProcessor.java:219)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsBeforeInitialization(AbstractAutowireCapableBeanFactory.java:419)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1762)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:598)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:254)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1417)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1337)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:713)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:696)
	at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:145)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:483)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1416)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:597)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:254)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1417)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1337)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:713)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:696)
	at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:145)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:483)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1416)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:597)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:973)
	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:942)
	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:608)
	at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:146)
	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:734)
	at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:436)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:312)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1306)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1295)
	at com.l3agent.Application.main(Application.java:13)
2025-05-13 14:19:26 [main] WARN  c.l.s.impl.HnswVectorStoreService - Continuous failure count: 175/5
2025-05-13 14:19:28 [main] WARN  c.l.s.impl.HnswVectorStoreService - Error generating embedding for text (attempt 1/3): class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
2025-05-13 14:19:28 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrying in 100 ms
2025-05-13 14:19:29 [main] WARN  c.l.s.impl.HnswVectorStoreService - Error generating embedding for text (attempt 2/3): class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
2025-05-13 14:19:29 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrying in 200 ms
2025-05-13 14:19:31 [main] WARN  c.l.s.impl.HnswVectorStoreService - Error generating embedding for text (attempt 3/3): class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
2025-05-13 14:19:31 [main] ERROR c.l.s.impl.HnswVectorStoreService - Failed to generate embedding after 3 attempts
java.lang.ClassCastException: class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
	at com.l3agent.service.impl.HnswVectorStoreService.callGainsightEmbeddingApi(HnswVectorStoreService.java:636)
	at com.l3agent.service.impl.HnswVectorStoreService.generateEmbedding(HnswVectorStoreService.java:551)
	at com.l3agent.service.impl.VectorBasedCodeRepositoryService.indexCodeRepository(VectorBasedCodeRepositoryService.java:118)
	at com.l3agent.service.impl.VectorBasedCodeRepositoryService.init(VectorBasedCodeRepositoryService.java:68)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMethod.invoke(InitDestroyAnnotationBeanPostProcessor.java:457)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMetadata.invokeInitMethods(InitDestroyAnnotationBeanPostProcessor.java:401)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor.postProcessBeforeInitialization(InitDestroyAnnotationBeanPostProcessor.java:219)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsBeforeInitialization(AbstractAutowireCapableBeanFactory.java:419)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1762)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:598)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:254)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1417)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1337)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:713)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:696)
	at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:145)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:483)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1416)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:597)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:254)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1417)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1337)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:713)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:696)
	at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:145)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:483)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1416)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:597)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:973)
	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:942)
	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:608)
	at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:146)
	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:734)
	at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:436)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:312)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1306)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1295)
	at com.l3agent.Application.main(Application.java:13)
2025-05-13 14:19:31 [main] WARN  c.l.s.impl.HnswVectorStoreService - Continuous failure count: 176/5
2025-05-13 14:19:32 [main] WARN  c.l.s.impl.HnswVectorStoreService - Error generating embedding for text (attempt 1/3): class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
2025-05-13 14:19:32 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrying in 100 ms
2025-05-13 14:19:34 [main] WARN  c.l.s.impl.HnswVectorStoreService - Error generating embedding for text (attempt 2/3): class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
2025-05-13 14:19:34 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrying in 200 ms
2025-05-13 14:19:35 [main] WARN  c.l.s.impl.HnswVectorStoreService - Error generating embedding for text (attempt 3/3): class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
2025-05-13 14:19:35 [main] ERROR c.l.s.impl.HnswVectorStoreService - Failed to generate embedding after 3 attempts
java.lang.ClassCastException: class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
	at com.l3agent.service.impl.HnswVectorStoreService.callGainsightEmbeddingApi(HnswVectorStoreService.java:636)
	at com.l3agent.service.impl.HnswVectorStoreService.generateEmbedding(HnswVectorStoreService.java:551)
	at com.l3agent.service.impl.VectorBasedCodeRepositoryService.indexCodeRepository(VectorBasedCodeRepositoryService.java:118)
	at com.l3agent.service.impl.VectorBasedCodeRepositoryService.init(VectorBasedCodeRepositoryService.java:68)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMethod.invoke(InitDestroyAnnotationBeanPostProcessor.java:457)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMetadata.invokeInitMethods(InitDestroyAnnotationBeanPostProcessor.java:401)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor.postProcessBeforeInitialization(InitDestroyAnnotationBeanPostProcessor.java:219)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsBeforeInitialization(AbstractAutowireCapableBeanFactory.java:419)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1762)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:598)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:254)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1417)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1337)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:713)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:696)
	at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:145)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:483)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1416)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:597)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:254)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1417)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1337)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:713)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:696)
	at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:145)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:483)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1416)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:597)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:973)
	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:942)
	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:608)
	at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:146)
	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:734)
	at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:436)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:312)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1306)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1295)
	at com.l3agent.Application.main(Application.java:13)
2025-05-13 14:19:35 [main] INFO  c.l.s.impl.HnswVectorStoreService - Saved 170 embedding failures to /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/vector-store /embedding_failures.json
2025-05-13 14:19:35 [main] WARN  c.l.s.impl.HnswVectorStoreService - Continuous failure count: 177/5
2025-05-13 14:19:37 [main] WARN  c.l.s.impl.HnswVectorStoreService - Error generating embedding for text (attempt 1/3): class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
2025-05-13 14:19:37 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrying in 100 ms
2025-05-13 14:19:38 [main] WARN  c.l.s.impl.HnswVectorStoreService - Error generating embedding for text (attempt 2/3): class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
2025-05-13 14:19:38 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrying in 200 ms
2025-05-13 14:19:40 [main] WARN  c.l.s.impl.HnswVectorStoreService - Error generating embedding for text (attempt 3/3): class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
2025-05-13 14:19:40 [main] ERROR c.l.s.impl.HnswVectorStoreService - Failed to generate embedding after 3 attempts
java.lang.ClassCastException: class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
	at com.l3agent.service.impl.HnswVectorStoreService.callGainsightEmbeddingApi(HnswVectorStoreService.java:636)
	at com.l3agent.service.impl.HnswVectorStoreService.generateEmbedding(HnswVectorStoreService.java:551)
	at com.l3agent.service.impl.VectorBasedCodeRepositoryService.indexCodeRepository(VectorBasedCodeRepositoryService.java:118)
	at com.l3agent.service.impl.VectorBasedCodeRepositoryService.init(VectorBasedCodeRepositoryService.java:68)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMethod.invoke(InitDestroyAnnotationBeanPostProcessor.java:457)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMetadata.invokeInitMethods(InitDestroyAnnotationBeanPostProcessor.java:401)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor.postProcessBeforeInitialization(InitDestroyAnnotationBeanPostProcessor.java:219)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsBeforeInitialization(AbstractAutowireCapableBeanFactory.java:419)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1762)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:598)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:254)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1417)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1337)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:713)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:696)
	at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:145)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:483)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1416)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:597)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:254)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1417)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1337)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:713)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:696)
	at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:145)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:483)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1416)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:597)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:973)
	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:942)
	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:608)
	at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:146)
	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:734)
	at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:436)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:312)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1306)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1295)
	at com.l3agent.Application.main(Application.java:13)
2025-05-13 14:19:40 [main] WARN  c.l.s.impl.HnswVectorStoreService - Continuous failure count: 178/5
2025-05-13 14:19:41 [main] WARN  c.l.s.impl.HnswVectorStoreService - Error generating embedding for text (attempt 1/3): class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
2025-05-13 14:19:41 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrying in 100 ms
2025-05-13 14:19:43 [main] WARN  c.l.s.impl.HnswVectorStoreService - Error generating embedding for text (attempt 2/3): class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
2025-05-13 14:19:43 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrying in 200 ms
2025-05-13 14:19:44 [main] WARN  c.l.s.impl.HnswVectorStoreService - Error generating embedding for text (attempt 3/3): class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
2025-05-13 14:19:44 [main] ERROR c.l.s.impl.HnswVectorStoreService - Failed to generate embedding after 3 attempts
java.lang.ClassCastException: class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
	at com.l3agent.service.impl.HnswVectorStoreService.callGainsightEmbeddingApi(HnswVectorStoreService.java:636)
	at com.l3agent.service.impl.HnswVectorStoreService.generateEmbedding(HnswVectorStoreService.java:551)
	at com.l3agent.service.impl.VectorBasedCodeRepositoryService.indexCodeRepository(VectorBasedCodeRepositoryService.java:118)
	at com.l3agent.service.impl.VectorBasedCodeRepositoryService.init(VectorBasedCodeRepositoryService.java:68)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMethod.invoke(InitDestroyAnnotationBeanPostProcessor.java:457)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMetadata.invokeInitMethods(InitDestroyAnnotationBeanPostProcessor.java:401)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor.postProcessBeforeInitialization(InitDestroyAnnotationBeanPostProcessor.java:219)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsBeforeInitialization(AbstractAutowireCapableBeanFactory.java:419)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1762)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:598)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:254)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1417)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1337)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:713)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:696)
	at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:145)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:483)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1416)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:597)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:254)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1417)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1337)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:713)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:696)
	at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:145)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:483)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1416)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:597)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:973)
	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:942)
	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:608)
	at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:146)
	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:734)
	at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:436)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:312)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1306)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1295)
	at com.l3agent.Application.main(Application.java:13)
2025-05-13 14:19:44 [main] WARN  c.l.s.impl.HnswVectorStoreService - Continuous failure count: 179/5
2025-05-13 14:19:46 [main] WARN  c.l.s.impl.HnswVectorStoreService - Error generating embedding for text (attempt 1/3): class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
2025-05-13 14:19:46 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrying in 100 ms
2025-05-13 14:19:47 [main] WARN  c.l.s.impl.HnswVectorStoreService - Error generating embedding for text (attempt 2/3): class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
2025-05-13 14:19:47 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrying in 200 ms
2025-05-13 14:19:49 [main] WARN  c.l.s.impl.HnswVectorStoreService - Error generating embedding for text (attempt 3/3): class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
2025-05-13 14:19:49 [main] ERROR c.l.s.impl.HnswVectorStoreService - Failed to generate embedding after 3 attempts
java.lang.ClassCastException: class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
	at com.l3agent.service.impl.HnswVectorStoreService.callGainsightEmbeddingApi(HnswVectorStoreService.java:636)
	at com.l3agent.service.impl.HnswVectorStoreService.generateEmbedding(HnswVectorStoreService.java:551)
	at com.l3agent.service.impl.VectorBasedCodeRepositoryService.indexCodeRepository(VectorBasedCodeRepositoryService.java:118)
	at com.l3agent.service.impl.VectorBasedCodeRepositoryService.init(VectorBasedCodeRepositoryService.java:68)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMethod.invoke(InitDestroyAnnotationBeanPostProcessor.java:457)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMetadata.invokeInitMethods(InitDestroyAnnotationBeanPostProcessor.java:401)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor.postProcessBeforeInitialization(InitDestroyAnnotationBeanPostProcessor.java:219)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsBeforeInitialization(AbstractAutowireCapableBeanFactory.java:419)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1762)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:598)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:254)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1417)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1337)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:713)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:696)
	at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:145)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:483)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1416)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:597)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:254)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1417)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1337)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:713)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:696)
	at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:145)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:483)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1416)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:597)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:973)
	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:942)
	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:608)
	at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:146)
	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:734)
	at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:436)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:312)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1306)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1295)
	at com.l3agent.Application.main(Application.java:13)
2025-05-13 14:19:49 [main] WARN  c.l.s.impl.HnswVectorStoreService - Continuous failure count: 180/5
2025-05-13 14:19:50 [main] WARN  c.l.s.impl.HnswVectorStoreService - Error generating embedding for text (attempt 1/3): class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
2025-05-13 14:19:50 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrying in 100 ms
2025-05-13 14:19:52 [main] WARN  c.l.s.impl.HnswVectorStoreService - Error generating embedding for text (attempt 2/3): class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
2025-05-13 14:19:52 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrying in 200 ms
2025-05-13 14:19:53 [main] WARN  c.l.s.impl.HnswVectorStoreService - Error generating embedding for text (attempt 3/3): class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
2025-05-13 14:19:53 [main] ERROR c.l.s.impl.HnswVectorStoreService - Failed to generate embedding after 3 attempts
java.lang.ClassCastException: class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
	at com.l3agent.service.impl.HnswVectorStoreService.callGainsightEmbeddingApi(HnswVectorStoreService.java:636)
	at com.l3agent.service.impl.HnswVectorStoreService.generateEmbedding(HnswVectorStoreService.java:551)
	at com.l3agent.service.impl.VectorBasedCodeRepositoryService.indexCodeRepository(VectorBasedCodeRepositoryService.java:118)
	at com.l3agent.service.impl.VectorBasedCodeRepositoryService.init(VectorBasedCodeRepositoryService.java:68)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMethod.invoke(InitDestroyAnnotationBeanPostProcessor.java:457)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMetadata.invokeInitMethods(InitDestroyAnnotationBeanPostProcessor.java:401)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor.postProcessBeforeInitialization(InitDestroyAnnotationBeanPostProcessor.java:219)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsBeforeInitialization(AbstractAutowireCapableBeanFactory.java:419)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1762)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:598)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:254)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1417)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1337)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:713)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:696)
	at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:145)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:483)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1416)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:597)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:254)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1417)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1337)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:713)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:696)
	at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:145)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:483)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1416)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:597)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:973)
	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:942)
	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:608)
	at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:146)
	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:734)
	at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:436)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:312)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1306)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1295)
	at com.l3agent.Application.main(Application.java:13)
2025-05-13 14:19:53 [main] WARN  c.l.s.impl.HnswVectorStoreService - Continuous failure count: 181/5
2025-05-13 14:19:55 [main] WARN  c.l.s.impl.HnswVectorStoreService - Error generating embedding for text (attempt 1/3): class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
2025-05-13 14:19:55 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrying in 100 ms
2025-05-13 14:19:56 [main] WARN  c.l.s.impl.HnswVectorStoreService - Error generating embedding for text (attempt 2/3): class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
2025-05-13 14:19:56 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrying in 200 ms
2025-05-13 14:19:58 [main] WARN  c.l.s.impl.HnswVectorStoreService - Error generating embedding for text (attempt 3/3): class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
2025-05-13 14:19:58 [main] ERROR c.l.s.impl.HnswVectorStoreService - Failed to generate embedding after 3 attempts
java.lang.ClassCastException: class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
	at com.l3agent.service.impl.HnswVectorStoreService.callGainsightEmbeddingApi(HnswVectorStoreService.java:636)
	at com.l3agent.service.impl.HnswVectorStoreService.generateEmbedding(HnswVectorStoreService.java:551)
	at com.l3agent.service.impl.VectorBasedCodeRepositoryService.indexCodeRepository(VectorBasedCodeRepositoryService.java:118)
	at com.l3agent.service.impl.VectorBasedCodeRepositoryService.init(VectorBasedCodeRepositoryService.java:68)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMethod.invoke(InitDestroyAnnotationBeanPostProcessor.java:457)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMetadata.invokeInitMethods(InitDestroyAnnotationBeanPostProcessor.java:401)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor.postProcessBeforeInitialization(InitDestroyAnnotationBeanPostProcessor.java:219)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsBeforeInitialization(AbstractAutowireCapableBeanFactory.java:419)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1762)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:598)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:254)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1417)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1337)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:713)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:696)
	at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:145)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:483)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1416)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:597)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:254)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1417)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1337)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:713)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:696)
	at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:145)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:483)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1416)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:597)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:973)
	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:942)
	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:608)
	at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:146)
	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:734)
	at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:436)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:312)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1306)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1295)
	at com.l3agent.Application.main(Application.java:13)
2025-05-13 14:19:58 [main] WARN  c.l.s.impl.HnswVectorStoreService - Continuous failure count: 182/5
2025-05-13 14:19:59 [main] WARN  c.l.s.impl.HnswVectorStoreService - Error generating embedding for text (attempt 1/3): class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
2025-05-13 14:19:59 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrying in 100 ms
2025-05-13 14:20:01 [main] WARN  c.l.s.impl.HnswVectorStoreService - Error generating embedding for text (attempt 2/3): class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
2025-05-13 14:20:01 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrying in 200 ms
2025-05-13 14:20:02 [main] WARN  c.l.s.impl.HnswVectorStoreService - Error generating embedding for text (attempt 3/3): class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
2025-05-13 14:20:02 [main] ERROR c.l.s.impl.HnswVectorStoreService - Failed to generate embedding after 3 attempts
java.lang.ClassCastException: class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
	at com.l3agent.service.impl.HnswVectorStoreService.callGainsightEmbeddingApi(HnswVectorStoreService.java:636)
	at com.l3agent.service.impl.HnswVectorStoreService.generateEmbedding(HnswVectorStoreService.java:551)
	at com.l3agent.service.impl.VectorBasedCodeRepositoryService.indexCodeRepository(VectorBasedCodeRepositoryService.java:118)
	at com.l3agent.service.impl.VectorBasedCodeRepositoryService.init(VectorBasedCodeRepositoryService.java:68)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMethod.invoke(InitDestroyAnnotationBeanPostProcessor.java:457)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMetadata.invokeInitMethods(InitDestroyAnnotationBeanPostProcessor.java:401)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor.postProcessBeforeInitialization(InitDestroyAnnotationBeanPostProcessor.java:219)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsBeforeInitialization(AbstractAutowireCapableBeanFactory.java:419)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1762)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:598)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:254)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1417)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1337)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:713)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:696)
	at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:145)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:483)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1416)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:597)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:254)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1417)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1337)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:713)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:696)
	at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:145)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:483)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1416)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:597)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:973)
	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:942)
	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:608)
	at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:146)
	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:734)
	at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:436)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:312)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1306)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1295)
	at com.l3agent.Application.main(Application.java:13)
2025-05-13 14:20:02 [main] WARN  c.l.s.impl.HnswVectorStoreService - Continuous failure count: 183/5
2025-05-13 14:20:04 [main] WARN  c.l.s.impl.HnswVectorStoreService - Error generating embedding for text (attempt 1/3): class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
2025-05-13 14:20:04 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrying in 100 ms
2025-05-13 14:20:05 [main] WARN  c.l.s.impl.HnswVectorStoreService - Error generating embedding for text (attempt 2/3): class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
2025-05-13 14:20:05 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrying in 200 ms
2025-05-13 14:20:07 [main] WARN  c.l.s.impl.HnswVectorStoreService - Error generating embedding for text (attempt 3/3): class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
2025-05-13 14:20:07 [main] ERROR c.l.s.impl.HnswVectorStoreService - Failed to generate embedding after 3 attempts
java.lang.ClassCastException: class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
	at com.l3agent.service.impl.HnswVectorStoreService.callGainsightEmbeddingApi(HnswVectorStoreService.java:636)
	at com.l3agent.service.impl.HnswVectorStoreService.generateEmbedding(HnswVectorStoreService.java:551)
	at com.l3agent.service.impl.VectorBasedCodeRepositoryService.indexCodeRepository(VectorBasedCodeRepositoryService.java:118)
	at com.l3agent.service.impl.VectorBasedCodeRepositoryService.init(VectorBasedCodeRepositoryService.java:68)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMethod.invoke(InitDestroyAnnotationBeanPostProcessor.java:457)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMetadata.invokeInitMethods(InitDestroyAnnotationBeanPostProcessor.java:401)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor.postProcessBeforeInitialization(InitDestroyAnnotationBeanPostProcessor.java:219)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsBeforeInitialization(AbstractAutowireCapableBeanFactory.java:419)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1762)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:598)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:254)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1417)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1337)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:713)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:696)
	at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:145)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:483)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1416)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:597)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:254)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1417)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1337)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:713)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:696)
	at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:145)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:483)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1416)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:597)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:973)
	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:942)
	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:608)
	at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:146)
	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:734)
	at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:436)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:312)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1306)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1295)
	at com.l3agent.Application.main(Application.java:13)
2025-05-13 14:20:07 [main] WARN  c.l.s.impl.HnswVectorStoreService - Continuous failure count: 184/5
2025-05-13 14:20:09 [main] WARN  c.l.s.impl.HnswVectorStoreService - Error generating embedding for text (attempt 1/3): class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
2025-05-13 14:20:09 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrying in 100 ms
2025-05-13 14:20:10 [main] WARN  c.l.s.impl.HnswVectorStoreService - Error generating embedding for text (attempt 2/3): class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
2025-05-13 14:20:10 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrying in 200 ms
2025-05-13 14:20:12 [main] WARN  c.l.s.impl.HnswVectorStoreService - Error generating embedding for text (attempt 3/3): class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
2025-05-13 14:20:12 [main] ERROR c.l.s.impl.HnswVectorStoreService - Failed to generate embedding after 3 attempts
java.lang.ClassCastException: class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
	at com.l3agent.service.impl.HnswVectorStoreService.callGainsightEmbeddingApi(HnswVectorStoreService.java:636)
	at com.l3agent.service.impl.HnswVectorStoreService.generateEmbedding(HnswVectorStoreService.java:551)
	at com.l3agent.service.impl.VectorBasedCodeRepositoryService.indexCodeRepository(VectorBasedCodeRepositoryService.java:118)
	at com.l3agent.service.impl.VectorBasedCodeRepositoryService.init(VectorBasedCodeRepositoryService.java:68)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMethod.invoke(InitDestroyAnnotationBeanPostProcessor.java:457)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMetadata.invokeInitMethods(InitDestroyAnnotationBeanPostProcessor.java:401)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor.postProcessBeforeInitialization(InitDestroyAnnotationBeanPostProcessor.java:219)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsBeforeInitialization(AbstractAutowireCapableBeanFactory.java:419)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1762)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:598)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:254)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1417)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1337)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:713)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:696)
	at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:145)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:483)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1416)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:597)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:254)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1417)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1337)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:713)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:696)
	at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:145)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:483)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1416)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:597)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:973)
	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:942)
	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:608)
	at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:146)
	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:734)
	at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:436)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:312)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1306)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1295)
	at com.l3agent.Application.main(Application.java:13)
2025-05-13 14:20:12 [main] WARN  c.l.s.impl.HnswVectorStoreService - Continuous failure count: 185/5
2025-05-13 14:20:14 [main] WARN  c.l.s.impl.HnswVectorStoreService - Error generating embedding for text (attempt 1/3): class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
2025-05-13 14:20:14 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrying in 100 ms
2025-05-13 14:20:15 [main] WARN  c.l.s.impl.HnswVectorStoreService - Error generating embedding for text (attempt 2/3): class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
2025-05-13 14:20:15 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrying in 200 ms
2025-05-13 14:20:17 [main] WARN  c.l.s.impl.HnswVectorStoreService - Error generating embedding for text (attempt 3/3): class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
2025-05-13 14:20:17 [main] ERROR c.l.s.impl.HnswVectorStoreService - Failed to generate embedding after 3 attempts
java.lang.ClassCastException: class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
	at com.l3agent.service.impl.HnswVectorStoreService.callGainsightEmbeddingApi(HnswVectorStoreService.java:636)
	at com.l3agent.service.impl.HnswVectorStoreService.generateEmbedding(HnswVectorStoreService.java:551)
	at com.l3agent.service.impl.VectorBasedCodeRepositoryService.indexCodeRepository(VectorBasedCodeRepositoryService.java:118)
	at com.l3agent.service.impl.VectorBasedCodeRepositoryService.init(VectorBasedCodeRepositoryService.java:68)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMethod.invoke(InitDestroyAnnotationBeanPostProcessor.java:457)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMetadata.invokeInitMethods(InitDestroyAnnotationBeanPostProcessor.java:401)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor.postProcessBeforeInitialization(InitDestroyAnnotationBeanPostProcessor.java:219)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsBeforeInitialization(AbstractAutowireCapableBeanFactory.java:419)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1762)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:598)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:254)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1417)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1337)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:713)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:696)
	at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:145)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:483)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1416)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:597)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:254)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1417)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1337)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:713)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:696)
	at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:145)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:483)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1416)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:597)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:973)
	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:942)
	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:608)
	at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:146)
	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:734)
	at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:436)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:312)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1306)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1295)
	at com.l3agent.Application.main(Application.java:13)
2025-05-13 14:20:17 [main] WARN  c.l.s.impl.HnswVectorStoreService - Continuous failure count: 186/5
2025-05-13 14:20:19 [main] WARN  c.l.s.impl.HnswVectorStoreService - Error generating embedding for text (attempt 1/3): class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
2025-05-13 14:20:19 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrying in 100 ms
2025-05-13 14:20:20 [main] WARN  c.l.s.impl.HnswVectorStoreService - Error generating embedding for text (attempt 2/3): class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
2025-05-13 14:20:20 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrying in 200 ms
2025-05-13 14:20:22 [main] WARN  c.l.s.impl.HnswVectorStoreService - Error generating embedding for text (attempt 3/3): class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
2025-05-13 14:20:22 [main] ERROR c.l.s.impl.HnswVectorStoreService - Failed to generate embedding after 3 attempts
java.lang.ClassCastException: class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
	at com.l3agent.service.impl.HnswVectorStoreService.callGainsightEmbeddingApi(HnswVectorStoreService.java:636)
	at com.l3agent.service.impl.HnswVectorStoreService.generateEmbedding(HnswVectorStoreService.java:551)
	at com.l3agent.service.impl.VectorBasedCodeRepositoryService.indexCodeRepository(VectorBasedCodeRepositoryService.java:118)
	at com.l3agent.service.impl.VectorBasedCodeRepositoryService.init(VectorBasedCodeRepositoryService.java:68)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMethod.invoke(InitDestroyAnnotationBeanPostProcessor.java:457)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMetadata.invokeInitMethods(InitDestroyAnnotationBeanPostProcessor.java:401)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor.postProcessBeforeInitialization(InitDestroyAnnotationBeanPostProcessor.java:219)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsBeforeInitialization(AbstractAutowireCapableBeanFactory.java:419)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1762)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:598)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:254)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1417)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1337)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:713)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:696)
	at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:145)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:483)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1416)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:597)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:254)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1417)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1337)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:713)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:696)
	at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:145)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:483)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1416)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:597)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:973)
	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:942)
	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:608)
	at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:146)
	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:734)
	at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:436)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:312)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1306)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1295)
	at com.l3agent.Application.main(Application.java:13)
2025-05-13 14:20:22 [main] INFO  c.l.s.impl.HnswVectorStoreService - Saved 180 embedding failures to /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/vector-store /embedding_failures.json
2025-05-13 14:20:22 [main] WARN  c.l.s.impl.HnswVectorStoreService - Continuous failure count: 187/5
2025-05-13 14:20:23 [main] WARN  c.l.s.impl.HnswVectorStoreService - Error generating embedding for text (attempt 1/3): class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
2025-05-13 14:20:23 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrying in 100 ms
2025-05-13 14:20:25 [main] WARN  c.l.s.impl.HnswVectorStoreService - Error generating embedding for text (attempt 2/3): class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
2025-05-13 14:20:25 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrying in 200 ms
2025-05-13 14:20:26 [main] WARN  c.l.s.impl.HnswVectorStoreService - Error generating embedding for text (attempt 3/3): class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
2025-05-13 14:20:26 [main] ERROR c.l.s.impl.HnswVectorStoreService - Failed to generate embedding after 3 attempts
java.lang.ClassCastException: class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
	at com.l3agent.service.impl.HnswVectorStoreService.callGainsightEmbeddingApi(HnswVectorStoreService.java:636)
	at com.l3agent.service.impl.HnswVectorStoreService.generateEmbedding(HnswVectorStoreService.java:551)
	at com.l3agent.service.impl.VectorBasedCodeRepositoryService.indexCodeRepository(VectorBasedCodeRepositoryService.java:118)
	at com.l3agent.service.impl.VectorBasedCodeRepositoryService.init(VectorBasedCodeRepositoryService.java:68)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMethod.invoke(InitDestroyAnnotationBeanPostProcessor.java:457)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMetadata.invokeInitMethods(InitDestroyAnnotationBeanPostProcessor.java:401)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor.postProcessBeforeInitialization(InitDestroyAnnotationBeanPostProcessor.java:219)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsBeforeInitialization(AbstractAutowireCapableBeanFactory.java:419)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1762)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:598)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:254)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1417)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1337)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:713)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:696)
	at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:145)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:483)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1416)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:597)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:254)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1417)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1337)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:713)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:696)
	at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:145)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:483)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1416)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:597)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:973)
	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:942)
	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:608)
	at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:146)
	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:734)
	at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:436)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:312)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1306)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1295)
	at com.l3agent.Application.main(Application.java:13)
2025-05-13 14:20:26 [main] WARN  c.l.s.impl.HnswVectorStoreService - Continuous failure count: 188/5
2025-05-13 14:20:28 [main] WARN  c.l.s.impl.HnswVectorStoreService - Error generating embedding for text (attempt 1/3): class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
2025-05-13 14:20:28 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrying in 100 ms
2025-05-13 14:20:29 [main] WARN  c.l.s.impl.HnswVectorStoreService - Error generating embedding for text (attempt 2/3): class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
2025-05-13 14:20:29 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrying in 200 ms
2025-05-13 14:20:31 [main] WARN  c.l.s.impl.HnswVectorStoreService - Error generating embedding for text (attempt 3/3): class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
2025-05-13 14:20:31 [main] ERROR c.l.s.impl.HnswVectorStoreService - Failed to generate embedding after 3 attempts
java.lang.ClassCastException: class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
	at com.l3agent.service.impl.HnswVectorStoreService.callGainsightEmbeddingApi(HnswVectorStoreService.java:636)
	at com.l3agent.service.impl.HnswVectorStoreService.generateEmbedding(HnswVectorStoreService.java:551)
	at com.l3agent.service.impl.VectorBasedCodeRepositoryService.indexCodeRepository(VectorBasedCodeRepositoryService.java:118)
	at com.l3agent.service.impl.VectorBasedCodeRepositoryService.init(VectorBasedCodeRepositoryService.java:68)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMethod.invoke(InitDestroyAnnotationBeanPostProcessor.java:457)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMetadata.invokeInitMethods(InitDestroyAnnotationBeanPostProcessor.java:401)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor.postProcessBeforeInitialization(InitDestroyAnnotationBeanPostProcessor.java:219)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsBeforeInitialization(AbstractAutowireCapableBeanFactory.java:419)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1762)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:598)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:254)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1417)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1337)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:713)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:696)
	at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:145)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:483)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1416)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:597)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:254)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1417)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1337)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:713)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:696)
	at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:145)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:483)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1416)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:597)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:973)
	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:942)
	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:608)
	at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:146)
	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:734)
	at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:436)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:312)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1306)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1295)
	at com.l3agent.Application.main(Application.java:13)
2025-05-13 14:20:31 [main] WARN  c.l.s.impl.HnswVectorStoreService - Continuous failure count: 189/5
2025-05-13 14:20:32 [main] WARN  c.l.s.impl.HnswVectorStoreService - Error generating embedding for text (attempt 1/3): class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
2025-05-13 14:20:32 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrying in 100 ms
2025-05-13 14:20:34 [main] WARN  c.l.s.impl.HnswVectorStoreService - Error generating embedding for text (attempt 2/3): class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
2025-05-13 14:20:34 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrying in 200 ms
2025-05-13 14:20:36 [main] WARN  c.l.s.impl.HnswVectorStoreService - Error generating embedding for text (attempt 3/3): class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
2025-05-13 14:20:36 [main] ERROR c.l.s.impl.HnswVectorStoreService - Failed to generate embedding after 3 attempts
java.lang.ClassCastException: class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
	at com.l3agent.service.impl.HnswVectorStoreService.callGainsightEmbeddingApi(HnswVectorStoreService.java:636)
	at com.l3agent.service.impl.HnswVectorStoreService.generateEmbedding(HnswVectorStoreService.java:551)
	at com.l3agent.service.impl.VectorBasedCodeRepositoryService.indexCodeRepository(VectorBasedCodeRepositoryService.java:118)
	at com.l3agent.service.impl.VectorBasedCodeRepositoryService.init(VectorBasedCodeRepositoryService.java:68)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMethod.invoke(InitDestroyAnnotationBeanPostProcessor.java:457)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMetadata.invokeInitMethods(InitDestroyAnnotationBeanPostProcessor.java:401)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor.postProcessBeforeInitialization(InitDestroyAnnotationBeanPostProcessor.java:219)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsBeforeInitialization(AbstractAutowireCapableBeanFactory.java:419)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1762)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:598)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:254)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1417)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1337)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:713)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:696)
	at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:145)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:483)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1416)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:597)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:254)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1417)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1337)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:713)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:696)
	at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:145)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:483)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1416)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:597)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:973)
	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:942)
	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:608)
	at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:146)
	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:734)
	at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:436)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:312)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1306)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1295)
	at com.l3agent.Application.main(Application.java:13)
2025-05-13 14:20:36 [main] WARN  c.l.s.impl.HnswVectorStoreService - Continuous failure count: 190/5
2025-05-13 14:20:37 [main] WARN  c.l.s.impl.HnswVectorStoreService - Error generating embedding for text (attempt 1/3): class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
2025-05-13 14:20:37 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrying in 100 ms
2025-05-13 14:20:39 [main] WARN  c.l.s.impl.HnswVectorStoreService - Error generating embedding for text (attempt 2/3): class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
2025-05-13 14:20:39 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrying in 200 ms
2025-05-13 14:20:41 [main] WARN  c.l.s.impl.HnswVectorStoreService - Error generating embedding for text (attempt 3/3): class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
2025-05-13 14:20:41 [main] ERROR c.l.s.impl.HnswVectorStoreService - Failed to generate embedding after 3 attempts
java.lang.ClassCastException: class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
	at com.l3agent.service.impl.HnswVectorStoreService.callGainsightEmbeddingApi(HnswVectorStoreService.java:636)
	at com.l3agent.service.impl.HnswVectorStoreService.generateEmbedding(HnswVectorStoreService.java:551)
	at com.l3agent.service.impl.VectorBasedCodeRepositoryService.indexCodeRepository(VectorBasedCodeRepositoryService.java:118)
	at com.l3agent.service.impl.VectorBasedCodeRepositoryService.init(VectorBasedCodeRepositoryService.java:68)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMethod.invoke(InitDestroyAnnotationBeanPostProcessor.java:457)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMetadata.invokeInitMethods(InitDestroyAnnotationBeanPostProcessor.java:401)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor.postProcessBeforeInitialization(InitDestroyAnnotationBeanPostProcessor.java:219)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsBeforeInitialization(AbstractAutowireCapableBeanFactory.java:419)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1762)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:598)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:254)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1417)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1337)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:713)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:696)
	at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:145)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:483)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1416)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:597)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:254)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1417)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1337)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:713)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:696)
	at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:145)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:483)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1416)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:597)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:973)
	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:942)
	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:608)
	at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:146)
	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:734)
	at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:436)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:312)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1306)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1295)
	at com.l3agent.Application.main(Application.java:13)
2025-05-13 14:20:41 [main] WARN  c.l.s.impl.HnswVectorStoreService - Continuous failure count: 191/5
2025-05-13 14:20:42 [main] WARN  c.l.s.impl.HnswVectorStoreService - Error generating embedding for text (attempt 1/3): class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
2025-05-13 14:20:42 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrying in 100 ms
2025-05-13 14:20:43 [main] WARN  c.l.s.impl.HnswVectorStoreService - Error generating embedding for text (attempt 2/3): class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
2025-05-13 14:20:43 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrying in 200 ms
2025-05-13 14:20:45 [main] WARN  c.l.s.impl.HnswVectorStoreService - Error generating embedding for text (attempt 3/3): class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
2025-05-13 14:20:45 [main] ERROR c.l.s.impl.HnswVectorStoreService - Failed to generate embedding after 3 attempts
java.lang.ClassCastException: class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
	at com.l3agent.service.impl.HnswVectorStoreService.callGainsightEmbeddingApi(HnswVectorStoreService.java:636)
	at com.l3agent.service.impl.HnswVectorStoreService.generateEmbedding(HnswVectorStoreService.java:551)
	at com.l3agent.service.impl.VectorBasedCodeRepositoryService.indexCodeRepository(VectorBasedCodeRepositoryService.java:118)
	at com.l3agent.service.impl.VectorBasedCodeRepositoryService.init(VectorBasedCodeRepositoryService.java:68)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMethod.invoke(InitDestroyAnnotationBeanPostProcessor.java:457)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMetadata.invokeInitMethods(InitDestroyAnnotationBeanPostProcessor.java:401)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor.postProcessBeforeInitialization(InitDestroyAnnotationBeanPostProcessor.java:219)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsBeforeInitialization(AbstractAutowireCapableBeanFactory.java:419)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1762)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:598)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:254)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1417)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1337)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:713)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:696)
	at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:145)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:483)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1416)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:597)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:254)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1417)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1337)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:713)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:696)
	at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:145)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:483)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1416)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:597)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:973)
	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:942)
	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:608)
	at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:146)
	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:734)
	at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:436)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:312)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1306)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1295)
	at com.l3agent.Application.main(Application.java:13)
2025-05-13 14:20:45 [main] WARN  c.l.s.impl.HnswVectorStoreService - Continuous failure count: 192/5
2025-05-13 14:20:46 [main] WARN  c.l.s.impl.HnswVectorStoreService - Error generating embedding for text (attempt 1/3): class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
2025-05-13 14:20:46 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrying in 100 ms
2025-05-13 14:20:48 [main] WARN  c.l.s.impl.HnswVectorStoreService - Error generating embedding for text (attempt 2/3): class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
2025-05-13 14:20:48 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrying in 200 ms
2025-05-13 14:20:49 [main] WARN  c.l.s.impl.HnswVectorStoreService - Error generating embedding for text (attempt 3/3): class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
2025-05-13 14:20:49 [main] ERROR c.l.s.impl.HnswVectorStoreService - Failed to generate embedding after 3 attempts
java.lang.ClassCastException: class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
	at com.l3agent.service.impl.HnswVectorStoreService.callGainsightEmbeddingApi(HnswVectorStoreService.java:636)
	at com.l3agent.service.impl.HnswVectorStoreService.generateEmbedding(HnswVectorStoreService.java:551)
	at com.l3agent.service.impl.VectorBasedCodeRepositoryService.indexCodeRepository(VectorBasedCodeRepositoryService.java:118)
	at com.l3agent.service.impl.VectorBasedCodeRepositoryService.init(VectorBasedCodeRepositoryService.java:68)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMethod.invoke(InitDestroyAnnotationBeanPostProcessor.java:457)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMetadata.invokeInitMethods(InitDestroyAnnotationBeanPostProcessor.java:401)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor.postProcessBeforeInitialization(InitDestroyAnnotationBeanPostProcessor.java:219)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsBeforeInitialization(AbstractAutowireCapableBeanFactory.java:419)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1762)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:598)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:254)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1417)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1337)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:713)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:696)
	at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:145)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:483)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1416)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:597)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:254)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1417)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1337)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:713)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:696)
	at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:145)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:483)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1416)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:597)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:973)
	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:942)
	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:608)
	at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:146)
	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:734)
	at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:436)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:312)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1306)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1295)
	at com.l3agent.Application.main(Application.java:13)
2025-05-13 14:20:49 [main] WARN  c.l.s.impl.HnswVectorStoreService - Continuous failure count: 193/5
2025-05-13 14:20:51 [main] WARN  c.l.s.impl.HnswVectorStoreService - Error generating embedding for text (attempt 1/3): class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
2025-05-13 14:20:51 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrying in 100 ms
2025-05-13 14:20:52 [main] WARN  c.l.s.impl.HnswVectorStoreService - Error generating embedding for text (attempt 2/3): class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
2025-05-13 14:20:52 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrying in 200 ms
2025-05-13 14:20:54 [main] WARN  c.l.s.impl.HnswVectorStoreService - Error generating embedding for text (attempt 3/3): class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
2025-05-13 14:20:54 [main] ERROR c.l.s.impl.HnswVectorStoreService - Failed to generate embedding after 3 attempts
java.lang.ClassCastException: class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
	at com.l3agent.service.impl.HnswVectorStoreService.callGainsightEmbeddingApi(HnswVectorStoreService.java:636)
	at com.l3agent.service.impl.HnswVectorStoreService.generateEmbedding(HnswVectorStoreService.java:551)
	at com.l3agent.service.impl.VectorBasedCodeRepositoryService.indexCodeRepository(VectorBasedCodeRepositoryService.java:118)
	at com.l3agent.service.impl.VectorBasedCodeRepositoryService.init(VectorBasedCodeRepositoryService.java:68)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMethod.invoke(InitDestroyAnnotationBeanPostProcessor.java:457)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMetadata.invokeInitMethods(InitDestroyAnnotationBeanPostProcessor.java:401)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor.postProcessBeforeInitialization(InitDestroyAnnotationBeanPostProcessor.java:219)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsBeforeInitialization(AbstractAutowireCapableBeanFactory.java:419)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1762)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:598)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:254)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1417)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1337)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:713)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:696)
	at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:145)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:483)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1416)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:597)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:254)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1417)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1337)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:713)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:696)
	at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:145)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:483)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1416)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:597)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:973)
	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:942)
	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:608)
	at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:146)
	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:734)
	at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:436)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:312)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1306)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1295)
	at com.l3agent.Application.main(Application.java:13)
2025-05-13 14:20:54 [main] WARN  c.l.s.impl.HnswVectorStoreService - Continuous failure count: 194/5
2025-05-13 14:20:55 [main] WARN  c.l.s.impl.HnswVectorStoreService - Error generating embedding for text (attempt 1/3): class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
2025-05-13 14:20:55 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrying in 100 ms
2025-05-13 14:20:57 [main] WARN  c.l.s.impl.HnswVectorStoreService - Error generating embedding for text (attempt 2/3): class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
2025-05-13 14:20:57 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrying in 200 ms
2025-05-13 14:20:59 [main] WARN  c.l.s.impl.HnswVectorStoreService - Error generating embedding for text (attempt 3/3): class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
2025-05-13 14:20:59 [main] ERROR c.l.s.impl.HnswVectorStoreService - Failed to generate embedding after 3 attempts
java.lang.ClassCastException: class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
	at com.l3agent.service.impl.HnswVectorStoreService.callGainsightEmbeddingApi(HnswVectorStoreService.java:636)
	at com.l3agent.service.impl.HnswVectorStoreService.generateEmbedding(HnswVectorStoreService.java:551)
	at com.l3agent.service.impl.VectorBasedCodeRepositoryService.indexCodeRepository(VectorBasedCodeRepositoryService.java:118)
	at com.l3agent.service.impl.VectorBasedCodeRepositoryService.init(VectorBasedCodeRepositoryService.java:68)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMethod.invoke(InitDestroyAnnotationBeanPostProcessor.java:457)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMetadata.invokeInitMethods(InitDestroyAnnotationBeanPostProcessor.java:401)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor.postProcessBeforeInitialization(InitDestroyAnnotationBeanPostProcessor.java:219)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsBeforeInitialization(AbstractAutowireCapableBeanFactory.java:419)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1762)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:598)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:254)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1417)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1337)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:713)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:696)
	at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:145)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:483)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1416)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:597)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:254)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1417)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1337)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:713)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:696)
	at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:145)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:483)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1416)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:597)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:973)
	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:942)
	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:608)
	at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:146)
	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:734)
	at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:436)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:312)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1306)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1295)
	at com.l3agent.Application.main(Application.java:13)
2025-05-13 14:20:59 [main] WARN  c.l.s.impl.HnswVectorStoreService - Continuous failure count: 195/5
2025-05-13 14:21:01 [main] WARN  c.l.s.impl.HnswVectorStoreService - Error generating embedding for text (attempt 1/3): class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
2025-05-13 14:21:01 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrying in 100 ms
2025-05-13 14:21:02 [main] WARN  c.l.s.impl.HnswVectorStoreService - Error generating embedding for text (attempt 2/3): class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
2025-05-13 14:21:02 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrying in 200 ms
2025-05-13 14:21:04 [main] WARN  c.l.s.impl.HnswVectorStoreService - Error generating embedding for text (attempt 3/3): class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
2025-05-13 14:21:04 [main] ERROR c.l.s.impl.HnswVectorStoreService - Failed to generate embedding after 3 attempts
java.lang.ClassCastException: class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
	at com.l3agent.service.impl.HnswVectorStoreService.callGainsightEmbeddingApi(HnswVectorStoreService.java:636)
	at com.l3agent.service.impl.HnswVectorStoreService.generateEmbedding(HnswVectorStoreService.java:551)
	at com.l3agent.service.impl.VectorBasedCodeRepositoryService.indexCodeRepository(VectorBasedCodeRepositoryService.java:118)
	at com.l3agent.service.impl.VectorBasedCodeRepositoryService.init(VectorBasedCodeRepositoryService.java:68)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMethod.invoke(InitDestroyAnnotationBeanPostProcessor.java:457)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMetadata.invokeInitMethods(InitDestroyAnnotationBeanPostProcessor.java:401)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor.postProcessBeforeInitialization(InitDestroyAnnotationBeanPostProcessor.java:219)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsBeforeInitialization(AbstractAutowireCapableBeanFactory.java:419)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1762)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:598)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:254)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1417)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1337)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:713)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:696)
	at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:145)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:483)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1416)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:597)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:254)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1417)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1337)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:713)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:696)
	at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:145)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:483)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1416)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:597)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:973)
	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:942)
	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:608)
	at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:146)
	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:734)
	at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:436)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:312)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1306)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1295)
	at com.l3agent.Application.main(Application.java:13)
2025-05-13 14:21:04 [main] WARN  c.l.s.impl.HnswVectorStoreService - Continuous failure count: 196/5
2025-05-13 14:21:06 [main] WARN  c.l.s.impl.HnswVectorStoreService - Error generating embedding for text (attempt 1/3): class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
2025-05-13 14:21:06 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrying in 100 ms
2025-05-13 14:21:08 [main] WARN  c.l.s.impl.HnswVectorStoreService - Error generating embedding for text (attempt 2/3): class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
2025-05-13 14:21:08 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrying in 200 ms
2025-05-13 14:21:09 [main] WARN  c.l.s.impl.HnswVectorStoreService - Error generating embedding for text (attempt 3/3): class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
2025-05-13 14:21:09 [main] ERROR c.l.s.impl.HnswVectorStoreService - Failed to generate embedding after 3 attempts
java.lang.ClassCastException: class java.util.LinkedHashMap cannot be cast to class java.util.List (java.util.LinkedHashMap and java.util.List are in module java.base of loader 'bootstrap')
	at com.l3agent.service.impl.HnswVectorStoreService.callGainsightEmbeddingApi(HnswVectorStoreService.java:636)
	at com.l3agent.service.impl.HnswVectorStoreService.generateEmbedding(HnswVectorStoreService.java:551)
	at com.l3agent.service.impl.VectorBasedCodeRepositoryService.indexCodeRepository(VectorBasedCodeRepositoryService.java:118)
	at com.l3agent.service.impl.VectorBasedCodeRepositoryService.init(VectorBasedCodeRepositoryService.java:68)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMethod.invoke(InitDestroyAnnotationBeanPostProcessor.java:457)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMetadata.invokeInitMethods(InitDestroyAnnotationBeanPostProcessor.java:401)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor.postProcessBeforeInitialization(InitDestroyAnnotationBeanPostProcessor.java:219)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsBeforeInitialization(AbstractAutowireCapableBeanFactory.java:419)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1762)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:598)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:254)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1417)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1337)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:713)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:696)
	at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:145)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:483)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1416)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:597)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:254)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1417)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1337)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:713)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:696)
	at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:145)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:483)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1416)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:597)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:973)
	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:942)
	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:608)
	at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:146)
	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:734)
	at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:436)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:312)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1306)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1295)
	at com.l3agent.Application.main(Application.java:13)
2025-05-13 14:21:09 [main] WARN  c.l.s.impl.HnswVectorStoreService - Continuous failure count: 197/5
2025-05-13 14:21:37 [main] WARN  o.s.b.w.s.c.AnnotationConfigServletWebServerApplicationContext - Exception encountered during context initialization - cancelling refresh attempt: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'embeddingGenerationRunner': Unsatisfied dependency expressed through field 'l3AgentService': Error creating bean with name 'basicL3AgentService': Unsatisfied dependency expressed through field 'codeRepositoryService': Error creating bean with name 'vectorBasedCodeRepositoryService': Invocation of init method failed
2025-05-13 14:21:37 [main] INFO  c.l.s.impl.HnswVectorStoreService - Saved index for namespace default to /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/vector-store /default/hnsw_index.bin
2025-05-13 14:21:37 [main] INFO  c.l.s.impl.HnswVectorStoreService - Saved metadata for namespace default to /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/vector-store /default/embedding_metadata.json
2025-05-13 14:21:37 [main] INFO  c.l.s.impl.HnswVectorStoreService - Saved 189 embedding failures to /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/vector-store /embedding_failures.json
2025-05-13 14:21:37 [main] INFO  c.l.s.impl.HnswVectorStoreService - Saved 1 repository namespaces
2025-05-13 15:06:14 [main] INFO  com.l3agent.Application - Starting Application using Java 21.0.1 with PID 47467 (/Users/psambaraju/Desktop/cursorProjects/l3AgentNew/target/classes started by psambaraju in /Users/psambaraju/Desktop/cursorProjects/l3AgentNew)
2025-05-13 15:06:14 [main] DEBUG com.l3agent.Application - Running with Spring Boot v3.1.3, Spring v6.0.11
2025-05-13 15:06:14 [main] INFO  com.l3agent.Application - The following 1 profile is active: "nodb"
2025-05-13 15:06:14 [main] INFO  o.s.d.r.c.RepositoryConfigurationDelegate - Bootstrapping Spring Data JPA repositories in DEFAULT mode.
2025-05-13 15:06:14 [main] INFO  o.s.d.r.c.RepositoryConfigurationDelegate - Finished Spring Data repository scanning in 5 ms. Found 0 JPA repository interfaces.
2025-05-13 15:06:15 [main] INFO  o.s.b.w.e.tomcat.TomcatWebServer - Tomcat initialized with port(s): 8080 (http)
2025-05-13 15:06:15 [main] INFO  o.a.catalina.core.StandardService - Starting service [Tomcat]
2025-05-13 15:06:15 [main] INFO  o.a.catalina.core.StandardEngine - Starting Servlet engine: [Apache Tomcat/10.1.12]
2025-05-13 15:06:15 [main] INFO  o.a.c.c.C.[.[localhost].[/l3agent] - Initializing Spring embedded WebApplicationContext
2025-05-13 15:06:15 [main] INFO  o.s.b.w.s.c.ServletWebServerApplicationContext - Root WebApplicationContext: initialization completed in 708 ms
2025-05-13 15:06:15 [main] DEBUG c.l.s.impl.FileBasedTicketService - Loaded ticket TICKET-1234 from ./data/tickets/TICKET-1234.json
2025-05-13 15:06:15 [main] INFO  c.l.s.impl.HnswVectorStoreService - Loaded 1 repository namespaces
2025-05-13 15:06:15 [main] ERROR c.l.s.impl.HnswVectorStoreService - Error loading index for namespace default
java.io.InvalidObjectException: ReflectiveOperationException during deserialization
	at java.base/java.lang.invoke.SerializedLambda.readResolve(SerializedLambda.java:280)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at java.base/java.io.ObjectStreamClass.invokeReadResolve(ObjectStreamClass.java:1192)
	at java.base/java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2293)
	at java.base/java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1762)
	at java.base/java.io.ObjectInputStream.readObject(ObjectInputStream.java:540)
	at java.base/java.io.ObjectInputStream.readObject(ObjectInputStream.java:498)
	at com.github.jelmerk.knn.hnsw.HnswIndex.readObject(HnswIndex.java:785)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at java.base/java.io.ObjectStreamClass.invokeReadObject(ObjectStreamClass.java:1102)
	at java.base/java.io.ObjectInputStream.readSerialData(ObjectInputStream.java:2444)
	at java.base/java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2284)
	at java.base/java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1762)
	at java.base/java.io.ObjectInputStream.readObject(ObjectInputStream.java:540)
	at java.base/java.io.ObjectInputStream.readObject(ObjectInputStream.java:498)
	at com.github.jelmerk.knn.hnsw.HnswIndex.load(HnswIndex.java:960)
	at com.github.jelmerk.knn.hnsw.HnswIndex.load(HnswIndex.java:939)
	at com.github.jelmerk.knn.hnsw.HnswIndex.load(HnswIndex.java:871)
	at com.l3agent.service.impl.HnswVectorStoreService.loadIndex(HnswVectorStoreService.java:326)
	at com.l3agent.service.impl.HnswVectorStoreService.initializeNamespace(HnswVectorStoreService.java:209)
	at com.l3agent.service.impl.HnswVectorStoreService.init(HnswVectorStoreService.java:175)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMethod.invoke(InitDestroyAnnotationBeanPostProcessor.java:457)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMetadata.invokeInitMethods(InitDestroyAnnotationBeanPostProcessor.java:401)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor.postProcessBeforeInitialization(InitDestroyAnnotationBeanPostProcessor.java:219)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsBeforeInitialization(AbstractAutowireCapableBeanFactory.java:419)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1762)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:598)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:254)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1417)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1337)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:713)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:696)
	at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:145)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:483)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1416)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:597)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:254)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1417)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1337)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:713)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:696)
	at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:145)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:483)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1416)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:597)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:254)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1417)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1337)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:713)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:696)
	at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:145)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:483)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1416)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:597)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:973)
	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:942)
	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:608)
	at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:146)
	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:734)
	at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:436)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:312)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1306)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1295)
	at com.l3agent.Application.main(Application.java:13)
Caused by: java.lang.reflect.InvocationTargetException: null
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:118)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at java.base/java.lang.invoke.SerializedLambda.readResolve(SerializedLambda.java:278)
	... 87 common frames omitted
Caused by: java.lang.IllegalArgumentException: Invalid lambda deserialization
	at com.l3agent.service.impl.HnswVectorStoreService.$deserializeLambda$(HnswVectorStoreService.java:57)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	... 89 common frames omitted
2025-05-13 15:06:15 [main] INFO  c.l.s.impl.HnswVectorStoreService - Creating new vector index for namespace default with dimension 384
2025-05-13 15:06:15 [main] INFO  c.l.s.impl.HnswVectorStoreService - Loaded metadata for 194 embeddings in namespace default
2025-05-13 15:06:15 [main] INFO  c.l.s.impl.HnswVectorStoreService - Loaded existing vector store for namespace default with 0 embeddings
2025-05-13 15:06:15 [main] INFO  c.l.s.impl.HnswVectorStoreService - Loaded 189 embedding failures
2025-05-13 15:06:15 [main] INFO  c.l.s.i.VectorBasedCodeRepositoryService - Indexing code repository at ./data/code
2025-05-13 15:06:19 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:06:19 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:06:19 [main] DEBUG c.l.s.i.VectorBasedCodeRepositoryService - Skipping binary file: gs-integrations/connectors/src/main/resources/00D1I000000oG8e_1.jks
2025-05-13 15:06:25 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:06:25 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:06:27 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:06:27 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:06:32 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:06:32 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:06:43 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:06:43 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:06:49 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:06:49 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:06:51 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:06:51 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:06:54 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:06:54 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:07:00 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:07:00 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:07:02 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:07:02 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:07:09 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:07:09 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:07:10 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:07:10 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:07:13 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:07:13 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:07:28 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:07:28 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:07:32 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:07:32 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:07:37 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:07:37 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:07:45 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:07:45 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:07:50 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:07:50 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:07:57 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:07:57 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:08:02 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:08:02 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:08:05 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:08:05 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:08:15 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:08:15 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:08:16 [main] INFO  com.l3agent.Application - Starting Application using Java 21.0.1 with PID 49678 (/Users/psambaraju/Desktop/cursorProjects/l3AgentNew/target/classes started by psambaraju in /Users/psambaraju/Desktop/cursorProjects/l3AgentNew)
2025-05-13 15:08:16 [main] DEBUG com.l3agent.Application - Running with Spring Boot v3.1.3, Spring v6.0.11
2025-05-13 15:08:16 [main] INFO  com.l3agent.Application - The following 1 profile is active: "nodb"
2025-05-13 15:08:16 [main] INFO  o.s.d.r.c.RepositoryConfigurationDelegate - Bootstrapping Spring Data JPA repositories in DEFAULT mode.
2025-05-13 15:08:16 [main] INFO  o.s.d.r.c.RepositoryConfigurationDelegate - Finished Spring Data repository scanning in 3 ms. Found 0 JPA repository interfaces.
2025-05-13 15:08:16 [main] INFO  o.s.b.w.e.tomcat.TomcatWebServer - Tomcat initialized with port(s): 8080 (http)
2025-05-13 15:08:16 [main] INFO  o.a.catalina.core.StandardService - Starting service [Tomcat]
2025-05-13 15:08:16 [main] INFO  o.a.catalina.core.StandardEngine - Starting Servlet engine: [Apache Tomcat/10.1.12]
2025-05-13 15:08:16 [main] INFO  o.a.c.c.C.[.[localhost].[/l3agent] - Initializing Spring embedded WebApplicationContext
2025-05-13 15:08:16 [main] INFO  o.s.b.w.s.c.ServletWebServerApplicationContext - Root WebApplicationContext: initialization completed in 661 ms
2025-05-13 15:08:16 [main] DEBUG c.l.s.impl.FileBasedTicketService - Loaded ticket TICKET-1234 from ./data/tickets/TICKET-1234.json
2025-05-13 15:08:16 [main] INFO  c.l.s.impl.HnswVectorStoreService - Loaded 1 repository namespaces
2025-05-13 15:08:16 [main] INFO  c.l.s.impl.HnswVectorStoreService - Created directory: ./data/vector-store/default
2025-05-13 15:08:16 [main] INFO  c.l.s.impl.HnswVectorStoreService - Creating new vector index for namespace default with dimension 3072
2025-05-13 15:08:16 [main] INFO  c.l.s.impl.HnswVectorStoreService - Created new vector store for namespace default
2025-05-13 15:08:16 [main] INFO  c.l.s.impl.HnswVectorStoreService - Loaded 189 embedding failures
2025-05-13 15:08:16 [main] DEBUG c.l.s.i.FileBasedKnowledgeBaseService - Loaded article: KB001 - Resolving NullPointerException in TaskProcessor
2025-05-13 15:08:16 [main] DEBUG c.l.s.i.FileBasedKnowledgeBaseService - Loaded article: KB002 - Troubleshooting Salesforce API Connection Timeouts
2025-05-13 15:08:16 [main] DEBUG c.l.s.i.FileBasedKnowledgeBaseService - Loaded article: KB003 - Resolving Database Connection Issues in Gainsight Adapter
2025-05-13 15:08:16 [main] INFO  c.l.s.i.FileBasedKnowledgeBaseService - Loaded 3 knowledge articles
2025-05-13 15:08:16 [main] WARN  o.s.b.w.s.c.AnnotationConfigServletWebServerApplicationContext - Exception encountered during context initialization - cancelling refresh attempt: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'embeddingGenerationRunner': Unsatisfied dependency expressed through field 'l3AgentService': Error creating bean with name 'basicL3AgentService': Unsatisfied dependency expressed through field 'llmService': Error creating bean with name 'llmService' defined in class path resource [com/l3agent/config/LLMConfiguration.class]: Failed to instantiate [com.l3agent.service.LLMService]: Factory method 'llmService' threw exception with message: No bean named 'openAiLLMService' available
2025-05-13 15:08:16 [main] INFO  c.l.s.impl.HnswVectorStoreService - Saved index for namespace default to /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/vector-store/default/hnsw_index.bin
2025-05-13 15:08:16 [main] INFO  c.l.s.impl.HnswVectorStoreService - Saved metadata for namespace default to /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/vector-store/default/embedding_metadata.json
2025-05-13 15:08:16 [main] INFO  c.l.s.impl.HnswVectorStoreService - Saved 189 embedding failures to /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/vector-store/embedding_failures.json
2025-05-13 15:08:16 [main] INFO  c.l.s.impl.HnswVectorStoreService - Saved 1 repository namespaces
2025-05-13 15:08:16 [main] INFO  o.a.catalina.core.StandardService - Stopping service [Tomcat]
2025-05-13 15:08:16 [main] INFO  o.s.b.a.l.ConditionEvaluationReportLogger - 

Error starting ApplicationContext. To display the condition evaluation report re-run your application with 'debug' enabled.
2025-05-13 15:08:16 [main] ERROR o.s.b.d.LoggingFailureAnalysisReporter - 

***************************
APPLICATION FAILED TO START
***************************

Description:

Field llmService in com.l3agent.service.impl.BasicL3AgentService required a bean named 'openAiLLMService' that could not be found.

The injection point has the following annotations:
	- @org.springframework.beans.factory.annotation.Autowired(required=true)


Action:

Consider defining a bean named 'openAiLLMService' in your configuration.

2025-05-13 15:08:21 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:08:21 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:08:22 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:08:22 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:08:26 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:08:26 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:08:33 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:08:33 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:08:37 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:08:37 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:08:40 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:08:40 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:08:44 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:08:44 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:08:47 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:08:47 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:08:55 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:08:55 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:08:57 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:08:57 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:09:00 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:09:00 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:09:04 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:09:04 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:09:08 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:09:08 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:09:18 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:09:18 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:09:20 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:09:20 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:09:23 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:09:23 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:09:26 [main] INFO  com.l3agent.Application - Starting Application using Java 21.0.1 with PID 50973 (/Users/psambaraju/Desktop/cursorProjects/l3AgentNew/target/classes started by psambaraju in /Users/psambaraju/Desktop/cursorProjects/l3AgentNew)
2025-05-13 15:09:26 [main] DEBUG com.l3agent.Application - Running with Spring Boot v3.1.3, Spring v6.0.11
2025-05-13 15:09:26 [main] INFO  com.l3agent.Application - The following 1 profile is active: "nodb"
2025-05-13 15:09:26 [main] WARN  o.s.b.w.s.c.AnnotationConfigServletWebServerApplicationContext - Exception encountered during context initialization - cancelling refresh attempt: org.springframework.beans.factory.support.BeanDefinitionOverrideException: Invalid bean definition with name 'gainsightLLMService' defined in class path resource [com/l3agent/config/LLMConfiguration.class]: Cannot register bean definition [Root bean: class [null]; scope=; abstract=false; lazyInit=null; autowireMode=3; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=LLMConfiguration; factoryMethodName=gainsightLLMService; initMethodNames=null; destroyMethodNames=[(inferred)]; defined in class path resource [com/l3agent/config/LLMConfiguration.class]] for bean 'gainsightLLMService' since there is already [Generic bean: class [com.l3agent.service.impl.GainsightLLMService]; scope=singleton; abstract=false; lazyInit=null; autowireMode=0; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=null; factoryMethodName=null; initMethodNames=null; destroyMethodNames=null; defined in file [/Users/psambaraju/Desktop/cursorProjects/l3AgentNew/target/classes/com/l3agent/service/impl/GainsightLLMService.class]] bound.
2025-05-13 15:09:26 [main] INFO  o.s.b.a.l.ConditionEvaluationReportLogger - 

Error starting ApplicationContext. To display the condition evaluation report re-run your application with 'debug' enabled.
2025-05-13 15:09:26 [main] ERROR o.s.b.d.LoggingFailureAnalysisReporter - 

***************************
APPLICATION FAILED TO START
***************************

Description:

The bean 'gainsightLLMService', defined in class path resource [com/l3agent/config/LLMConfiguration.class], could not be registered. A bean with that name has already been defined in file [/Users/psambaraju/Desktop/cursorProjects/l3AgentNew/target/classes/com/l3agent/service/impl/GainsightLLMService.class] and overriding is disabled.

Action:

Consider renaming one of the beans or enabling overriding by setting spring.main.allow-bean-definition-overriding=true

2025-05-13 15:09:29 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:09:29 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:09:31 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:09:31 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:09:35 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:09:35 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:09:40 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:09:40 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:09:46 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:09:46 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:09:49 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:09:49 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:09:59 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:09:59 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:10:04 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:10:04 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:10:05 [main] INFO  com.l3agent.Application - Starting Application using Java 21.0.1 with PID 51710 (/Users/psambaraju/Desktop/cursorProjects/l3AgentNew/target/classes started by psambaraju in /Users/psambaraju/Desktop/cursorProjects/l3AgentNew)
2025-05-13 15:10:05 [main] DEBUG com.l3agent.Application - Running with Spring Boot v3.1.3, Spring v6.0.11
2025-05-13 15:10:05 [main] INFO  com.l3agent.Application - The following 1 profile is active: "nodb"
2025-05-13 15:10:05 [main] WARN  o.s.b.w.s.c.AnnotationConfigServletWebServerApplicationContext - Exception encountered during context initialization - cancelling refresh attempt: org.springframework.beans.factory.support.BeanDefinitionOverrideException: Invalid bean definition with name 'gainsightLLMService' defined in class path resource [com/l3agent/config/LLMConfiguration.class]: Cannot register bean definition [Root bean: class [null]; scope=; abstract=false; lazyInit=null; autowireMode=3; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=LLMConfiguration; factoryMethodName=gainsightLLMService; initMethodNames=null; destroyMethodNames=[(inferred)]; defined in class path resource [com/l3agent/config/LLMConfiguration.class]] for bean 'gainsightLLMService' since there is already [Generic bean: class [com.l3agent.service.impl.GainsightLLMService]; scope=singleton; abstract=false; lazyInit=null; autowireMode=0; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=null; factoryMethodName=null; initMethodNames=null; destroyMethodNames=null; defined in file [/Users/psambaraju/Desktop/cursorProjects/l3AgentNew/target/classes/com/l3agent/service/impl/GainsightLLMService.class]] bound.
2025-05-13 15:10:05 [main] INFO  o.s.b.a.l.ConditionEvaluationReportLogger - 

Error starting ApplicationContext. To display the condition evaluation report re-run your application with 'debug' enabled.
2025-05-13 15:10:05 [main] ERROR o.s.b.d.LoggingFailureAnalysisReporter - 

***************************
APPLICATION FAILED TO START
***************************

Description:

The bean 'gainsightLLMService', defined in class path resource [com/l3agent/config/LLMConfiguration.class], could not be registered. A bean with that name has already been defined in file [/Users/psambaraju/Desktop/cursorProjects/l3AgentNew/target/classes/com/l3agent/service/impl/GainsightLLMService.class] and overriding is disabled.

Action:

Consider renaming one of the beans or enabling overriding by setting spring.main.allow-bean-definition-overriding=true

2025-05-13 15:10:07 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:10:07 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:10:11 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:10:11 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:10:15 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:10:15 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:10:23 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:10:23 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:10:32 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:10:32 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:10:41 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:10:41 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:10:46 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:10:46 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:10:50 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:10:50 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:10:55 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:10:55 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:10:59 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:10:59 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:11:04 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:11:04 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:11:08 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:11:08 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:11:11 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:11:11 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:11:17 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:11:17 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:11:21 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:11:21 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:11:30 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:11:30 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:11:31 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:11:31 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:11:41 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:11:41 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:11:47 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:11:47 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:11:52 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:11:52 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:11:55 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:11:55 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:12:02 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:12:02 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:12:06 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:12:06 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:12:11 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:12:11 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:12:15 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:12:15 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:12:18 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:12:18 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:12:23 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:12:23 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:12:27 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:12:27 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:12:30 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:12:30 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:12:37 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:12:37 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:12:43 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:12:43 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:12:46 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:12:46 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:12:52 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:12:52 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:12:54 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:12:54 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:12:58 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:12:58 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:13:02 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:13:02 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:13:06 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:13:06 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:13:10 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:13:10 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:13:13 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:13:13 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:13:21 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:13:21 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:13:26 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:13:26 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:13:33 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:13:33 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:13:39 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:13:39 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:13:46 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:13:46 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:13:50 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:13:50 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:13:54 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:13:54 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:13:58 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:13:58 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:14:02 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:14:02 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:14:18 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:14:18 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:14:21 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:14:21 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:14:29 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:14:29 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:14:39 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:14:39 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:14:43 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:14:43 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:14:46 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:14:46 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:14:46 [main] INFO  c.l.s.impl.HnswVectorStoreService - Saved index for namespace default to /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/vector-store /default/hnsw_index.bin
2025-05-13 15:14:46 [main] INFO  c.l.s.impl.HnswVectorStoreService - Saved metadata for namespace default to /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/vector-store /default/embedding_metadata.json
2025-05-13 15:14:52 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:14:52 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:14:54 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:14:54 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:14:59 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:14:59 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:15:02 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:15:02 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:15:06 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:15:06 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:15:10 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:15:10 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:15:12 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:15:12 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:15:17 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:15:17 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:15:20 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:15:20 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:15:24 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:15:24 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:15:26 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:15:26 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:15:28 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:15:28 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:15:33 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:15:33 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:15:39 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:15:39 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:15:46 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:15:46 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:15:48 [main] INFO  com.l3agent.Application - Starting Application using Java 21.0.1 with PID 57877 (/Users/psambaraju/Desktop/cursorProjects/l3AgentNew/target/classes started by psambaraju in /Users/psambaraju/Desktop/cursorProjects/l3AgentNew)
2025-05-13 15:15:48 [main] DEBUG com.l3agent.Application - Running with Spring Boot v3.1.3, Spring v6.0.11
2025-05-13 15:15:48 [main] INFO  com.l3agent.Application - The following 1 profile is active: "nodb"
2025-05-13 15:15:49 [main] INFO  o.s.d.r.c.RepositoryConfigurationDelegate - Bootstrapping Spring Data JPA repositories in DEFAULT mode.
2025-05-13 15:15:49 [main] INFO  o.s.d.r.c.RepositoryConfigurationDelegate - Finished Spring Data repository scanning in 5 ms. Found 0 JPA repository interfaces.
2025-05-13 15:15:49 [main] INFO  o.s.b.w.e.tomcat.TomcatWebServer - Tomcat initialized with port(s): 8080 (http)
2025-05-13 15:15:49 [main] INFO  o.a.catalina.core.StandardService - Starting service [Tomcat]
2025-05-13 15:15:49 [main] INFO  o.a.catalina.core.StandardEngine - Starting Servlet engine: [Apache Tomcat/10.1.12]
2025-05-13 15:15:49 [main] INFO  o.a.c.c.C.[.[localhost].[/l3agent] - Initializing Spring embedded WebApplicationContext
2025-05-13 15:15:49 [main] INFO  o.s.b.w.s.c.ServletWebServerApplicationContext - Root WebApplicationContext: initialization completed in 929 ms
2025-05-13 15:15:49 [main] DEBUG c.l.s.impl.FileBasedTicketService - Loaded ticket TICKET-1234 from ./data/tickets/TICKET-1234.json
2025-05-13 15:15:49 [main] INFO  c.l.s.impl.HnswVectorStoreService - Loaded 1 repository namespaces
2025-05-13 15:15:50 [main] INFO  c.l.s.impl.HnswVectorStoreService - Loaded index for namespace default from /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/vector-store/default/hnsw_index.bin
2025-05-13 15:15:50 [main] INFO  c.l.s.impl.HnswVectorStoreService - Loaded metadata for 0 embeddings in namespace default
2025-05-13 15:15:50 [main] INFO  c.l.s.impl.HnswVectorStoreService - Loaded existing vector store for namespace default with 0 embeddings
2025-05-13 15:15:50 [main] INFO  c.l.s.impl.HnswVectorStoreService - Loaded 189 embedding failures
2025-05-13 15:15:50 [main] DEBUG c.l.s.i.FileBasedKnowledgeBaseService - Loaded article: KB001 - Resolving NullPointerException in TaskProcessor
2025-05-13 15:15:50 [main] DEBUG c.l.s.i.FileBasedKnowledgeBaseService - Loaded article: KB002 - Troubleshooting Salesforce API Connection Timeouts
2025-05-13 15:15:50 [main] DEBUG c.l.s.i.FileBasedKnowledgeBaseService - Loaded article: KB003 - Resolving Database Connection Issues in Gainsight Adapter
2025-05-13 15:15:50 [main] INFO  c.l.s.i.FileBasedKnowledgeBaseService - Loaded 3 knowledge articles
2025-05-13 15:15:50 [main] WARN  o.s.b.w.s.c.AnnotationConfigServletWebServerApplicationContext - Exception encountered during context initialization - cancelling refresh attempt: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'embeddingGenerationRunner': Unsatisfied dependency expressed through field 'l3AgentService': Error creating bean with name 'basicL3AgentService': Unsatisfied dependency expressed through field 'llmService': Error creating bean with name 'llmService' defined in class path resource [com/l3agent/config/LLMConfiguration.class]: Failed to instantiate [com.l3agent.service.LLMService]: Factory method 'llmService' threw exception with message: No bean named 'openAiLLMService' available
2025-05-13 15:15:50 [main] INFO  c.l.s.impl.HnswVectorStoreService - Saved index for namespace default to /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/vector-store/default/hnsw_index.bin
2025-05-13 15:15:50 [main] INFO  c.l.s.impl.HnswVectorStoreService - Saved metadata for namespace default to /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/vector-store/default/embedding_metadata.json
2025-05-13 15:15:50 [main] INFO  c.l.s.impl.HnswVectorStoreService - Saved 189 embedding failures to /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/vector-store/embedding_failures.json
2025-05-13 15:15:50 [main] INFO  c.l.s.impl.HnswVectorStoreService - Saved 1 repository namespaces
2025-05-13 15:15:50 [main] INFO  o.a.catalina.core.StandardService - Stopping service [Tomcat]
2025-05-13 15:15:50 [main] INFO  o.s.b.a.l.ConditionEvaluationReportLogger - 

Error starting ApplicationContext. To display the condition evaluation report re-run your application with 'debug' enabled.
2025-05-13 15:15:50 [main] ERROR o.s.b.d.LoggingFailureAnalysisReporter - 

***************************
APPLICATION FAILED TO START
***************************

Description:

Field llmService in com.l3agent.service.impl.BasicL3AgentService required a bean named 'openAiLLMService' that could not be found.

The injection point has the following annotations:
	- @org.springframework.beans.factory.annotation.Autowired(required=true)


Action:

Consider defining a bean named 'openAiLLMService' in your configuration.

2025-05-13 15:15:51 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:15:51 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:15:53 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:15:53 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:15:56 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:15:56 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:15:58 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:15:58 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:16:01 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:16:01 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:16:09 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:16:09 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:16:13 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:16:13 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:16:26 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:16:26 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:16:30 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:16:30 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:16:32 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:16:32 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:16:38 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:16:38 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:16:41 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:16:41 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:16:43 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:16:43 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:16:48 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:16:48 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:16:52 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:16:52 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:17:00 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:17:00 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:17:06 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:17:06 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:17:11 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:17:11 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:17:15 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:17:15 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:17:19 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:17:19 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:17:24 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:17:24 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:17:26 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:17:26 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:17:29 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:17:29 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:17:37 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:17:37 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:17:39 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:17:39 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:17:45 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:17:45 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:17:50 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:17:50 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:17:53 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:17:53 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:17:57 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:17:57 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:18:01 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:18:01 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:18:12 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:18:12 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:18:22 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:18:22 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:18:30 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:18:30 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:18:34 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:18:34 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:18:38 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:18:38 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:18:40 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:18:40 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:18:43 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:18:43 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:18:49 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:18:49 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:18:52 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:18:52 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:18:56 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:18:56 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:18:58 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:18:58 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:19:03 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:19:03 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:19:09 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:19:09 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:19:16 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:19:16 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:19:18 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:19:18 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:19:25 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:19:25 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:19:31 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:19:31 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:19:39 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:19:39 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:19:43 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:19:43 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:19:45 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:19:45 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:19:48 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:19:48 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:19:53 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:19:53 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:20:00 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:20:00 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:20:04 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:20:04 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:20:07 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:20:07 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:20:08 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:20:08 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:20:14 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:20:14 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:20:19 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:20:19 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:20:22 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:20:22 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:20:25 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:20:25 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:20:31 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:20:31 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:20:35 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:20:35 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:20:40 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:20:40 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:20:48 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:20:48 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:20:51 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:20:51 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:20:56 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:20:56 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:20:56 [main] INFO  com.l3agent.Application - Starting Application using Java 21.0.1 with PID 63315 (/Users/psambaraju/Desktop/cursorProjects/l3AgentNew/target/classes started by psambaraju in /Users/psambaraju/Desktop/cursorProjects/l3AgentNew)
2025-05-13 15:20:56 [main] DEBUG com.l3agent.Application - Running with Spring Boot v3.1.3, Spring v6.0.11
2025-05-13 15:20:56 [main] INFO  com.l3agent.Application - The following 1 profile is active: "nodb"
2025-05-13 15:20:56 [main] INFO  o.s.d.r.c.RepositoryConfigurationDelegate - Bootstrapping Spring Data JPA repositories in DEFAULT mode.
2025-05-13 15:20:56 [main] INFO  o.s.d.r.c.RepositoryConfigurationDelegate - Finished Spring Data repository scanning in 3 ms. Found 0 JPA repository interfaces.
2025-05-13 15:20:57 [main] INFO  o.s.b.w.e.tomcat.TomcatWebServer - Tomcat initialized with port(s): 8080 (http)
2025-05-13 15:20:57 [main] INFO  o.a.catalina.core.StandardService - Starting service [Tomcat]
2025-05-13 15:20:57 [main] INFO  o.a.catalina.core.StandardEngine - Starting Servlet engine: [Apache Tomcat/10.1.12]
2025-05-13 15:20:57 [main] INFO  o.a.c.c.C.[.[localhost].[/l3agent] - Initializing Spring embedded WebApplicationContext
2025-05-13 15:20:57 [main] INFO  o.s.b.w.s.c.ServletWebServerApplicationContext - Root WebApplicationContext: initialization completed in 661 ms
2025-05-13 15:20:57 [main] DEBUG c.l.s.impl.FileBasedTicketService - Loaded ticket TICKET-1234 from ./data/tickets/TICKET-1234.json
2025-05-13 15:20:57 [main] INFO  c.l.s.impl.HnswVectorStoreService - Loaded 1 repository namespaces
2025-05-13 15:20:57 [main] INFO  c.l.s.impl.HnswVectorStoreService - Loaded index for namespace default from /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/vector-store/default/hnsw_index.bin
2025-05-13 15:20:57 [main] INFO  c.l.s.impl.HnswVectorStoreService - Loaded metadata for 0 embeddings in namespace default
2025-05-13 15:20:57 [main] INFO  c.l.s.impl.HnswVectorStoreService - Loaded existing vector store for namespace default with 0 embeddings
2025-05-13 15:20:57 [main] INFO  c.l.s.impl.HnswVectorStoreService - Loaded 189 embedding failures
2025-05-13 15:20:57 [main] DEBUG c.l.s.i.FileBasedKnowledgeBaseService - Loaded article: KB001 - Resolving NullPointerException in TaskProcessor
2025-05-13 15:20:57 [main] DEBUG c.l.s.i.FileBasedKnowledgeBaseService - Loaded article: KB002 - Troubleshooting Salesforce API Connection Timeouts
2025-05-13 15:20:57 [main] DEBUG c.l.s.i.FileBasedKnowledgeBaseService - Loaded article: KB003 - Resolving Database Connection Issues in Gainsight Adapter
2025-05-13 15:20:57 [main] INFO  c.l.s.i.FileBasedKnowledgeBaseService - Loaded 3 knowledge articles
2025-05-13 15:20:57 [main] WARN  o.s.b.w.s.c.AnnotationConfigServletWebServerApplicationContext - Exception encountered during context initialization - cancelling refresh attempt: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'embeddingGenerationRunner': Unsatisfied dependency expressed through field 'l3AgentService': Error creating bean with name 'basicL3AgentService': Unsatisfied dependency expressed through field 'llmService': Error creating bean with name 'llmService' defined in class path resource [com/l3agent/config/LLMConfiguration.class]: Failed to instantiate [com.l3agent.service.LLMService]: Factory method 'llmService' threw exception with message: No valid LLM provider configured. Please check your configuration.
2025-05-13 15:20:57 [main] INFO  c.l.s.impl.HnswVectorStoreService - Saved index for namespace default to /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/vector-store/default/hnsw_index.bin
2025-05-13 15:20:57 [main] INFO  c.l.s.impl.HnswVectorStoreService - Saved metadata for namespace default to /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/vector-store/default/embedding_metadata.json
2025-05-13 15:20:57 [main] INFO  c.l.s.impl.HnswVectorStoreService - Saved 189 embedding failures to /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/vector-store/embedding_failures.json
2025-05-13 15:20:57 [main] INFO  c.l.s.impl.HnswVectorStoreService - Saved 1 repository namespaces
2025-05-13 15:20:57 [main] INFO  o.a.catalina.core.StandardService - Stopping service [Tomcat]
2025-05-13 15:20:57 [main] INFO  o.s.b.a.l.ConditionEvaluationReportLogger - 

Error starting ApplicationContext. To display the condition evaluation report re-run your application with 'debug' enabled.
2025-05-13 15:20:57 [main] ERROR o.s.boot.SpringApplication - Application run failed
org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'embeddingGenerationRunner': Unsatisfied dependency expressed through field 'l3AgentService': Error creating bean with name 'basicL3AgentService': Unsatisfied dependency expressed through field 'llmService': Error creating bean with name 'llmService' defined in class path resource [com/l3agent/config/LLMConfiguration.class]: Failed to instantiate [com.l3agent.service.LLMService]: Factory method 'llmService' threw exception with message: No valid LLM provider configured. Please check your configuration.
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:716)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:696)
	at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:145)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:483)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1416)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:597)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:973)
	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:942)
	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:608)
	at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:146)
	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:734)
	at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:436)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:312)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1306)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1295)
	at com.l3agent.Application.main(Application.java:13)
Caused by: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'basicL3AgentService': Unsatisfied dependency expressed through field 'llmService': Error creating bean with name 'llmService' defined in class path resource [com/l3agent/config/LLMConfiguration.class]: Failed to instantiate [com.l3agent.service.LLMService]: Factory method 'llmService' threw exception with message: No valid LLM provider configured. Please check your configuration.
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:716)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:696)
	at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:145)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:483)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1416)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:597)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:254)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1417)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1337)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:713)
	... 20 common frames omitted
Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'llmService' defined in class path resource [com/l3agent/config/LLMConfiguration.class]: Failed to instantiate [com.l3agent.service.LLMService]: Factory method 'llmService' threw exception with message: No valid LLM provider configured. Please check your configuration.
	at org.springframework.beans.factory.support.ConstructorResolver.instantiate(ConstructorResolver.java:659)
	at org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:493)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateUsingFactoryMethod(AbstractAutowireCapableBeanFactory.java:1332)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1162)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:560)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:254)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1417)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1337)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:713)
	... 34 common frames omitted
Caused by: org.springframework.beans.BeanInstantiationException: Failed to instantiate [com.l3agent.service.LLMService]: Factory method 'llmService' threw exception with message: No valid LLM provider configured. Please check your configuration.
	at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:171)
	at org.springframework.beans.factory.support.ConstructorResolver.instantiate(ConstructorResolver.java:655)
	... 47 common frames omitted
Caused by: java.lang.IllegalStateException: No valid LLM provider configured. Please check your configuration.
	at com.l3agent.config.LLMConfiguration.llmService(LLMConfiguration.java:49)
	at com.l3agent.config.LLMConfiguration$$SpringCGLIB$$0.CGLIB$llmService$1(<generated>)
	at com.l3agent.config.LLMConfiguration$$SpringCGLIB$$2.invoke(<generated>)
	at org.springframework.cglib.proxy.MethodProxy.invokeSuper(MethodProxy.java:258)
	at org.springframework.context.annotation.ConfigurationClassEnhancer$BeanMethodInterceptor.intercept(ConfigurationClassEnhancer.java:331)
	at com.l3agent.config.LLMConfiguration$$SpringCGLIB$$0.llmService(<generated>)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:139)
	... 48 common frames omitted
2025-05-13 15:21:03 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:21:03 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:21:06 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:21:06 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:21:09 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:21:09 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:21:13 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:21:13 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:21:17 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:21:17 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:21:22 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:21:22 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:21:27 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:21:27 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:21:30 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:21:30 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:21:32 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:21:32 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:21:37 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:21:37 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:21:47 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:21:47 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:21:50 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:21:50 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:21:52 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:21:52 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:21:57 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:21:57 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:22:00 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:22:00 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:22:03 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 15:22:03 [main] WARN  c.l.s.impl.HnswVectorStoreService - API returned 3072 dimensions, truncating to expected 384 dimensions
2025-05-13 15:22:39 [main] WARN  o.s.b.w.s.c.AnnotationConfigServletWebServerApplicationContext - Exception encountered during context initialization - cancelling refresh attempt: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'embeddingGenerationRunner': Unsatisfied dependency expressed through field 'l3AgentService': Error creating bean with name 'basicL3AgentService': Unsatisfied dependency expressed through field 'codeRepositoryService': Error creating bean with name 'vectorBasedCodeRepositoryService': Invocation of init method failed
2025-05-13 15:22:39 [main] INFO  c.l.s.impl.HnswVectorStoreService - Saved index for namespace default to /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/vector-store /default/hnsw_index.bin
2025-05-13 15:22:39 [main] INFO  c.l.s.impl.HnswVectorStoreService - Saved metadata for namespace default to /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/vector-store /default/embedding_metadata.json
2025-05-13 15:22:39 [main] INFO  c.l.s.impl.HnswVectorStoreService - Saved 189 embedding failures to /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/vector-store /embedding_failures.json
2025-05-13 15:22:39 [main] INFO  c.l.s.impl.HnswVectorStoreService - Saved 1 repository namespaces
2025-05-13 15:24:41 [main] INFO  com.l3agent.Application - Starting Application using Java 21.0.1 with PID 67229 (/Users/psambaraju/Desktop/cursorProjects/l3AgentNew/target/classes started by psambaraju in /Users/psambaraju/Desktop/cursorProjects/l3AgentNew)
2025-05-13 15:24:41 [main] DEBUG com.l3agent.Application - Running with Spring Boot v3.1.3, Spring v6.0.11
2025-05-13 15:24:41 [main] INFO  com.l3agent.Application - The following 1 profile is active: "nodb"
2025-05-13 15:24:41 [main] INFO  o.s.d.r.c.RepositoryConfigurationDelegate - Bootstrapping Spring Data JPA repositories in DEFAULT mode.
2025-05-13 15:24:41 [main] INFO  o.s.d.r.c.RepositoryConfigurationDelegate - Finished Spring Data repository scanning in 4 ms. Found 0 JPA repository interfaces.
2025-05-13 15:24:41 [main] INFO  o.s.b.w.e.tomcat.TomcatWebServer - Tomcat initialized with port(s): 8080 (http)
2025-05-13 15:24:41 [main] INFO  o.a.catalina.core.StandardService - Starting service [Tomcat]
2025-05-13 15:24:41 [main] INFO  o.a.catalina.core.StandardEngine - Starting Servlet engine: [Apache Tomcat/10.1.12]
2025-05-13 15:24:41 [main] INFO  o.a.c.c.C.[.[localhost].[/l3agent] - Initializing Spring embedded WebApplicationContext
2025-05-13 15:24:41 [main] INFO  o.s.b.w.s.c.ServletWebServerApplicationContext - Root WebApplicationContext: initialization completed in 634 ms
2025-05-13 15:24:41 [main] DEBUG c.l.s.impl.FileBasedTicketService - Loaded ticket TICKET-1234 from ./data/tickets/TICKET-1234.json
2025-05-13 15:24:41 [main] INFO  c.l.s.impl.HnswVectorStoreService - Loaded 1 repository namespaces
2025-05-13 15:24:41 [main] INFO  c.l.s.impl.HnswVectorStoreService - Loaded index for namespace default from /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/vector-store/default/hnsw_index.bin
2025-05-13 15:24:41 [main] INFO  c.l.s.impl.HnswVectorStoreService - Loaded metadata for 0 embeddings in namespace default
2025-05-13 15:24:41 [main] INFO  c.l.s.impl.HnswVectorStoreService - Loaded existing vector store for namespace default with 0 embeddings
2025-05-13 15:24:41 [main] INFO  c.l.s.impl.HnswVectorStoreService - Loaded 189 embedding failures
2025-05-13 15:24:41 [main] DEBUG c.l.s.i.FileBasedKnowledgeBaseService - Loaded article: KB001 - Resolving NullPointerException in TaskProcessor
2025-05-13 15:24:41 [main] DEBUG c.l.s.i.FileBasedKnowledgeBaseService - Loaded article: KB002 - Troubleshooting Salesforce API Connection Timeouts
2025-05-13 15:24:41 [main] DEBUG c.l.s.i.FileBasedKnowledgeBaseService - Loaded article: KB003 - Resolving Database Connection Issues in Gainsight Adapter
2025-05-13 15:24:41 [main] INFO  c.l.s.i.FileBasedKnowledgeBaseService - Loaded 3 knowledge articles
2025-05-13 15:24:41 [main] INFO  c.l.service.impl.GainsightLLMService - Gainsight LLM service initialized with default model: gpt-4o (version: 2024-05-13)
2025-05-13 15:24:41 [main] INFO  c.l.r.NullLLMMetadataRepository - Using NullLLMMetadataRepository - database operations will be no-ops
2025-05-13 15:24:41 [main] INFO  com.l3agent.config.LLMConfiguration - Using Gainsight LLM service
2025-05-13 15:24:41 [main] INFO  c.l.s.i.InMemoryKnowledgeGraphService - Created knowledge graph directory: ./data/knowledge-graph
2025-05-13 15:24:41 [main] INFO  c.l.s.i.InMemoryKnowledgeGraphService - No existing knowledge graph found. Starting with empty graph.
2025-05-13 15:24:41 [main] INFO  c.l.s.i.FileBasedCodeRepositoryService - Code repository service initialized with directory: ./data/code
2025-05-13 15:24:41 [main] INFO  c.l.s.i.FileBasedCodeRepositoryService - Found repository: gs-integrations
2025-05-13 15:24:41 [main] INFO  c.l.s.i.FileBasedCodeRepositoryService - Found repository: dp_dynamic_tasks
2025-05-13 15:24:41 [main] INFO  c.l.s.i.FileBasedCodeRepositoryService - Found repository: gs-duct
2025-05-13 15:24:41 [main] INFO  c.l.s.i.FileBasedCodeRepositoryService - Found repository: data
2025-05-13 15:24:41 [main] INFO  c.l.s.i.FileBasedCodeRepositoryService - Found repository: gainsight-adapter
2025-05-13 15:24:41 [main] WARN  o.s.b.w.s.c.AnnotationConfigServletWebServerApplicationContext - Exception encountered during context initialization - cancelling refresh attempt: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'jpaSharedEM_entityManagerFactory': Cannot resolve reference to bean 'entityManagerFactory' while setting constructor argument
2025-05-13 15:24:41 [main] INFO  c.l.s.i.InMemoryKnowledgeGraphService - Saved knowledge graph to /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/knowledge-graph/knowledge_graph.bin
2025-05-13 15:24:42 [main] INFO  c.l.s.impl.HnswVectorStoreService - Saved index for namespace default to /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/vector-store/default/hnsw_index.bin
2025-05-13 15:24:42 [main] INFO  c.l.s.impl.HnswVectorStoreService - Saved metadata for namespace default to /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/vector-store/default/embedding_metadata.json
2025-05-13 15:24:42 [main] INFO  c.l.s.impl.HnswVectorStoreService - Saved 189 embedding failures to /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/vector-store/embedding_failures.json
2025-05-13 15:24:42 [main] INFO  c.l.s.impl.HnswVectorStoreService - Saved 1 repository namespaces
2025-05-13 15:24:42 [main] INFO  o.a.catalina.core.StandardService - Stopping service [Tomcat]
2025-05-13 15:24:42 [main] INFO  o.s.b.a.l.ConditionEvaluationReportLogger - 

Error starting ApplicationContext. To display the condition evaluation report re-run your application with 'debug' enabled.
2025-05-13 15:24:42 [main] ERROR o.s.b.d.LoggingFailureAnalysisReporter - 

***************************
APPLICATION FAILED TO START
***************************

Description:

A component required a bean named 'entityManagerFactory' that could not be found.


Action:

Consider defining a bean named 'entityManagerFactory' in your configuration.

2025-05-13 15:28:30 [main] INFO  com.l3agent.Application - Starting Application using Java 21.0.1 with PID 71320 (/Users/psambaraju/Desktop/cursorProjects/l3AgentNew/target/classes started by psambaraju in /Users/psambaraju/Desktop/cursorProjects/l3AgentNew)
2025-05-13 15:28:30 [main] DEBUG com.l3agent.Application - Running with Spring Boot v3.1.3, Spring v6.0.11
2025-05-13 15:28:30 [main] INFO  com.l3agent.Application - The following 1 profile is active: "nodb"
2025-05-13 15:28:30 [main] INFO  o.s.d.r.c.RepositoryConfigurationDelegate - Bootstrapping Spring Data JPA repositories in DEFAULT mode.
2025-05-13 15:28:30 [main] INFO  o.s.d.r.c.RepositoryConfigurationDelegate - Finished Spring Data repository scanning in 3 ms. Found 0 JPA repository interfaces.
2025-05-13 15:28:31 [main] INFO  o.s.b.w.e.tomcat.TomcatWebServer - Tomcat initialized with port(s): 8080 (http)
2025-05-13 15:28:31 [main] INFO  o.a.catalina.core.StandardService - Starting service [Tomcat]
2025-05-13 15:28:31 [main] INFO  o.a.catalina.core.StandardEngine - Starting Servlet engine: [Apache Tomcat/10.1.12]
2025-05-13 15:28:31 [main] INFO  o.a.c.c.C.[.[localhost].[/l3agent] - Initializing Spring embedded WebApplicationContext
2025-05-13 15:28:31 [main] INFO  o.s.b.w.s.c.ServletWebServerApplicationContext - Root WebApplicationContext: initialization completed in 590 ms
2025-05-13 15:28:31 [main] DEBUG c.l.s.impl.FileBasedTicketService - Loaded ticket TICKET-1234 from ./data/tickets/TICKET-1234.json
2025-05-13 15:28:31 [main] INFO  c.l.s.impl.HnswVectorStoreService - Loaded 1 repository namespaces
2025-05-13 15:28:31 [main] INFO  c.l.s.impl.HnswVectorStoreService - Loaded index for namespace default from /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/vector-store/default/hnsw_index.bin
2025-05-13 15:28:31 [main] INFO  c.l.s.impl.HnswVectorStoreService - Loaded metadata for 0 embeddings in namespace default
2025-05-13 15:28:31 [main] INFO  c.l.s.impl.HnswVectorStoreService - Loaded existing vector store for namespace default with 0 embeddings
2025-05-13 15:28:31 [main] INFO  c.l.s.impl.HnswVectorStoreService - Loaded 189 embedding failures
2025-05-13 15:28:31 [main] DEBUG c.l.s.i.FileBasedKnowledgeBaseService - Loaded article: KB001 - Resolving NullPointerException in TaskProcessor
2025-05-13 15:28:31 [main] DEBUG c.l.s.i.FileBasedKnowledgeBaseService - Loaded article: KB002 - Troubleshooting Salesforce API Connection Timeouts
2025-05-13 15:28:31 [main] DEBUG c.l.s.i.FileBasedKnowledgeBaseService - Loaded article: KB003 - Resolving Database Connection Issues in Gainsight Adapter
2025-05-13 15:28:31 [main] INFO  c.l.s.i.FileBasedKnowledgeBaseService - Loaded 3 knowledge articles
2025-05-13 15:28:31 [main] INFO  c.l.service.impl.GainsightLLMService - Gainsight LLM service initialized with default model: gpt-4o (version: 2024-05-13)
2025-05-13 15:28:31 [main] INFO  c.l.r.NullLLMMetadataRepository - Using NullLLMMetadataRepository - database operations will be no-ops
2025-05-13 15:28:31 [main] INFO  com.l3agent.config.LLMConfiguration - Using Gainsight LLM service
2025-05-13 15:28:31 [main] INFO  c.l.s.i.InMemoryKnowledgeGraphService - Loaded knowledge graph from /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/knowledge-graph/knowledge_graph.bin
2025-05-13 15:28:31 [main] INFO  c.l.s.i.InMemoryKnowledgeGraphService - Loaded existing knowledge graph with 0 entities and 0 relationships
2025-05-13 15:28:31 [main] INFO  c.l.s.i.FileBasedCodeRepositoryService - Code repository service initialized with directory: ./data/code
2025-05-13 15:28:31 [main] INFO  c.l.s.i.FileBasedCodeRepositoryService - Found repository: gs-integrations
2025-05-13 15:28:31 [main] INFO  c.l.s.i.FileBasedCodeRepositoryService - Found repository: dp_dynamic_tasks
2025-05-13 15:28:31 [main] INFO  c.l.s.i.FileBasedCodeRepositoryService - Found repository: gs-duct
2025-05-13 15:28:31 [main] INFO  c.l.s.i.FileBasedCodeRepositoryService - Found repository: data
2025-05-13 15:28:31 [main] INFO  c.l.s.i.FileBasedCodeRepositoryService - Found repository: gainsight-adapter
2025-05-13 15:28:31 [main] WARN  o.s.b.w.s.c.AnnotationConfigServletWebServerApplicationContext - Exception encountered during context initialization - cancelling refresh attempt: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'jpaSharedEM_entityManagerFactory': Cannot resolve reference to bean 'entityManagerFactory' while setting constructor argument
2025-05-13 15:28:31 [main] INFO  c.l.s.i.InMemoryKnowledgeGraphService - Saved knowledge graph to /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/knowledge-graph/knowledge_graph.bin
2025-05-13 15:28:31 [main] INFO  c.l.s.impl.HnswVectorStoreService - Saved index for namespace default to /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/vector-store/default/hnsw_index.bin
2025-05-13 15:28:31 [main] INFO  c.l.s.impl.HnswVectorStoreService - Saved metadata for namespace default to /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/vector-store/default/embedding_metadata.json
2025-05-13 15:28:31 [main] INFO  c.l.s.impl.HnswVectorStoreService - Saved 189 embedding failures to /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/vector-store/embedding_failures.json
2025-05-13 15:28:31 [main] INFO  c.l.s.impl.HnswVectorStoreService - Saved 1 repository namespaces
2025-05-13 15:28:31 [main] INFO  o.a.catalina.core.StandardService - Stopping service [Tomcat]
2025-05-13 15:28:31 [main] INFO  o.s.b.a.l.ConditionEvaluationReportLogger - 

Error starting ApplicationContext. To display the condition evaluation report re-run your application with 'debug' enabled.
2025-05-13 15:28:31 [main] ERROR o.s.b.d.LoggingFailureAnalysisReporter - 

***************************
APPLICATION FAILED TO START
***************************

Description:

A component required a bean named 'entityManagerFactory' that could not be found.


Action:

Consider defining a bean named 'entityManagerFactory' in your configuration.

2025-05-13 15:38:17 [main] INFO  com.l3agent.Application - Starting Application using Java 21.0.1 with PID 81502 (/Users/psambaraju/Desktop/cursorProjects/l3AgentNew/target/classes started by psambaraju in /Users/psambaraju/Desktop/cursorProjects/l3AgentNew)
2025-05-13 15:38:17 [main] DEBUG com.l3agent.Application - Running with Spring Boot v3.1.3, Spring v6.0.11
2025-05-13 15:38:17 [main] INFO  com.l3agent.Application - The following 1 profile is active: "nodb"
2025-05-13 15:38:18 [main] INFO  o.s.b.w.e.tomcat.TomcatWebServer - Tomcat initialized with port(s): 8080 (http)
2025-05-13 15:38:18 [main] INFO  o.a.catalina.core.StandardService - Starting service [Tomcat]
2025-05-13 15:38:18 [main] INFO  o.a.catalina.core.StandardEngine - Starting Servlet engine: [Apache Tomcat/10.1.12]
2025-05-13 15:38:18 [main] INFO  o.a.c.c.C.[.[localhost].[/l3agent] - Initializing Spring embedded WebApplicationContext
2025-05-13 15:38:18 [main] INFO  o.s.b.w.s.c.ServletWebServerApplicationContext - Root WebApplicationContext: initialization completed in 667 ms
2025-05-13 15:38:18 [main] DEBUG c.l.s.impl.FileBasedTicketService - Loaded ticket TICKET-1234 from ./data/tickets/TICKET-1234.json
2025-05-13 15:38:18 [main] INFO  c.l.s.impl.HnswVectorStoreService - Loaded 1 repository namespaces
2025-05-13 15:38:18 [main] INFO  c.l.s.impl.HnswVectorStoreService - Loaded index for namespace default from /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/vector-store/default/hnsw_index.bin
2025-05-13 15:38:18 [main] INFO  c.l.s.impl.HnswVectorStoreService - Loaded metadata for 0 embeddings in namespace default
2025-05-13 15:38:18 [main] INFO  c.l.s.impl.HnswVectorStoreService - Loaded existing vector store for namespace default with 0 embeddings
2025-05-13 15:38:18 [main] INFO  c.l.s.impl.HnswVectorStoreService - Loaded 189 embedding failures
2025-05-13 15:38:18 [main] DEBUG c.l.s.i.FileBasedKnowledgeBaseService - Loaded article: KB001 - Resolving NullPointerException in TaskProcessor
2025-05-13 15:38:18 [main] DEBUG c.l.s.i.FileBasedKnowledgeBaseService - Loaded article: KB002 - Troubleshooting Salesforce API Connection Timeouts
2025-05-13 15:38:18 [main] DEBUG c.l.s.i.FileBasedKnowledgeBaseService - Loaded article: KB003 - Resolving Database Connection Issues in Gainsight Adapter
2025-05-13 15:38:18 [main] INFO  c.l.s.i.FileBasedKnowledgeBaseService - Loaded 3 knowledge articles
2025-05-13 15:38:18 [main] INFO  c.l.service.impl.GainsightLLMService - Gainsight LLM service initialized with default model: gpt-4o (version: 2024-05-13)
2025-05-13 15:38:18 [main] INFO  c.l.r.NullLLMMetadataRepository - Using NullLLMMetadataRepository - database operations will be no-ops
2025-05-13 15:38:18 [main] INFO  com.l3agent.config.LLMConfiguration - Using Gainsight LLM service
2025-05-13 15:38:18 [main] INFO  c.l.s.i.InMemoryKnowledgeGraphService - Loaded knowledge graph from /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/knowledge-graph/knowledge_graph.bin
2025-05-13 15:38:18 [main] INFO  c.l.s.i.InMemoryKnowledgeGraphService - Loaded existing knowledge graph with 0 entities and 0 relationships
2025-05-13 15:38:18 [main] INFO  c.l.s.i.FileBasedCodeRepositoryService - Code repository service initialized with directory: ./data/code
2025-05-13 15:38:18 [main] INFO  c.l.s.i.FileBasedCodeRepositoryService - Found repository: gs-integrations
2025-05-13 15:38:18 [main] INFO  c.l.s.i.FileBasedCodeRepositoryService - Found repository: dp_dynamic_tasks
2025-05-13 15:38:18 [main] INFO  c.l.s.i.FileBasedCodeRepositoryService - Found repository: gs-duct
2025-05-13 15:38:18 [main] INFO  c.l.s.i.FileBasedCodeRepositoryService - Found repository: data
2025-05-13 15:38:18 [main] INFO  c.l.s.i.FileBasedCodeRepositoryService - Found repository: gainsight-adapter
2025-05-13 15:38:18 [main] INFO  o.s.b.w.e.tomcat.TomcatWebServer - Tomcat started on port(s): 8080 (http) with context path '/l3agent'
2025-05-13 15:38:18 [main] INFO  com.l3agent.Application - Started Application in 1.394 seconds (process running for 1.602)
2025-05-13 15:38:18 [main] INFO  c.l.cli.EmbeddingGenerationRunner - Starting embedding generation in command line mode
2025-05-13 15:38:18 [main] INFO  c.l.cli.EmbeddingGenerationRunner - Path: dp_dynamic_tasks, Recursive: true
2025-05-13 15:38:18 [main] INFO  c.l.service.impl.BasicL3AgentService - Generating embeddings on demand for path: dp_dynamic_tasks, recursive: true
2025-05-13 15:38:18 [main] INFO  c.l.s.impl.HnswVectorStoreService - Performing embedding pre-check...
2025-05-13 15:38:18 [main] ERROR c.l.s.impl.HnswVectorStoreService - Pre-check failed: Gainsight access key is missing or using default placeholder value.
2025-05-13 15:38:18 [main] ERROR c.l.s.impl.HnswVectorStoreService - Please set a valid access key in application.properties or via GAINSIGHT_ACCESS_KEY environment variable.
2025-05-13 15:38:18 [main] ERROR c.l.service.impl.BasicL3AgentService - Embedding pre-check failed. Aborting embedding generation.
2025-05-13 15:38:18 [main] INFO  c.l.cli.EmbeddingGenerationRunner - Embedding generation completed
2025-05-13 15:38:18 [main] INFO  c.l.cli.EmbeddingGenerationRunner - Files processed: null
2025-05-13 15:38:18 [main] INFO  c.l.cli.EmbeddingGenerationRunner - Total chunks: null
2025-05-13 15:38:18 [main] INFO  c.l.cli.EmbeddingGenerationRunner - Successful embeddings: null
2025-05-13 15:38:18 [main] INFO  c.l.cli.EmbeddingGenerationRunner - Failed embeddings: null
2025-05-13 15:38:18 [main] INFO  c.l.cli.EmbeddingGenerationRunner - Processing time (ms): null
2025-05-13 15:38:19 [main] INFO  o.a.catalina.core.StandardService - Stopping service [Tomcat]
2025-05-13 15:38:19 [main] INFO  c.l.s.i.InMemoryKnowledgeGraphService - Saved knowledge graph to /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/knowledge-graph/knowledge_graph.bin
2025-05-13 15:38:19 [main] INFO  c.l.s.impl.HnswVectorStoreService - Saved index for namespace default to /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/vector-store/default/hnsw_index.bin
2025-05-13 15:38:19 [main] INFO  c.l.s.impl.HnswVectorStoreService - Saved metadata for namespace default to /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/vector-store/default/embedding_metadata.json
2025-05-13 15:38:19 [main] INFO  c.l.s.impl.HnswVectorStoreService - Saved 189 embedding failures to /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/vector-store/embedding_failures.json
2025-05-13 15:38:19 [main] INFO  c.l.s.impl.HnswVectorStoreService - Saved 1 repository namespaces
2025-05-13 16:25:31 [main] INFO  com.l3agent.Application - Starting Application using Java 21.0.1 with PID 59384 (/Users/psambaraju/Desktop/cursorProjects/l3AgentNew/target/classes started by psambaraju in /Users/psambaraju/Desktop/cursorProjects/l3AgentNew)
2025-05-13 16:25:31 [main] DEBUG com.l3agent.Application - Running with Spring Boot v3.1.3, Spring v6.0.11
2025-05-13 16:25:31 [main] INFO  com.l3agent.Application - The following 1 profile is active: "nodb"
2025-05-13 16:25:31 [main] INFO  o.s.b.w.e.tomcat.TomcatWebServer - Tomcat initialized with port(s): 8080 (http)
2025-05-13 16:25:31 [main] INFO  o.a.catalina.core.StandardService - Starting service [Tomcat]
2025-05-13 16:25:31 [main] INFO  o.a.catalina.core.StandardEngine - Starting Servlet engine: [Apache Tomcat/10.1.12]
2025-05-13 16:25:31 [main] INFO  o.a.c.c.C.[.[localhost].[/l3agent] - Initializing Spring embedded WebApplicationContext
2025-05-13 16:25:31 [main] INFO  o.s.b.w.s.c.ServletWebServerApplicationContext - Root WebApplicationContext: initialization completed in 668 ms
2025-05-13 16:25:31 [main] DEBUG c.l.s.impl.FileBasedTicketService - Loaded ticket TICKET-1234 from ./data/tickets/TICKET-1234.json
2025-05-13 16:25:31 [main] INFO  c.l.s.impl.HnswVectorStoreService - Loaded 1 repository namespaces
2025-05-13 16:25:32 [main] ERROR c.l.s.impl.HnswVectorStoreService - Error loading index for namespace default
java.io.InvalidObjectException: ReflectiveOperationException during deserialization
	at java.base/java.lang.invoke.SerializedLambda.readResolve(SerializedLambda.java:280)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at java.base/java.io.ObjectStreamClass.invokeReadResolve(ObjectStreamClass.java:1192)
	at java.base/java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2293)
	at java.base/java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1762)
	at java.base/java.io.ObjectInputStream.readObject(ObjectInputStream.java:540)
	at java.base/java.io.ObjectInputStream.readObject(ObjectInputStream.java:498)
	at com.github.jelmerk.knn.hnsw.HnswIndex.readObject(HnswIndex.java:785)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at java.base/java.io.ObjectStreamClass.invokeReadObject(ObjectStreamClass.java:1102)
	at java.base/java.io.ObjectInputStream.readSerialData(ObjectInputStream.java:2444)
	at java.base/java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2284)
	at java.base/java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1762)
	at java.base/java.io.ObjectInputStream.readObject(ObjectInputStream.java:540)
	at java.base/java.io.ObjectInputStream.readObject(ObjectInputStream.java:498)
	at com.github.jelmerk.knn.hnsw.HnswIndex.load(HnswIndex.java:960)
	at com.github.jelmerk.knn.hnsw.HnswIndex.load(HnswIndex.java:939)
	at com.github.jelmerk.knn.hnsw.HnswIndex.load(HnswIndex.java:871)
	at com.l3agent.service.impl.HnswVectorStoreService.loadIndex(HnswVectorStoreService.java:326)
	at com.l3agent.service.impl.HnswVectorStoreService.initializeNamespace(HnswVectorStoreService.java:209)
	at com.l3agent.service.impl.HnswVectorStoreService.init(HnswVectorStoreService.java:175)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMethod.invoke(InitDestroyAnnotationBeanPostProcessor.java:457)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMetadata.invokeInitMethods(InitDestroyAnnotationBeanPostProcessor.java:401)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor.postProcessBeforeInitialization(InitDestroyAnnotationBeanPostProcessor.java:219)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsBeforeInitialization(AbstractAutowireCapableBeanFactory.java:419)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1762)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:598)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:254)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1417)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1337)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:713)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:696)
	at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:145)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:483)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1416)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:597)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:254)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1417)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1337)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:713)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:696)
	at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:145)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:483)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1416)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:597)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:254)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1417)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1337)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:713)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:696)
	at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:145)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:483)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1416)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:597)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:520)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:973)
	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:942)
	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:608)
	at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:146)
	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:734)
	at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:436)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:312)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1306)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1295)
	at com.l3agent.Application.main(Application.java:13)
Caused by: java.lang.reflect.InvocationTargetException: null
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:118)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at java.base/java.lang.invoke.SerializedLambda.readResolve(SerializedLambda.java:278)
	... 87 common frames omitted
Caused by: java.lang.IllegalArgumentException: Invalid lambda deserialization
	at com.l3agent.service.impl.HnswVectorStoreService.$deserializeLambda$(HnswVectorStoreService.java:1)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	... 89 common frames omitted
2025-05-13 16:25:32 [main] INFO  c.l.s.impl.HnswVectorStoreService - Creating new vector index for namespace default with dimension 3072
2025-05-13 16:25:32 [main] INFO  c.l.s.impl.HnswVectorStoreService - Loaded metadata for 0 embeddings in namespace default
2025-05-13 16:25:32 [main] INFO  c.l.s.impl.HnswVectorStoreService - Loaded existing vector store for namespace default with 0 embeddings
2025-05-13 16:25:32 [main] INFO  c.l.s.impl.HnswVectorStoreService - Loaded 189 embedding failures
2025-05-13 16:25:32 [main] DEBUG c.l.s.i.FileBasedKnowledgeBaseService - Loaded article: KB001 - Resolving NullPointerException in TaskProcessor
2025-05-13 16:25:32 [main] DEBUG c.l.s.i.FileBasedKnowledgeBaseService - Loaded article: KB002 - Troubleshooting Salesforce API Connection Timeouts
2025-05-13 16:25:32 [main] DEBUG c.l.s.i.FileBasedKnowledgeBaseService - Loaded article: KB003 - Resolving Database Connection Issues in Gainsight Adapter
2025-05-13 16:25:32 [main] INFO  c.l.s.i.FileBasedKnowledgeBaseService - Loaded 3 knowledge articles
2025-05-13 16:25:32 [main] INFO  c.l.service.impl.GainsightLLMService - Gainsight LLM service initialized with default model: gpt-4o (version: 2024-05-13)
2025-05-13 16:25:32 [main] INFO  c.l.r.NullLLMMetadataRepository - Using NullLLMMetadataRepository - database operations will be no-ops
2025-05-13 16:25:32 [main] INFO  com.l3agent.config.LLMConfiguration - Using Gainsight LLM service
2025-05-13 16:25:32 [main] INFO  c.l.s.i.InMemoryKnowledgeGraphService - Loaded knowledge graph from /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/knowledge-graph/knowledge_graph.bin
2025-05-13 16:25:32 [main] INFO  c.l.s.i.InMemoryKnowledgeGraphService - Loaded existing knowledge graph with 0 entities and 0 relationships
2025-05-13 16:25:32 [main] INFO  c.l.s.i.FileBasedCodeRepositoryService - Code repository service initialized with directory: ./data/code
2025-05-13 16:25:32 [main] INFO  c.l.s.i.FileBasedCodeRepositoryService - Found repository: gs-integrations
2025-05-13 16:25:32 [main] INFO  c.l.s.i.FileBasedCodeRepositoryService - Found repository: dp_dynamic_tasks
2025-05-13 16:25:32 [main] INFO  c.l.s.i.FileBasedCodeRepositoryService - Found repository: gs-duct
2025-05-13 16:25:32 [main] INFO  c.l.s.i.FileBasedCodeRepositoryService - Found repository: data
2025-05-13 16:25:32 [main] INFO  c.l.s.i.FileBasedCodeRepositoryService - Found repository: gainsight-adapter
2025-05-13 16:25:32 [main] INFO  o.s.b.w.e.tomcat.TomcatWebServer - Tomcat started on port(s): 8080 (http) with context path '/l3agent'
2025-05-13 16:25:32 [main] INFO  com.l3agent.Application - Started Application in 1.411 seconds (process running for 1.625)
2025-05-13 16:25:32 [main] INFO  c.l.cli.EmbeddingGenerationRunner - Starting embedding generation in command line mode
2025-05-13 16:25:32 [main] INFO  c.l.cli.EmbeddingGenerationRunner - Path: dp_dynamic_tasks, Recursive: true
2025-05-13 16:25:32 [main] INFO  c.l.service.impl.BasicL3AgentService - Generating embeddings on demand for path: dp_dynamic_tasks, recursive: true
2025-05-13 16:25:32 [main] INFO  c.l.s.impl.HnswVectorStoreService - Performing embedding pre-check...
2025-05-13 16:25:32 [main] ERROR c.l.s.impl.HnswVectorStoreService - Pre-check failed: Gainsight access key is missing or using default placeholder value.
2025-05-13 16:25:32 [main] ERROR c.l.s.impl.HnswVectorStoreService - Please set a valid access key in application.properties or via GAINSIGHT_ACCESS_KEY environment variable.
2025-05-13 16:25:32 [main] ERROR c.l.service.impl.BasicL3AgentService - Embedding pre-check failed. Aborting embedding generation.
2025-05-13 16:25:32 [main] INFO  c.l.cli.EmbeddingGenerationRunner - Embedding generation completed
2025-05-13 16:25:32 [main] INFO  c.l.cli.EmbeddingGenerationRunner - Files processed: null
2025-05-13 16:25:32 [main] INFO  c.l.cli.EmbeddingGenerationRunner - Total chunks: null
2025-05-13 16:25:32 [main] INFO  c.l.cli.EmbeddingGenerationRunner - Successful embeddings: null
2025-05-13 16:25:32 [main] INFO  c.l.cli.EmbeddingGenerationRunner - Failed embeddings: null
2025-05-13 16:25:32 [main] INFO  c.l.cli.EmbeddingGenerationRunner - Processing time (ms): null
2025-05-13 16:25:32 [main] INFO  o.a.catalina.core.StandardService - Stopping service [Tomcat]
2025-05-13 16:25:32 [main] INFO  c.l.s.i.InMemoryKnowledgeGraphService - Saved knowledge graph to /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/knowledge-graph/knowledge_graph.bin
2025-05-13 16:25:32 [main] INFO  c.l.s.impl.HnswVectorStoreService - Saved index for namespace default to /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/vector-store/default/hnsw_index.bin
2025-05-13 16:25:32 [main] INFO  c.l.s.impl.HnswVectorStoreService - Saved metadata for namespace default to /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/vector-store/default/embedding_metadata.json
2025-05-13 16:25:32 [main] INFO  c.l.s.impl.HnswVectorStoreService - Saved 189 embedding failures to /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/vector-store/embedding_failures.json
2025-05-13 16:25:32 [main] INFO  c.l.s.impl.HnswVectorStoreService - Saved 1 repository namespaces
2025-05-13 16:26:03 [main] INFO  com.l3agent.Application - Starting Application using Java 21.0.1 with PID 59977 (/Users/psambaraju/Desktop/cursorProjects/l3AgentNew/target/classes started by psambaraju in /Users/psambaraju/Desktop/cursorProjects/l3AgentNew)
2025-05-13 16:26:03 [main] DEBUG com.l3agent.Application - Running with Spring Boot v3.1.3, Spring v6.0.11
2025-05-13 16:26:03 [main] INFO  com.l3agent.Application - The following 1 profile is active: "nodb"
2025-05-13 16:26:04 [main] INFO  o.s.b.w.e.tomcat.TomcatWebServer - Tomcat initialized with port(s): 8080 (http)
2025-05-13 16:26:04 [main] INFO  o.a.catalina.core.StandardService - Starting service [Tomcat]
2025-05-13 16:26:04 [main] INFO  o.a.catalina.core.StandardEngine - Starting Servlet engine: [Apache Tomcat/10.1.12]
2025-05-13 16:26:04 [main] INFO  o.a.c.c.C.[.[localhost].[/l3agent] - Initializing Spring embedded WebApplicationContext
2025-05-13 16:26:04 [main] INFO  o.s.b.w.s.c.ServletWebServerApplicationContext - Root WebApplicationContext: initialization completed in 617 ms
2025-05-13 16:26:04 [main] DEBUG c.l.s.impl.FileBasedTicketService - Loaded ticket TICKET-1234 from ./data/tickets/TICKET-1234.json
2025-05-13 16:26:04 [main] INFO  c.l.s.impl.HnswVectorStoreService - Loaded 1 repository namespaces
2025-05-13 16:26:04 [main] INFO  c.l.s.impl.HnswVectorStoreService - Loaded index for namespace default from /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/vector-store/default/hnsw_index.bin
2025-05-13 16:26:04 [main] INFO  c.l.s.impl.HnswVectorStoreService - Loaded metadata for 0 embeddings in namespace default
2025-05-13 16:26:04 [main] INFO  c.l.s.impl.HnswVectorStoreService - Loaded existing vector store for namespace default with 0 embeddings
2025-05-13 16:26:04 [main] INFO  c.l.s.impl.HnswVectorStoreService - Loaded 189 embedding failures
2025-05-13 16:26:04 [main] DEBUG c.l.s.i.FileBasedKnowledgeBaseService - Loaded article: KB001 - Resolving NullPointerException in TaskProcessor
2025-05-13 16:26:04 [main] DEBUG c.l.s.i.FileBasedKnowledgeBaseService - Loaded article: KB002 - Troubleshooting Salesforce API Connection Timeouts
2025-05-13 16:26:04 [main] DEBUG c.l.s.i.FileBasedKnowledgeBaseService - Loaded article: KB003 - Resolving Database Connection Issues in Gainsight Adapter
2025-05-13 16:26:04 [main] INFO  c.l.s.i.FileBasedKnowledgeBaseService - Loaded 3 knowledge articles
2025-05-13 16:26:04 [main] INFO  c.l.service.impl.GainsightLLMService - Gainsight LLM service initialized with default model: gpt-4o (version: 2024-05-13)
2025-05-13 16:26:04 [main] INFO  c.l.r.NullLLMMetadataRepository - Using NullLLMMetadataRepository - database operations will be no-ops
2025-05-13 16:26:04 [main] INFO  com.l3agent.config.LLMConfiguration - Using Gainsight LLM service
2025-05-13 16:26:04 [main] INFO  c.l.s.i.InMemoryKnowledgeGraphService - Loaded knowledge graph from /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/knowledge-graph/knowledge_graph.bin
2025-05-13 16:26:04 [main] INFO  c.l.s.i.InMemoryKnowledgeGraphService - Loaded existing knowledge graph with 0 entities and 0 relationships
2025-05-13 16:26:04 [main] INFO  c.l.s.i.FileBasedCodeRepositoryService - Code repository service initialized with directory: ./data/code
2025-05-13 16:26:04 [main] INFO  c.l.s.i.FileBasedCodeRepositoryService - Found repository: gs-integrations
2025-05-13 16:26:04 [main] INFO  c.l.s.i.FileBasedCodeRepositoryService - Found repository: dp_dynamic_tasks
2025-05-13 16:26:04 [main] INFO  c.l.s.i.FileBasedCodeRepositoryService - Found repository: gs-duct
2025-05-13 16:26:04 [main] INFO  c.l.s.i.FileBasedCodeRepositoryService - Found repository: data
2025-05-13 16:26:04 [main] INFO  c.l.s.i.FileBasedCodeRepositoryService - Found repository: gainsight-adapter
2025-05-13 16:26:04 [main] INFO  o.s.b.w.e.tomcat.TomcatWebServer - Tomcat started on port(s): 8080 (http) with context path '/l3agent'
2025-05-13 16:26:04 [main] INFO  com.l3agent.Application - Started Application in 1.35 seconds (process running for 1.584)
2025-05-13 16:26:04 [main] INFO  c.l.cli.EmbeddingGenerationRunner - Starting embedding generation in command line mode
2025-05-13 16:26:04 [main] INFO  c.l.cli.EmbeddingGenerationRunner - Path: dp_dynamic_tasks, Recursive: true
2025-05-13 16:26:04 [main] INFO  c.l.service.impl.BasicL3AgentService - Generating embeddings on demand for path: dp_dynamic_tasks, recursive: true
2025-05-13 16:26:04 [main] INFO  c.l.s.impl.HnswVectorStoreService - Performing embedding pre-check...
2025-05-13 16:26:04 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 16:26:04 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 16:26:04 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"This is a test to verify embedding generation is working properly."}
2025-05-13 16:26:06 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 16:26:06 [main] INFO  c.l.s.impl.HnswVectorStoreService - Embedding pre-check passed successfully
2025-05-13 16:26:06 [main] WARN  c.l.service.impl.BasicL3AgentService - Specified path does not exist: dp_dynamic_tasks
2025-05-13 16:26:06 [main] INFO  c.l.cli.EmbeddingGenerationRunner - Embedding generation completed
2025-05-13 16:26:06 [main] INFO  c.l.cli.EmbeddingGenerationRunner - Files processed: null
2025-05-13 16:26:06 [main] INFO  c.l.cli.EmbeddingGenerationRunner - Total chunks: null
2025-05-13 16:26:06 [main] INFO  c.l.cli.EmbeddingGenerationRunner - Successful embeddings: null
2025-05-13 16:26:06 [main] INFO  c.l.cli.EmbeddingGenerationRunner - Failed embeddings: null
2025-05-13 16:26:06 [main] INFO  c.l.cli.EmbeddingGenerationRunner - Processing time (ms): null
2025-05-13 16:26:07 [main] INFO  o.a.catalina.core.StandardService - Stopping service [Tomcat]
2025-05-13 16:26:07 [main] INFO  c.l.s.i.InMemoryKnowledgeGraphService - Saved knowledge graph to /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/knowledge-graph/knowledge_graph.bin
2025-05-13 16:26:07 [main] INFO  c.l.s.impl.HnswVectorStoreService - Saved index for namespace default to /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/vector-store/default/hnsw_index.bin
2025-05-13 16:26:07 [main] INFO  c.l.s.impl.HnswVectorStoreService - Saved metadata for namespace default to /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/vector-store/default/embedding_metadata.json
2025-05-13 16:26:07 [main] INFO  c.l.s.impl.HnswVectorStoreService - Saved 189 embedding failures to /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/vector-store/embedding_failures.json
2025-05-13 16:26:07 [main] INFO  c.l.s.impl.HnswVectorStoreService - Saved 1 repository namespaces
2025-05-13 20:53:49 [main] INFO  com.l3agent.Application - Starting Application using Java 21.0.1 with PID 95781 (/Users/psambaraju/Desktop/cursorProjects/l3AgentNew/target/classes started by psambaraju in /Users/psambaraju/Desktop/cursorProjects/l3AgentNew)
2025-05-13 20:53:49 [main] DEBUG com.l3agent.Application - Running with Spring Boot v3.1.3, Spring v6.0.11
2025-05-13 20:53:49 [main] INFO  com.l3agent.Application - The following 1 profile is active: "nodb"
2025-05-13 20:53:49 [main] INFO  o.s.b.w.e.tomcat.TomcatWebServer - Tomcat initialized with port(s): 8080 (http)
2025-05-13 20:53:49 [main] INFO  o.a.catalina.core.StandardService - Starting service [Tomcat]
2025-05-13 20:53:49 [main] INFO  o.a.catalina.core.StandardEngine - Starting Servlet engine: [Apache Tomcat/10.1.12]
2025-05-13 20:53:49 [main] INFO  o.a.c.c.C.[.[localhost].[/l3agent] - Initializing Spring embedded WebApplicationContext
2025-05-13 20:53:49 [main] INFO  o.s.b.w.s.c.ServletWebServerApplicationContext - Root WebApplicationContext: initialization completed in 669 ms
2025-05-13 20:53:49 [main] DEBUG c.l.s.impl.FileBasedTicketService - Loaded ticket TICKET-1234 from ./data/tickets/TICKET-1234.json
2025-05-13 20:53:49 [main] INFO  c.l.s.impl.HnswVectorStoreService - Loaded 1 repository namespaces
2025-05-13 20:53:50 [main] INFO  c.l.s.impl.HnswVectorStoreService - Loaded index for namespace default from /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/vector-store/default/hnsw_index.bin
2025-05-13 20:53:50 [main] INFO  c.l.s.impl.HnswVectorStoreService - Loaded metadata for 0 embeddings in namespace default
2025-05-13 20:53:50 [main] INFO  c.l.s.impl.HnswVectorStoreService - Loaded existing vector store for namespace default with 0 embeddings
2025-05-13 20:53:50 [main] INFO  c.l.s.impl.HnswVectorStoreService - Loaded 189 embedding failures
2025-05-13 20:53:50 [main] DEBUG c.l.s.i.FileBasedKnowledgeBaseService - Loaded article: KB001 - Resolving NullPointerException in TaskProcessor
2025-05-13 20:53:50 [main] DEBUG c.l.s.i.FileBasedKnowledgeBaseService - Loaded article: KB002 - Troubleshooting Salesforce API Connection Timeouts
2025-05-13 20:53:50 [main] DEBUG c.l.s.i.FileBasedKnowledgeBaseService - Loaded article: KB003 - Resolving Database Connection Issues in Gainsight Adapter
2025-05-13 20:53:50 [main] INFO  c.l.s.i.FileBasedKnowledgeBaseService - Loaded 3 knowledge articles
2025-05-13 20:53:50 [main] INFO  c.l.service.impl.GainsightLLMService - Gainsight LLM service initialized with default model: gpt-4o (version: 2024-05-13)
2025-05-13 20:53:50 [main] INFO  c.l.r.NullLLMMetadataRepository - Using NullLLMMetadataRepository - database operations will be no-ops
2025-05-13 20:53:50 [main] INFO  com.l3agent.config.LLMConfiguration - Using Gainsight LLM service
2025-05-13 20:53:50 [main] INFO  c.l.s.i.InMemoryKnowledgeGraphService - Loaded knowledge graph from /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/knowledge-graph/knowledge_graph.bin
2025-05-13 20:53:50 [main] INFO  c.l.s.i.InMemoryKnowledgeGraphService - Loaded existing knowledge graph with 0 entities and 0 relationships
2025-05-13 20:53:50 [main] INFO  c.l.s.i.FileBasedCodeRepositoryService - Code repository service initialized with directory: ./data/code
2025-05-13 20:53:50 [main] INFO  c.l.s.i.FileBasedCodeRepositoryService - Found repository: gs-integrations
2025-05-13 20:53:50 [main] INFO  c.l.s.i.FileBasedCodeRepositoryService - Found repository: dp_dynamic_tasks
2025-05-13 20:53:50 [main] INFO  c.l.s.i.FileBasedCodeRepositoryService - Found repository: gs-duct
2025-05-13 20:53:50 [main] INFO  c.l.s.i.FileBasedCodeRepositoryService - Found repository: data
2025-05-13 20:53:50 [main] INFO  c.l.s.i.FileBasedCodeRepositoryService - Found repository: gainsight-adapter
2025-05-13 20:53:50 [main] INFO  o.s.b.w.e.tomcat.TomcatWebServer - Tomcat started on port(s): 8080 (http) with context path '/l3agent'
2025-05-13 20:53:50 [main] INFO  com.l3agent.Application - Started Application in 1.375 seconds (process running for 1.572)
2025-05-13 20:53:50 [main] INFO  c.l.cli.EmbeddingGenerationRunner - Starting embedding generation in command line mode
2025-05-13 20:53:50 [main] INFO  c.l.cli.EmbeddingGenerationRunner - Path: dp_dynamic_tasks, Recursive: true
2025-05-13 20:53:50 [main] INFO  c.l.service.impl.BasicL3AgentService - Generating embeddings on demand for path: dp_dynamic_tasks, recursive: true
2025-05-13 20:53:50 [main] INFO  c.l.s.impl.HnswVectorStoreService - Performing embedding pre-check...
2025-05-13 20:53:50 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 20:53:50 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 20:53:50 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"This is a test to verify embedding generation is working properly."}
2025-05-13 20:53:52 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 20:53:52 [main] INFO  c.l.s.impl.HnswVectorStoreService - Embedding pre-check passed successfully
2025-05-13 20:53:52 [main] WARN  c.l.service.impl.BasicL3AgentService - Specified path does not exist: dp_dynamic_tasks
2025-05-13 20:53:52 [main] INFO  c.l.cli.EmbeddingGenerationRunner - Embedding generation completed
2025-05-13 20:53:52 [main] INFO  c.l.cli.EmbeddingGenerationRunner - Files processed: null
2025-05-13 20:53:52 [main] INFO  c.l.cli.EmbeddingGenerationRunner - Total chunks: null
2025-05-13 20:53:52 [main] INFO  c.l.cli.EmbeddingGenerationRunner - Successful embeddings: null
2025-05-13 20:53:52 [main] INFO  c.l.cli.EmbeddingGenerationRunner - Failed embeddings: null
2025-05-13 20:53:52 [main] INFO  c.l.cli.EmbeddingGenerationRunner - Processing time (ms): null
2025-05-13 20:53:53 [main] INFO  o.a.catalina.core.StandardService - Stopping service [Tomcat]
2025-05-13 20:53:53 [main] INFO  c.l.s.i.InMemoryKnowledgeGraphService - Saved knowledge graph to /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/knowledge-graph/knowledge_graph.bin
2025-05-13 20:53:53 [main] INFO  c.l.s.impl.HnswVectorStoreService - Saved index for namespace default to /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/vector-store/default/hnsw_index.bin
2025-05-13 20:53:53 [main] INFO  c.l.s.impl.HnswVectorStoreService - Saved metadata for namespace default to /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/vector-store/default/embedding_metadata.json
2025-05-13 20:53:53 [main] INFO  c.l.s.impl.HnswVectorStoreService - Saved 189 embedding failures to /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/vector-store/embedding_failures.json
2025-05-13 20:53:53 [main] INFO  c.l.s.impl.HnswVectorStoreService - Saved 1 repository namespaces
2025-05-13 20:59:35 [main] INFO  com.l3agent.Application - Starting Application using Java 21.0.1 with PID 2692 (/Users/psambaraju/Desktop/cursorProjects/l3AgentNew/target/classes started by psambaraju in /Users/psambaraju/Desktop/cursorProjects/l3AgentNew)
2025-05-13 20:59:35 [main] DEBUG com.l3agent.Application - Running with Spring Boot v3.1.3, Spring v6.0.11
2025-05-13 20:59:35 [main] INFO  com.l3agent.Application - The following 1 profile is active: "nodb"
2025-05-13 20:59:36 [main] INFO  o.s.b.w.e.tomcat.TomcatWebServer - Tomcat initialized with port(s): 8080 (http)
2025-05-13 20:59:36 [main] INFO  o.a.catalina.core.StandardService - Starting service [Tomcat]
2025-05-13 20:59:36 [main] INFO  o.a.catalina.core.StandardEngine - Starting Servlet engine: [Apache Tomcat/10.1.12]
2025-05-13 20:59:36 [main] INFO  o.a.c.c.C.[.[localhost].[/l3agent] - Initializing Spring embedded WebApplicationContext
2025-05-13 20:59:36 [main] INFO  o.s.b.w.s.c.ServletWebServerApplicationContext - Root WebApplicationContext: initialization completed in 637 ms
2025-05-13 20:59:36 [main] DEBUG c.l.s.impl.FileBasedTicketService - Loaded ticket TICKET-1234 from ./data/tickets/TICKET-1234.json
2025-05-13 20:59:36 [main] INFO  c.l.s.impl.HnswVectorStoreService - Loaded 1 repository namespaces
2025-05-13 20:59:36 [main] INFO  c.l.s.impl.HnswVectorStoreService - Loaded index for namespace default from /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/vector-store/default/hnsw_index.bin
2025-05-13 20:59:36 [main] INFO  c.l.s.impl.HnswVectorStoreService - Loaded metadata for 0 embeddings in namespace default
2025-05-13 20:59:36 [main] INFO  c.l.s.impl.HnswVectorStoreService - Loaded existing vector store for namespace default with 0 embeddings
2025-05-13 20:59:36 [main] INFO  c.l.s.impl.HnswVectorStoreService - Loaded 189 embedding failures
2025-05-13 20:59:36 [main] DEBUG c.l.s.i.FileBasedKnowledgeBaseService - Loaded article: KB001 - Resolving NullPointerException in TaskProcessor
2025-05-13 20:59:36 [main] DEBUG c.l.s.i.FileBasedKnowledgeBaseService - Loaded article: KB002 - Troubleshooting Salesforce API Connection Timeouts
2025-05-13 20:59:36 [main] DEBUG c.l.s.i.FileBasedKnowledgeBaseService - Loaded article: KB003 - Resolving Database Connection Issues in Gainsight Adapter
2025-05-13 20:59:36 [main] INFO  c.l.s.i.FileBasedKnowledgeBaseService - Loaded 3 knowledge articles
2025-05-13 20:59:36 [main] INFO  c.l.service.impl.GainsightLLMService - Gainsight LLM service initialized with default model: gpt-4o (version: 2024-05-13)
2025-05-13 20:59:36 [main] INFO  c.l.r.NullLLMMetadataRepository - Using NullLLMMetadataRepository - database operations will be no-ops
2025-05-13 20:59:36 [main] INFO  com.l3agent.config.LLMConfiguration - Using Gainsight LLM service
2025-05-13 20:59:36 [main] INFO  c.l.s.i.InMemoryKnowledgeGraphService - Loaded knowledge graph from /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/knowledge-graph/knowledge_graph.bin
2025-05-13 20:59:36 [main] INFO  c.l.s.i.InMemoryKnowledgeGraphService - Loaded existing knowledge graph with 0 entities and 0 relationships
2025-05-13 20:59:36 [main] INFO  c.l.s.i.FileBasedCodeRepositoryService - Code repository service initialized with directory: ./data/code
2025-05-13 20:59:36 [main] INFO  c.l.s.i.FileBasedCodeRepositoryService - Found repository: gs-integrations
2025-05-13 20:59:36 [main] INFO  c.l.s.i.FileBasedCodeRepositoryService - Found repository: dp_dynamic_tasks
2025-05-13 20:59:36 [main] INFO  c.l.s.i.FileBasedCodeRepositoryService - Found repository: gs-duct
2025-05-13 20:59:36 [main] INFO  c.l.s.i.FileBasedCodeRepositoryService - Found repository: data
2025-05-13 20:59:36 [main] INFO  c.l.s.i.FileBasedCodeRepositoryService - Found repository: gainsight-adapter
2025-05-13 20:59:36 [main] INFO  o.s.b.w.e.tomcat.TomcatWebServer - Tomcat started on port(s): 8080 (http) with context path '/l3agent'
2025-05-13 20:59:36 [main] INFO  com.l3agent.Application - Started Application in 1.368 seconds (process running for 1.567)
2025-05-13 20:59:36 [main] INFO  c.l.cli.EmbeddingGenerationRunner - Starting embedding generation in command line mode
2025-05-13 20:59:36 [main] INFO  c.l.cli.EmbeddingGenerationRunner - Path: dp_dynamic_tasks, Recursive: true
2025-05-13 20:59:36 [main] INFO  c.l.s.impl.HnswVectorStoreService - Performing embedding pre-check...
2025-05-13 20:59:36 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 20:59:36 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 20:59:36 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"This is a test to verify embedding generation is working properly."}
2025-05-13 20:59:38 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 20:59:38 [main] INFO  c.l.s.impl.HnswVectorStoreService - Embedding pre-check passed successfully
2025-05-13 20:59:38 [main] INFO  c.l.service.impl.BasicL3AgentService - Interpreting path as repository: /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/code/dp_dynamic_tasks
2025-05-13 20:59:38 [main] INFO  c.l.service.impl.BasicL3AgentService - Found 22 files to process
2025-05-13 20:59:38 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 20:59:38 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 20:59:38 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"package com.gainsight.services.external.ipaas.extraction.task;\n\nimport com.gainsight.services.dataprocessing.commons.exception.ErrorCode;\nimport com.gainsight.services.dataprocessing.commons.properties.MessageProperties;\nimport com.gainsight.services.dataprocessing.commons.utils.DPUtils;\nimport org.apache.commons.lang3.StringUtils;\n\npublic enum IpaasExtractionValidationCode implements ErrorCode {\n    FIELD_NOT_PRESENT_IN_SYSTEM(100001)\n    ;\n\n    private final int code;\n    private String className = getClass().getSimpleName();\n\n    IpaasExtractionValidationCode(int code) {\n        this.code = code;\n    }\n\n    public int getCode() {\n        return code;\n    }\n\n    public String getErrorName() {\n        return className + \"__\" + this.name();\n    }\n\n    /**\n     * Refers to User Defined Text\n     */\n    public String getUserText(Object... args) {\n        String key = getErrorName();\n        MessageProperties messageProperties = MessageProperties.getMessageProperties();\n        if(messageProperties == null){\n            return key;\n        }\n        String message = messageProperties.getValue(key);\n        if (args == null || args.length == 0) {\n            message = DPUtils.msg(message, StringUtils.EMPTY);\n        } else {\n            message = DPUtils.msg(message, args);\n        }\n        return message;\n    }\n}\n\n"}
2025-05-13 20:59:40 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 20:59:40 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 20:59:40 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 20:59:40 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    public int getCode() {\n        return code;\n    }\n"}
2025-05-13 20:59:41 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 20:59:41 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 20:59:41 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 20:59:41 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    public String getErrorName() {\n        return className + \"__\" + this.name();\n    }\n"}
2025-05-13 20:59:43 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 20:59:43 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 20:59:43 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 20:59:43 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    public String getUserText(Object... args) {\n        String key = getErrorName();\n        MessageProperties messageProperties = MessageProperties.getMessageProperties();\n        if(messageProperties == null){\n            return key;\n        }\n        String message = messageProperties.getValue(key);\n        if (args == null || args.length == 0) {\n            message = DPUtils.msg(message, StringUtils.EMPTY);\n        } else {\n            message = DPUtils.msg(message, args);\n        }\n        return message;\n    }\n"}
2025-05-13 20:59:44 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 20:59:44 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 20:59:44 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 20:59:44 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"public enum IpaasExtractionValidationCode implements ErrorCode {\n    FIELD_NOT_PRESENT_IN_SYSTEM(100001)\n    ;\n\n    private final int code;\n    private String className = getClass().getSimpleName();\n\n    IpaasExtractionValidationCode(int code) {\n        this.code = code;\n    }\n\n    public int getCode() {\n        return code;\n    }\n\n    public String getErrorName() {\n        return className + \"__\" + this.name();\n    }\n\n    /**\n     * Refers to User Defined Text\n     */\n    public String getUserText(Object... args) {\n        String key = getErrorName();\n        MessageProperties messageProperties = MessageProperties.getMessageProperties();\n        if(messageProperties == null){\n            return key;\n        }\n        String message = messageProperties.getValue(key);\n        if (args == null || args.length == 0) {\n            message = DPUtils.msg(message, StringUtils.EMPTY);\n        } else {\n            message = DPUtils.msg(message, args);\n        }\n        return message;\n    }\n}\n"}
2025-05-13 20:59:46 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 20:59:46 [main] INFO  c.l.service.impl.BasicL3AgentService - Processed file: /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/code/dp_dynamic_tasks/ipaas-extraction-task/src/main/java/com/gainsight/services/external/ipaas/extraction/task/IpaasExtractionValidationCode.java with 5 chunks
2025-05-13 20:59:46 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 20:59:46 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 20:59:46 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"package com.gainsight.services.external.ipaas.extraction.task;\n\n\nimport com.gainsight.bean.SecretData;\nimport com.gainsight.context.RequestContextProvider;\nimport com.gainsight.integration.bean.IPaasConstants;\nimport com.gainsight.integration.bean.db.common.Conditions;\nimport com.gainsight.integration.bean.db.common.FieldInfo;\nimport com.gainsight.integration.bean.db.common.TaskInfo;\nimport com.gainsight.integration.bean.enums.TaskType;\nimport com.gainsight.integration.bean.enums.common.ConnectorType;\nimport com.gainsight.integration.connection.db.bean.PicklistOption;\nimport com.gainsight.integration.dataExtract.PaginatedDataExtractionService;\nimport com.gainsight.integration.dataExtract.bean.DataExtractionRequest;\nimport com.gainsight.integration.exception.externaltasks.ExternalTaskException;\nimport com.gainsight.integration.exception.externaltasks.ExternalTasksValidationCode;\nimport com.gainsight.integration.staging.beans.DatabaseConnectionRequest;\nimport com.gainsight.integration.staging.beans.IpaasStagingDetails;\nimport com.gainsight.integration.staging.beans.IpaasStagingFieldInfo;\nimport com.gainsight.integration.staging.services.IpaasStagingDetailsDao;\nimport com.gainsight.integration.staging.services.IpaasStagingDetailsDaoImpl;\nimport com.gainsight.integration.staging.utils.DatabaseConnectionPoolUtility;\nimport com.gainsight.integration.utils.common.UCConstants;\nimport com.gainsight.services.dataprocessing.commons.audit.AuditMetadata;\nimport com.gainsight.services.dataprocessing.commons.cryptography.CryptUtil;\nimport com.gainsight.services.dataprocessing.commons.exception.DPSystemException;\nimport com.gainsight.services.dataprocessing.commons.pojo.JsonFileContentType;\nimport com.gainsight.services.dataprocessing.commons.pojo.fields.FieldType;\nimport com.gainsight.services.dataprocessing.commons.pojo.workflow.DPWorkflowJobDetailsDTO;\nimport com.gainsight.services.dataprocessing.commons.properties.DeploymentProperties;\nimport com.gainsight.services.dataprocessing.dataexternals.mda.MDACalloutsService;\nimport com.gainsight.services.dataprocessing.dataexternals.mda.MDACalloutsServiceImpl;\nimport com.gainsight.services.dataprocessing.dataprocessor.dagdataprocessor.pojo.ExternalExtractionTaskResult;\nimport com.gainsight.services.dataprocessing.dataprocessor.dagdataprocessor.pojo.TaskResult;\nimport com.gainsight.services.dataprocessing.dataprocessor.dagdataprocessor.utils.TaskExecutorWorkflowUtils;\nimport com.gainsight.services.dataprocessing.external.task.ExternalTaskRequestContext;\nimport com.gainsight.services.dataprocessing.external.task.ExternalTaskUtil;\nimport com.gainsight.services.utilities.datahighway.dhcommons.pojo.base.connection.PNPConnectionInput;\nimport com.gainsight.services.utilities.datahighway.dhcommons.pojo.base.connection.PNPConnectionsInfo;\nimport com.gainsight.services.utilities.datahighway.dhcommons.pojo.base.connection.RelationalDBConnectionDetail;\nimport com.gainsight.services.utilities.datahighway.dhquerybuilder.constructs.custom.DateTimeProperties;\nimport com.gainsight.services.utilities.datahighway.dhquerybuilder.constructs.filters.FilterOperator;\nimport com.gainsight.services.utilities.datahighway.dhquerybuilder.constructs.filters.FilterRule;\nimport com.google.common.base.Stopwatch;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport com.google.common.collect.Sets;\nimport com.google.gson.*;\nimport com.google.gson.reflect.TypeToken;\nimport net.snowflake.client.jdbc.internal.apache.commons.io.FileUtils;\nimport org.apache.commons.collections4.CollectionUtils;\nimport org.apache.commons.collections4.MapUtils;\nimport org.apache.commons.dbcp2.BasicDataSource;\nimport org.apache.commons.lang3.StringUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.File;\nimport java.lang.reflect.Type;\nimport java.net.URLEncoder;\nimport java.time.ZoneId;\nimport java.time.ZonedDateTime;\nimport java.time.format.DateTimeFormatter;\nimport java.util.*;\nimport java.util.concurrent.TimeUnit;\nimport java.util.stream.Collectors;\n\nimport static com.gainsight.integration.bean.IPaasConstants.IS_CURRENCY_FIELD;\nimport static com.gainsight.integration.bean.IPaasConstants.PAGE_SIZE;\nimport static com.gainsight.services.dataprocessing.commons.audit.AuditMetadata.newInstance;\nimport static com.gainsight.services.dataprocessing.commons.constants.Constants.MDA_GAINSIGHT_B2B_SECRET;\nimport static com.gainsight.services.dataprocessing.commons.exception.ValidationCode.GENERIC_SYSTEM_ERROR;\nimport static com.gainsight.services.dataprocessing.commons.system.Precondition.isNotNull;\nimport static com.gainsight.services.dataprocessing.commons.utils.DPUtils.convertJsonToObject;\n\n/**\n * @author Manas Ranjan Sur (msur@gainsight.com)\n * created on 05-APR-2020\n * External Task for extracting records from ipaas\n */\n\npublic class IpaasExtractionTask {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(IpaasExtractionTask.class);\n    public static final String IPAAS_EXTRACT_DETAILS_KEY = \"ipaasExtractDetails\";\n    private static final String DATA = \"data\";\n    private static final String VALUE = \"value\";\n    private static final String IPAAS_INSTANCE_TOKEN = \"IPAAS_INSTANCE_TOKEN\";\n    private static final String IPAAS_ORG_TOKEN = \"IPAAS_ORG_TOKEN\";\n    private static final String IPAAS_USER_TOKEN = \"IPAAS_USER_TOKEN\";\n    private static final String IPAAS_EXCLUDE_STRING = \"uc.ipaas.external.task.excluded.string.list\";\n\n    public static void main(String[] args) {\n        executeTask(ExternalTaskUtil.getExternalTaskRequestContext());\n    }\n\n    private static void executeTask(ExternalTaskRequestContext externalTaskRequestContext) {\n        Stopwatch stopwatch = Stopwatch.createStarted();\n        ExternalExtractionTaskResult externalExtractionTaskResult = null;\n        String jobId = externalTaskRequestContext.getJobId();\n        String taskId = externalTaskRequestContext.getTaskId();\n        //Get workflowJobDetails of given jobId\n        DPWorkflowJobDetailsDTO workflowJobDetails = externalTaskRequestContext.getWorkflowJobDetails();\n        String tenantId = externalTaskRequestContext.getTenantId();\n        LOGGER.info(\"Request to ipaas extraction started !!  tId- {}, jobId- {}, taskId- {}\", tenantId, jobId, taskId);\n        LOGGER.info(\"checking : \", DeploymentProperties.getDeploymentProperties().getValue(MDA_GAINSIGHT_B2B_SECRET));\n        List<File> fileList = null;\n        try {\n            Map<String, String> metaData = externalTaskRequestContext.getMetaData();\n            AuditMetadata auditMetadata = newInstance(workflowJobDetails.getTenantId(), workflowJobDetails.getJobId(),\n                    workflowJobDetails.getExternalId(), taskId, externalTaskRequestContext.getTaskName());\n\n            IpaasExtractionDetails fetchTaskDetails = convertJsonToObject(metaData.get(IPAAS_EXTRACT_DETAILS_KEY), IpaasExtractionDetails.class);//todo remove from constants\n            LOGGER.info(\"MDA call out to fetch ipaas connection info for . connectionId : {}, tId- {}, jobId- {}, taskId- {}\",\n                    fetchTaskDetails.getConnectionId(), tenantId, jobId, taskId);\n            MDACalloutsService mdaCalloutsService = MDACalloutsService.createOrGetInstance(workflowJobDetails.getSystemToken(),\n                    TaskExecutorWorkflowUtils.getConfigSourceUrl(workflowJobDetails), auditMetadata);\n            String ipaasConnectionUrl = \"/connector/ipaas/connection/datahighway/\" + fetchTaskDetails.getConnectionId();\n            JsonObject jsonObject = mdaCalloutsService.getIpaasDetailsFromMDA(ipaasConnectionUrl, workflowJobDetails.getTenantId(), false);\n            isNotNull(jsonObject, GENERIC_SYSTEM_ERROR, \"No connection details found for this connection\");\n            LOGGER.info(\"Ipaas source connection details response :{}  for connectionId : {}, tId- {}, jobId- {}, taskId- {}\",\n                    jsonObject.get(\"result\").getAsBoolean(), fetchTaskDetails.getConnectionId(), tenantId, jobId, taskId);\n            if (!jsonObject.get(\"result\").getAsBoolean()) {\n                throw new ExternalTaskException(500, ExternalTasksValidationCode.IPAAS_CONNECTION_INFO_NOT_FOUND,\n                        String.format(\"Ipaas Connection info not found for id : %s\", fetchTaskDetails.getConnectionId()));\n            }\n            JsonObject data = jsonObject.get(DATA).getAsJsonObject();\n            if (data == null || data.isJsonNull())\n                throw new ExternalTaskException(500, ExternalTasksValidationCode.IPAAS_CONNECTION_INFO_NOT_FOUND,\n                        String.format(\"Ipaas Connection info is empty for id : %s\", fetchTaskDetails.getConnectionId()));\n            JsonObject decryptedObject = new JsonParser().parse(CryptUtil.decrypt(data.get(VALUE).getAsString())).getAsJsonObject();\n            Type type = new TypeToken<Map<String, Object>>() {\n            }.getType();\n            Map<String, Object> connectionDetailsMap = new Gson().fromJson(decryptedObject, type);\n            //extraction from ipaas\n            LOGGER.info(\"Fetching ipaas connection details ended. connectionId- {}, tId- {}, jobId- {}, taskId- {}\",\n                    fetchTaskDetails.getConnectionId(), tenantId, jobId, taskId);\n\n            //fetch dp staging details\n            if (fetchTaskDetails.getStagingConnectionInfo() != null) {\n                stagingDetailsProcessing(workflowJobDetails, tenantId, jobId, taskId, fetchTaskDetails, externalTaskRequestContext);\n            }\n\n            //fetch ipaas job & task details\n            LOGGER.info(\"MDA call out to fetch ipaas job and task details started. connectionId- {}, tId- {}, jobId- {}, taskId- {}\",\n                    fetchTaskDetails.getConnectionId(), tenantId, jobId, taskId);\n            String ipaasJobDetailsUrl = \"/connector/job/datahighway/\" + fetchTaskDetails.getJobId();\n            JsonObject obj = mdaCalloutsService.getIpaasDetailsFromMDA(ipaasJobDetailsUrl, workflowJobDetails.getTenantId(), false);\n\n            Type taskType = new TypeToken<List<TaskInfo>>() {\n            }.getType();\n            List<TaskInfo> taskInfos = new Gson().fromJson(obj.get(DATA).getAsJsonObject().get(\"taskInfo\"), taskType);\n\n            Map<String, String> ntzFields = Maps.newHashMap();\n            if (ConnectorType.SNOWFLAKE.equals(ConnectorType.getConnectorType(fetchTaskDetails.getConnectorType()))) {\n                List<TaskInfo> extractTaskInfos = taskInfos.stream().filter(taskInfo -> taskInfo.getTaskType().equals(TaskType.IPAAS_EXTRACT)).collect(Collectors.toList());\n                if (CollectionUtils.isNotEmpty(extractTaskInfos)) {\n                    extractTaskInfos.stream().forEach(taskInfo -> {\n                        if (CollectionUtils.isNotEmpty(taskInfo.getFieldInfoList())) {\n                            taskInfo.getFieldInfoList().stream().forEach(fieldInfo -> {\n                                        if (fieldInfo.getDataType().equals(\"date-time\") && fieldInfo.getMeta().containsKey(\"NTZ_ZONE_ID\")) {\n                                            ntzFields.put(fieldInfo.getPath(), fieldInfo.getMeta().get(\"NTZ_ZONE_ID\").toString());\n                                        }\n                                    }\n                            );\n                        }\n                    });\n                }\n            }\n\n            TaskInfo taskInfo = taskInfos.stream().filter(i -> i.getTaskId().equalsIgnoreCase(fetchTaskDetails.getTaskId()))\n                    .findFirst().get();\n            LOGGER.info(\"Fetched ipaas job and task details ended. connectionId- {}, tId- {}, jobId- {}, taskId- {}\",\n                    fetchTaskDetails.getConnectionId(), tenantId, jobId, taskId);\n            Map<String, List<PicklistOption>> picklistMap = Maps.newHashMap();\n\n\n            mdaCalloutsService = MDACalloutsService.createOrGetInstance(workflowJobDetails.getSystemToken(),\n                    TaskExecutorWorkflowUtils.getConfigSourceUrl(workflowJobDetails), auditMetadata);\n            StringBuilder objectMetaDataUrl = new StringBuilder(\"/connector/ipaas/metadata/datahighway/\")\n                    .append(taskInfo.getConnectionDetails().getConnectionId())\n                    .append(\"/\")\n                    .append(fetchTaskDetails.getExternalEntityName().trim().replaceAll(UCConstants.SPACE, \"%20\"))\n                    .append(\"/attributes\");\n            JsonObject objectMetaDataFromConnectors = mdaCalloutsService.getIpaasDetailsFromMDA(\n                    objectMetaDataUrl.toString(), workflowJobDetails.getTenantId(), false);\n            Set<String> ipaasFields = Sets.newHashSet();\n\n            for (FieldInfo field : taskInfo.getFieldInfoList()) {\n                validateMappingsExistInExternalSystem(field, objectMetaDataFromConnectors, ipaasFields);\n            }\n            if (null != taskInfo.getCriteria() && !taskInfo.getCriteria().getConditions().isEmpty()) {\n                for (Conditions condition : taskInfo.getCriteria().getConditions()) {\n                    if (!condition.isCustomizedFilterField())\n                        validateMappingsExistInExternalSystem(condition.getLeftOperand(), objectMetaDataFromConnectors, ipaasFields);\n                }\n            }\n\n            if (!ipaasFields.isEmpty()) {\n                if (!ConnectorType.FRESHDESK.equals(ConnectorType.getConnectorType(fetchTaskDetails.getConnectorType()))) {\n                    LOGGER.error(\"Exception while executing externalTask due to validation failure as fields are not present in external system tId- {}, jobId- {}, taskId- {}  with error - {}\",\n                            tenantId, jobId, taskId, ipaasFields);\n                    throw new ExternalTaskException(500, ExternalTasksValidationCode.FIELD_NOT_PRESENT_IN_SYSTEM,\n                            String.format(\"The job cannot be completed as the %s field was either deleted from the source or user is not authorised to access the field.Remove the field from connector mappings and re-run the job.\", ipaasFields));   // throw new DPSystemException(IpaasExtractionValidationCode.FIELD_NOT_PRESENT_IN_SYSTEM,String.format(\"Column %s does not exist. Possible causes: The column is deleted or the Integration/OAuth user does not have read permissions on the field.\", ipaasFields));\n                }else{\n                    LOGGER.warn(\"Not throwing exception for FRESHDESK connector, fields are missing {}\", ipaasFields);\n                }\n            }\n\n            if (fetchTaskDetails.isResolvePicklist()) {\n                boolean isPicklistFieldPresent = taskInfo.getFieldInfoList().stream().anyMatch(\n                        task -> (Boolean) task.getMeta().get(\"isPicklistField\"));\n                if (!isPicklistFieldPresent && taskInfo.getCriteria() != null && taskInfo.getCriteria().getConditions() != null && !taskInfo.getCriteria().getConditions().isEmpty()) {\n                    isPicklistFieldPresent = taskInfo.getCriteria().getConditions().stream().anyMatch(conditions -> conditions.getLeftOperand().getMeta().containsKey(\"isPicklistField\") && (Boolean) conditions.getLeftOperand().getMeta().get(\"isPicklistField\"));\n                }\n                if (isPicklistFieldPresent) {\n\n                    for (FieldInfo field : taskInfo.getFieldInfoList()) {\n                        populatePicklistMap(picklistMap, objectMetaDataFromConnectors, field);\n                    }\n                    if (null != taskInfo.getCriteria() && !taskInfo.getCriteria().getConditions().isEmpty()) {\n                        for (Conditions condition : taskInfo.getCriteria().getConditions()) {\n                            if (!condition.isCustomizedFilterField())\n                                populatePicklistMap(picklistMap, objectMetaDataFromConnectors, condition.getLeftOperand());\n                        }\n                    }\n                }\n            }\n            PaginatedDataExtractionService paginatedDataExtractionService = new PaginatedDataExtractionService();\n            List<com.gainsight.services.utilities.datahighway.dhquerybuilder.constructs.fields.FieldInfo> fieldInfoList = Lists.newArrayList();\n            fetchTaskDetails.getProjections().forEach(projection -> fieldInfoList.add(getFieldInfoList(projection)));\n            DataExtractionRequest dataExtractionRequest = new DataExtractionRequest();\n            dataExtractionRequest.setObjectName(fetchTaskDetails.getExternalEntityName());\n            dataExtractionRequest.setInstanceToken(SecretData.fromValue(connectionDetailsMap.get(IPAAS_INSTANCE_TOKEN).toString()));\n            dataExtractionRequest.setUserToken(SecretData.fromValue(connectionDetailsMap.get(IPAAS_USER_TOKEN).toString()));\n            dataExtractionRequest.setOrgToken(connectionDetailsMap.get(IPAAS_ORG_TOKEN).toString());\n            dataExtractionRequest.setJobId(workflowJobDetails.getJobId());\n            dataExtractionRequest.setConnectorType(ConnectorType.getConnectorType(fetchTaskDetails.getConnectorType()));\n            String ipaasExcludeString = DeploymentProperties.getDeploymentProperties().getValue(IPAAS_EXCLUDE_STRING);\n            if (StringUtils.isNotEmpty(ipaasExcludeString)) {\n                ipaasExcludeString = ipaasExcludeString.concat(\",\");\n            }\n            ipaasExcludeString = ipaasExcludeString.concat(\"\\u0000\");\n            List<String> excludedStringList = Arrays.asList(ipaasExcludeString.split(\",\"));\n            dataExtractionRequest.getProperties().put(\"ceTimeOut\", DeploymentProperties.getDeploymentProperties().getIntegerValue(\"ce.call.timeout.in.milli.secs\", 60000));\n            dataExtractionRequest.setExcludedStrings(excludedStringList);\n            LOGGER.info(\"Excluded Strings: {}\", dataExtractionRequest.getExcludedStrings());\n            dataExtractionRequest.setFilterRule(fetchTaskDetails.getWhereClause());\n            dataExtractionRequest.setFields(fieldInfoList);\n            if (DeploymentProperties.getDeploymentProperties().getBooleanValue(\"default.snowflake.enabled\", true)\n                    || DeploymentProperties.getDeploymentProperties().getValue(\"snowflake.tenant.list\").contains(RequestContextProvider.getTenantId())) {\n                dataExtractionRequest.getProperties().put(\"isJdbcSnowflakeRequired\", true);\n            } else {\n                dataExtractionRequest.getProperties().put(\"isJdbcSnowflakeRequired\", false);\n            }\n            dataExtractionRequest.getProperties().put(\"snowflakeFileSize\", DeploymentProperties.getDeploymentProperties().getLongValue(\"snowflake.file.size\", 200000000));\n            dataExtractionRequest.getProperties().put(\"snowflakeBatchLimit\", DeploymentProperties.getDeploymentProperties().getIntegerValue(\"snowflake.batch.limit\", 10000));\n            dataExtractionRequest.setCloudElementsBaseUrl(connectionDetailsMap.get(\"baseUrl\").toString());\n            dataExtractionRequest.setDateTimeConversionRequired(Boolean.parseBoolean(connectionDetailsMap.get(\"isDateTimeConversionRequired\").toString()));\n            dataExtractionRequest.getProperties().put(PAGE_SIZE, fetchTaskDetails.getPageSize());\n            dataExtractionRequest.getProperties().put(\"skipFieldsAsQueryParam\", fetchTaskDetails.isSkipFieldsForFetch());\n            dataExtractionRequest.setLastModifiedFieldName(fetchTaskDetails.getLastModifieldFieldPath());\n            dataExtractionRequest.setLastModifiedFieldValue(fetchTaskDetails.getLastModifieldFieldValue());\n            dataExtractionRequest.setHonourLastModfiedFieldValueToFetchDeltaData(fetchTaskDetails.isHonourLastModfiedFieldValueToFetchDeltaData());\n            dataExtractionRequest.setIgnorableErrorMessages(fetchTaskDetails.getIgnorableErrorMessages());\n            dataExtractionRequest.setQueryParamForDataFetch(fetchTaskDetails.getQueryParamForDataFetch());\n            dataExtractionRequest.setPicklistOptionMap(picklistMap);\n            dataExtractionRequest.getProperties().putAll(connectionDetailsMap);\n            taskInfo.getFieldInfoList().stream().filter(fieldInfo -> fieldInfo.getMeta().containsKey(\"isPrimaryKey\") && (Boolean) fieldInfo.getMeta().get(\"isPrimaryKey\")).findFirst().ifPresent(fieldInfo -> dataExtractionRequest.setPrimaryField(fieldInfo.getPath()));\n\n\n            if (null != fetchTaskDetails.getOrderByInfo() && !fetchTaskDetails.getOrderByInfo().getOrderByFields().isEmpty()) {\n                if (fetchTaskDetails.getOrderByInfo().isAscending()) {\n                    dataExtractionRequest.setOrderByInfoField(fetchTaskDetails.getOrderByInfo().getOrderByFields().get(0).getJsonPath() + URLEncoder.encode(\" \" + \"asc\", \"UTF-8\"));\n                } else {\n                    dataExtractionRequest.setOrderByInfoField(fetchTaskDetails.getOrderByInfo().getOrderByFields().get(0).getJsonPath() + URLEncoder.encode(\" \" + \"desc\", \"UTF-8\"));\n                }\n            }\n            dataExtractionRequest.setDefaultSleepTimeOnFail(fetchTaskDetails.getDefaultSleepTimeOnFail());\n            dataExtractionRequest.setMaxNoOfRetries(fetchTaskDetails.getMaxNumberOfRetries());\n            if (!ntzFields.isEmpty()) {\n                dataExtractionRequest.getProperties().put(\"NTZ_FIELDS\", ntzFields);\n            }\n\n            if (MapUtils.isNotEmpty(fetchTaskDetails.getAdditionalInformation())) {\n\n                dataExtractionRequest.getProperties().putAll(fetchTaskDetails.getAdditionalInformation());\n            }\n            if (StringUtils.isNotEmpty(fetchTaskDetails.getQuery())) {\n                dataExtractionRequest.getProperties().put(\"CUSTOM_QUERY\", fetchTaskDetails.getQuery());\n            }\n\n            fileList = paginatedDataExtractionService.extractData(dataExtractionRequest);\n            LOGGER.info(\"Ipaas Extraction started, tId- {}, jobId- {}, taskId- {}\", tenantId, jobId, taskId);\n\n\n            if (null != taskInfo.getCriteria()) {\n                taskInfo.getCriteria().getConditions().stream().filter(Objects::nonNull).forEach(criteria -> {\n                    if (criteria.getLeftOperand().getMeta().containsKey(IS_CURRENCY_FIELD)) {\n                        com.gainsight.services.dataprocessing.commons.pojo.fields.FieldInfo fieldInfoForCurrencyValue = new com.gainsight.services.dataprocessing.commons.pojo.fields.FieldInfo();\n                        fieldInfoForCurrencyValue.setDecimalPlaces(16);\n                        fieldInfoForCurrencyValue.setDataType(com.gainsight.services.dataprocessing.commons.pojo.DataType.NUMBER);\n                        fieldInfoForCurrencyValue.setName(criteria.getLeftOperand().getFieldName() + IPaasConstants.CURRENCY_FIELD);\n                        fieldInfoForCurrencyValue.setJsonPath(criteria.getLeftOperand().getFieldName() + IPaasConstants.CURRENCY_FIELD);\n                        fieldInfoForCurrencyValue.setFieldAlias(criteria.getLeftOperand().getFieldAlias() + IPaasConstants.CURRENCY_FIELD);\n                        fieldInfoForCurrencyValue.setFieldType(FieldType.FIELD);\n                        fetchTaskDetails.getProjections().add(fieldInfoForCurrencyValue);\n                    }\n                });\n            }\n            TaskResult taskResult = new TaskResult(fetchTaskDetails.getProjections(), null);\n\n            externalExtractionTaskResult = new ExternalExtractionTaskResult.ExternalExtractionTaskResultBuilder()\n                    .setTaskResult(taskResult)\n                    .setExtractedFiles(fileList.stream().map(file -> file.getAbsolutePath()).collect(Collectors.toList()))\n                    .setJsonData(true)\n                    .setJsonFileContentType(JsonFileContentType.LINE_SEPARATED_OBJECTS)\n                    .setPushExtractedDataToS3(fetchTaskDetails.isEnableDownloadSourceData())\n                    //.setPushExtractedDataToS3(true)\n                    .setExcludedStrings(ipaasExcludeString)\n                    .setIgnoreInvalidData(fetchTaskDetails.isIgnoreInvalidData())\n                    .build();\n            ExternalTaskUtil.saveExternalTaskResult(workflowJobDetails.getTenantId(), jobId, taskId, externalExtractionTaskResult);\n            LOGGER.info(\"Request to ipaas fetch completed in {} secs for tId- {}, jobId- {}, taskId- {}\",\n                    stopwatch.elapsed(TimeUnit.SECONDS), tenantId, jobId, taskId);\n        } catch (Exception ex) {\n            LOGGER.error(\"Exception while executing IpaasExtractiontask external.  tId- {}, jobId- {}, taskId- {}  with error - {}\",\n                    tenantId, jobId, taskId, ex);\n            if (CollectionUtils.isNotEmpty(fileList)) {\n                for (File file : fileList) {\n                    FileUtils.deleteQuietly(file);\n                }\n            }\n            if (ex instanceof ExternalTaskException)\n                throw new ExternalTaskException(((ExternalTaskException) ex).getHttpStatus(),\n                        ((ExternalTaskException) ex).getErrorCode(), ((ExternalTaskException) ex).getErrorMessage(), ex.getMessage());\n            else if (ex instanceof DPSystemException)\n                throw new ExternalTaskException(500, ExternalTasksValidationCode.DP_SYSTEM_EXCPETION,\n                        String.format(\"Failing with DP system exception due to : %s\", ex));\n            else\n                throw new ExternalTaskException(500, ExternalTasksValidationCode.GENERIC_ERROR,\n                        String.format(\"Failing with some exception due to : %s\", ex));\n        }\n    }\n\n    private static void validateMappingsExistInExternalSystem(FieldInfo field, JsonObject objectMetaDataFromConnectors, Set<String> ipaasFields) {\n        JsonObject data;\n        data = objectMetaDataFromConnectors.get(DATA).getAsJsonObject();\n        JsonArray fields = data.get(\"fields\").getAsJsonArray();\n        Iterator<JsonElement> iterator = fields.iterator();\n        boolean found = false;\n        while (iterator.hasNext()) {\n            JsonObject fieldInfo = iterator.next().getAsJsonObject();\n            JsonObject meta = fieldInfo.get(\"meta\").getAsJsonObject();\n            if (meta.getAsJsonObject().get(\"path\").getAsString().equals(field.getPath())) {\n                found = true;\n                break;\n            }\n        }\n        if (!found) {\n            ipaasFields.add(field.getLabel());\n        }\n    }\n\n    private static void populatePicklistMap(Map<String, List<PicklistOption>> picklistMap,\n                                            JsonObject objectMetaDataFromConnectors, FieldInfo field) {\n        JsonObject data;\n\n        if (field.getMeta().containsKey(\"isPicklistField\") && (Boolean) field.getMeta().get(\"isPicklistField\")) {\n            data = objectMetaDataFromConnectors.get(DATA).getAsJsonObject();\n            JsonArray fields = data.get(\"fields\").getAsJsonArray();\n            Iterator<JsonElement> iterator = fields.iterator();\n            List<PicklistOption> picklistList = Lists.newArrayList();\n            while (iterator.hasNext()) {\n                JsonObject fieldInfo = iterator.next().getAsJsonObject();\n                JsonObject meta = fieldInfo.get(\"meta\").getAsJsonObject();\n                if (meta.getAsJsonObject().get(\"path\").getAsString().equals(field.getPath()) &&\n                        meta.getAsJsonObject().get(\"isPicklistField\").getAsBoolean()) {\n                    JsonArray options = fieldInfo.get(\"options\").getAsJsonArray();\n                    options.forEach(option -> {\n                        PicklistOption picklistOption = new PicklistOption();\n                        picklistOption.setPicklistLabel(option.getAsJsonObject().get(\"label\").getAsString());\n                        picklistOption.setPicklistValue(option.getAsJsonObject().get(\"value\").getAsString());\n                        picklistList.add(picklistOption);\n                    });\n                }\n            }\n            picklistMap.put(field.getPath(), picklistList);\n        }\n        LOGGER.info(\"Populated picklist map with {}\", picklistMap);\n    }\n\n    private static void stagingDetailsProcessing(DPWorkflowJobDetailsDTO workflowJobDetails, String tenantId, String jobId,\n                                                 String taskId, IpaasExtractionDetails fetchTaskDetails,\n                                                 ExternalTaskRequestContext externalTaskRequestContext) throws Exception {\n        String configSourceUrl = ExternalTaskUtil.getConfigSourceUrl(workflowJobDetails);\n        String gsB2BSecret = DeploymentProperties.getDeploymentProperties().getValue(MDA_GAINSIGHT_B2B_SECRET);\n        LOGGER.info(\"MDA call out to fetch ipaas staging postgres details started uc connectionId- {}, tId- {}, jobId- {}, taskId- {}\",\n                fetchTaskDetails.getStagingConnectionInfo().getConnectionId(), tenantId, jobId, taskId);\n        MDACalloutsService mdaCalloutsService = new MDACalloutsServiceImpl(gsB2BSecret, configSourceUrl);\n        PNPConnectionInput pnpConnectionInput = mdaCalloutsService.getConnectionDetails(\n                fetchTaskDetails.getStagingConnectionInfo().getConnectionId(), externalTaskRequestContext.getTenantId());\n\n        PNPConnectionsInfo pnpConnectionsInfo = pnpConnectionInput.getPnpConnectionsInfo();\n        RelationalDBConnectionDetail relationalDBConnectionDetail =\n                (RelationalDBConnectionDetail) pnpConnectionsInfo.getConnectionDetail();\n        LOGGER.info(\"Fetching ipaas staging postgres details ended. connectionId- {}, tId- {}, jobId- {}, taskId- {}\",\n                fetchTaskDetails.getStagingConnectionInfo().getConnectionId(), tenantId, jobId, taskId);\n        StringBuilder url = new StringBuilder();\n        url.append(CryptUtil.decrypt(relationalDBConnectionDetail.getHost())).append(\":\")\n                .append(CryptUtil.decrypt(relationalDBConnectionDetail.getPort()));\n        DatabaseConnectionRequest databaseConnectionRequest = new DatabaseConnectionRequest(\n                url.toString(),\n                CryptUtil.decrypt(relationalDBConnectionDetail.getDataBaseName()),\n                CryptUtil.decrypt(relationalDBConnectionDetail.getUser()),\n                CryptUtil.decrypt(relationalDBConnectionDetail.getPwd()),\n                Integer.parseInt(String.valueOf(pnpConnectionsInfo.getProperties().get(\"minIdle\"))),\n                Integer.parseInt(String.valueOf(pnpConnectionsInfo.getProperties().get(\"maxIdle\"))),\n                Integer.parseInt(String.valueOf(pnpConnectionsInfo.getProperties().get(\"initialSize\"))));\n        databaseConnectionRequest.setSslEnabled(relationalDBConnectionDetail.isSslEnabled());\n        BasicDataSource dataSource = DatabaseConnectionPoolUtility.getOrCreateConnection(databaseConnectionRequest);\n        IpaasStagingDetailsDao ipaasStagingDetailsDao = new IpaasStagingDetailsDaoImpl(dataSource);\n        LOGGER.info(\"fetching staging details.  tId- {}, jobId- {}, taskId- {}\", tenantId, jobId, taskId);\n        IpaasStagingDetails ipaasStagingDetails = ipaasStagingDetailsDao.findStagingDetails(workflowJobDetails.getTenantId(),\n                fetchTaskDetails.getTaskId(), fetchTaskDetails.getJobId());\n        LOGGER.info(\"Showing ipaas staging details. tId- {}, jobId- {}, taskId- {}, Ipaas staging details  : {}\",\n                tenantId, jobId, taskId, ipaasStagingDetails);\n\n        //checking and updating field Infos & columns\n        if (ipaasStagingDetails != null && (!ipaasStagingDetails.isInSync() || !checkSyncStatusForStagingDetails(ipaasStagingDetails, fetchTaskDetails.getProjections())\n                || isUpsertKeyChanged(ipaasStagingDetails, fetchTaskDetails.getUpsertkey()))) {\n            LOGGER.info(\"full sync required . Hence changing from date in filter for jobId:{}, taskId:{}, tenantId:{}. \",\n                    jobId, taskId, workflowJobDetails.getTenantId());\n            fetchTaskDetails.setLastModifieldFieldValue(0);\n            //setting from date as 1970-01-01T00:00:00.000Z for fetching historical data\n            if (fetchTaskDetails.getWhereClause() != null && !fetchTaskDetails.getWhereClause().getRules().isEmpty() &&\n                    StringUtils.isNotEmpty(fetchTaskDetails.getLastModifieldFieldPath())) {\n                setDateForHistoricSync(fetchTaskDetails.getWhereClause(), fetchTaskDetails.getLastModifieldFieldPath());\n                ipaasStagingDetailsDao.updateInSyncByJobIdAndTaskId(ipaasStagingDetails);\n            }\n        }\n    }\n\n    private static boolean isUpsertKeyChanged(IpaasStagingDetails ipaasStagingDetails, String newUpsertKey) {\n        boolean upsertKeyChanged = false;\n        if (CollectionUtils.isNotEmpty(ipaasStagingDetails.getFieldInfos()) && StringUtils.isNotEmpty(newUpsertKey)) {\n            Optional<IpaasStagingFieldInfo> ipaasStagingFieldInfo = ipaasStagingDetails.getFieldInfos().stream().filter(fieldInfo -> fieldInfo.isUpsertKey()).findFirst();\n            if (!ipaasStagingFieldInfo.isPresent() || !ipaasStagingFieldInfo.get().getFieldName().equalsIgnoreCase(newUpsertKey)) {\n                upsertKeyChanged = true;\n                LOGGER.info(\"new upsertKey selected. {}\", newUpsertKey);\n            }\n        }\n        return upsertKeyChanged;\n    }\n\n    private static void setDateForHistoricSync(FilterRule rule, String lastModifieldFieldPath) {\n        if (CollectionUtils.isEmpty(rule.getRules())) {\n            if (rule.getFieldInfo().getJsonPath().equalsIgnoreCase(lastModifieldFieldPath) &&\n                    rule.getOp() == FilterOperator.GT) {\n                try {\n                    DateTimeFormatter sourceDateTimeFormatter = DateTimeFormatter.ofPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSSz\");\n                    ZonedDateTime zonedDateTime = ZonedDateTime.parse(\"1970-01-01T00:00:00.000+00:00\", sourceDateTimeFormatter.withZone(ZoneId.of(\"UTC\")));\n\n                    DateTimeFormatter targetDateTimeFormatter = StringUtils.isNotEmpty(rule.getFieldInfo().getDateTimeProperties().getFormat())\n                            ? DateTimeFormatter.ofPattern(rule.getFieldInfo().getDateTimeProperties().getFormat())\n                            : DateTimeFormatter.ISO_OFFSET_DATE_TIME;\n\n                    ZoneId zoneId = StringUtils.isNotBlank(rule.getFieldInfo().getDateTimeProperties().getTimeZoneId())\n                            ? ZoneId.of(rule.getFieldInfo().getDateTimeProperties().getTimeZoneId())\n                            : ZoneId.of(\"UTC\");\n\n                    rule.getValues().get(0).setValue(zonedDateTime.format(targetDateTimeFormatter.withZone(zoneId)));\n\n                } catch (Exception e) {\n                    LOGGER.info(\"Date Parse exception occurred while setting from date. {}\", e);\n                    throw new ExternalTaskException(500, ExternalTasksValidationCode.DATE_PARSE_EXCEPTION,\n                            String.format(\"Date Parse exception occurred while setting from date to January 01, 1970 due to %s\", e));\n                }\n            }\n        } else {\n            rule.getRules().forEach(innerRule -> setDateForHistoricSync(innerRule, lastModifieldFieldPath));\n        }\n    }\n\n    private static com.gainsight.services.utilities.datahighway.dhquerybuilder.constructs.fields.FieldInfo getFieldInfoList(com.gainsight.services.dataprocessing.commons.pojo.fields.FieldInfo fetchTaskFieldInfo) {\n        com.gainsight.services.utilities.datahighway.dhquerybuilder.constructs.fields.FieldInfo fieldInfo = new com.gainsight.services.utilities.datahighway.dhquerybuilder.constructs.fields.FieldInfo();\n        fieldInfo.setName(fetchTaskFieldInfo.getName());\n        fieldInfo.setJsonPath(fetchTaskFieldInfo.getJsonPath());\n        fieldInfo.setFieldAlias(fetchTaskFieldInfo.getFieldAlias());\n        fieldInfo.setDecimalPlaces(fetchTaskFieldInfo.getDecimalPlaces());\n        if (null != fetchTaskFieldInfo.getDateTimeProperties()) {\n            DateTimeProperties dateTimeProperties = new DateTimeProperties();\n            dateTimeProperties.setFormat(fetchTaskFieldInfo.getDateTimeProperties().getFormat());\n            dateTimeProperties.setTimeZoneId(\"UTC\");\n            fieldInfo.setDateTimeProperties(dateTimeProperties);\n\n        }\n        fieldInfo.setDataType(com.gainsight.services.utilities.datahighway.dhcommons.enums.datatype.DataType.getDataType(fetchTaskFieldInfo.getDataType().getDataType()));\n        fieldInfo.setFieldType(com.gainsight.services.utilities.datahighway.dhquerybuilder.constructs.fields.FieldType.FIELD);\n        fieldInfo.setIsCurrencyField(fetchTaskFieldInfo.isIsCurrencyField());\n        return fieldInfo;\n    }\n\n    private static boolean checkSyncStatusForStagingDetails(IpaasStagingDetails ipaasStagingDetails,\n                                                            List<com.gainsight.services.dataprocessing.commons.pojo.fields.FieldInfo> ipaasFetchDetails) {\n        Set<String> sourceFieldNames = ipaasFetchDetails\n                .stream().map(i -> i.getFieldAlias())\n                .collect(Collectors.toSet());\n\n        List<String> existingFieldNames = ipaasStagingDetails.getFieldInfos()\n                .stream().map(i -> i.getFieldName())\n                .collect(Collectors.toList());\n\n        return existingFieldNames.size() == sourceFieldNames.size() && existingFieldNames.containsAll(sourceFieldNames);\n    }\n}"}
2025-05-13 20:59:48 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 20:59:48 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 20:59:48 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 20:59:48 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    public static void main(String[] args) {\n        executeTask(ExternalTaskUtil.getExternalTaskRequestContext());\n    }\n"}
2025-05-13 20:59:49 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 20:59:49 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 20:59:49 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 20:59:49 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    private static void executeTask(ExternalTaskRequestContext externalTaskRequestContext) {\n        Stopwatch stopwatch = Stopwatch.createStarted();\n        ExternalExtractionTaskResult externalExtractionTaskResult = null;\n        String jobId = externalTaskRequestContext.getJobId();\n        String taskId = externalTaskRequestContext.getTaskId();\n        //Get workflowJobDetails of given jobId\n        DPWorkflowJobDetailsDTO workflowJobDetails = externalTaskRequestContext.getWorkflowJobDetails();\n        String tenantId = externalTaskRequestContext.getTenantId();\n        LOGGER.info(\"Request to ipaas extraction started !!  tId- {}, jobId- {}, taskId- {}\", tenantId, jobId, taskId);\n        LOGGER.info(\"checking : \", DeploymentProperties.getDeploymentProperties().getValue(MDA_GAINSIGHT_B2B_SECRET));\n        List<File> fileList = null;\n        try {\n            Map<String, String> metaData = externalTaskRequestContext.getMetaData();\n            AuditMetadata auditMetadata = newInstance(workflowJobDetails.getTenantId(), workflowJobDetails.getJobId(),\n                    workflowJobDetails.getExternalId(), taskId, externalTaskRequestContext.getTaskName());\n\n            IpaasExtractionDetails fetchTaskDetails = convertJsonToObject(metaData.get(IPAAS_EXTRACT_DETAILS_KEY), IpaasExtractionDetails.class);//todo remove from constants\n            LOGGER.info(\"MDA call out to fetch ipaas connection info for . connectionId : {}, tId- {}, jobId- {}, taskId- {}\",\n                    fetchTaskDetails.getConnectionId(), tenantId, jobId, taskId);\n            MDACalloutsService mdaCalloutsService = MDACalloutsService.createOrGetInstance(workflowJobDetails.getSystemToken(),\n                    TaskExecutorWorkflowUtils.getConfigSourceUrl(workflowJobDetails), auditMetadata);\n            String ipaasConnectionUrl = \"/connector/ipaas/connection/datahighway/\" + fetchTaskDetails.getConnectionId();\n            JsonObject jsonObject = mdaCalloutsService.getIpaasDetailsFromMDA(ipaasConnectionUrl, workflowJobDetails.getTenantId(), false);\n            isNotNull(jsonObject, GENERIC_SYSTEM_ERROR, \"No connection details found for this connection\");\n            LOGGER.info(\"Ipaas source connection details response :{}  for connectionId : {}, tId- {}, jobId- {}, taskId- {}\",\n                    jsonObject.get(\"result\").getAsBoolean(), fetchTaskDetails.getConnectionId(), tenantId, jobId, taskId);\n            if (!jsonObject.get(\"result\").getAsBoolean()) {\n                throw new ExternalTaskException(500, ExternalTasksValidationCode.IPAAS_CONNECTION_INFO_NOT_FOUND,\n                        String.format(\"Ipaas Connection info not found for id : %s\", fetchTaskDetails.getConnectionId()));\n            }\n            JsonObject data = jsonObject.get(DATA).getAsJsonObject();\n            if (data == null || data.isJsonNull())\n                throw new ExternalTaskException(500, ExternalTasksValidationCode.IPAAS_CONNECTION_INFO_NOT_FOUND,\n                        String.format(\"Ipaas Connection info is empty for id : %s\", fetchTaskDetails.getConnectionId()));\n            JsonObject decryptedObject = new JsonParser().parse(CryptUtil.decrypt(data.get(VALUE).getAsString())).getAsJsonObject();\n            Type type = new TypeToken<Map<String, Object>>() {\n            }.getType();\n            Map<String, Object> connectionDetailsMap = new Gson().fromJson(decryptedObject, type);\n            //extraction from ipaas\n            LOGGER.info(\"Fetching ipaas connection details ended. connectionId- {}, tId- {}, jobId- {}, taskId- {}\",\n                    fetchTaskDetails.getConnectionId(), tenantId, jobId, taskId);\n\n            //fetch dp staging details\n            if (fetchTaskDetails.getStagingConnectionInfo() != null) {\n                stagingDetailsProcessing(workflowJobDetails, tenantId, jobId, taskId, fetchTaskDetails, externalTaskRequestContext);\n            }\n\n            //fetch ipaas job & task details\n            LOGGER.info(\"MDA call out to fetch ipaas job and task details started. connectionId- {}, tId- {}, jobId- {}, taskId- {}\",\n                    fetchTaskDetails.getConnectionId(), tenantId, jobId, taskId);\n            String ipaasJobDetailsUrl = \"/connector/job/datahighway/\" + fetchTaskDetails.getJobId();\n            JsonObject obj = mdaCalloutsService.getIpaasDetailsFromMDA(ipaasJobDetailsUrl, workflowJobDetails.getTenantId(), false);\n\n            Type taskType = new TypeToken<List<TaskInfo>>() {\n            }.getType();\n            List<TaskInfo> taskInfos = new Gson().fromJson(obj.get(DATA).getAsJsonObject().get(\"taskInfo\"), taskType);\n\n            Map<String, String> ntzFields = Maps.newHashMap();\n            if (ConnectorType.SNOWFLAKE.equals(ConnectorType.getConnectorType(fetchTaskDetails.getConnectorType()))) {\n                List<TaskInfo> extractTaskInfos = taskInfos.stream().filter(taskInfo -> taskInfo.getTaskType().equals(TaskType.IPAAS_EXTRACT)).collect(Collectors.toList());\n                if (CollectionUtils.isNotEmpty(extractTaskInfos)) {\n                    extractTaskInfos.stream().forEach(taskInfo -> {\n                        if (CollectionUtils.isNotEmpty(taskInfo.getFieldInfoList())) {\n                            taskInfo.getFieldInfoList().stream().forEach(fieldInfo -> {\n                                        if (fieldInfo.getDataType().equals(\"date-time\") && fieldInfo.getMeta().containsKey(\"NTZ_ZONE_ID\")) {\n                                            ntzFields.put(fieldInfo.getPath(), fieldInfo.getMeta().get(\"NTZ_ZONE_ID\").toString());\n                                        }\n                                    }\n                            );\n                        }\n                    });\n                }\n            }\n\n            TaskInfo taskInfo = taskInfos.stream().filter(i -> i.getTaskId().equalsIgnoreCase(fetchTaskDetails.getTaskId()))\n                    .findFirst().get();\n            LOGGER.info(\"Fetched ipaas job and task details ended. connectionId- {}, tId- {}, jobId- {}, taskId- {}\",\n                    fetchTaskDetails.getConnectionId(), tenantId, jobId, taskId);\n            Map<String, List<PicklistOption>> picklistMap = Maps.newHashMap();\n\n\n            mdaCalloutsService = MDACalloutsService.createOrGetInstance(workflowJobDetails.getSystemToken(),\n                    TaskExecutorWorkflowUtils.getConfigSourceUrl(workflowJobDetails), auditMetadata);\n            StringBuilder objectMetaDataUrl = new StringBuilder(\"/connector/ipaas/metadata/datahighway/\")\n                    .append(taskInfo.getConnectionDetails().getConnectionId())\n                    .append(\"/\")\n                    .append(fetchTaskDetails.getExternalEntityName().trim().replaceAll(UCConstants.SPACE, \"%20\"))\n                    .append(\"/attributes\");\n            JsonObject objectMetaDataFromConnectors = mdaCalloutsService.getIpaasDetailsFromMDA(\n                    objectMetaDataUrl.toString(), workflowJobDetails.getTenantId(), false);\n            Set<String> ipaasFields = Sets.newHashSet();\n\n            for (FieldInfo field : taskInfo.getFieldInfoList()) {\n                validateMappingsExistInExternalSystem(field, objectMetaDataFromConnectors, ipaasFields);\n            }\n            if (null != taskInfo.getCriteria() && !taskInfo.getCriteria().getConditions().isEmpty()) {\n                for (Conditions condition : taskInfo.getCriteria().getConditions()) {\n                    if (!condition.isCustomizedFilterField())\n                        validateMappingsExistInExternalSystem(condition.getLeftOperand(), objectMetaDataFromConnectors, ipaasFields);\n                }\n            }\n\n            if (!ipaasFields.isEmpty()) {\n                if (!ConnectorType.FRESHDESK.equals(ConnectorType.getConnectorType(fetchTaskDetails.getConnectorType()))) {\n                    LOGGER.error(\"Exception while executing externalTask due to validation failure as fields are not present in external system tId- {}, jobId- {}, taskId- {}  with error - {}\",\n                            tenantId, jobId, taskId, ipaasFields);\n                    throw new ExternalTaskException(500, ExternalTasksValidationCode.FIELD_NOT_PRESENT_IN_SYSTEM,\n                            String.format(\"The job cannot be completed as the %s field was either deleted from the source or user is not authorised to access the field.Remove the field from connector mappings and re-run the job.\", ipaasFields));   // throw new DPSystemException(IpaasExtractionValidationCode.FIELD_NOT_PRESENT_IN_SYSTEM,String.format(\"Column %s does not exist. Possible causes: The column is deleted or the Integration/OAuth user does not have read permissions on the field.\", ipaasFields));\n                }else{\n                    LOGGER.warn(\"Not throwing exception for FRESHDESK connector, fields are missing {}\", ipaasFields);\n                }\n            }\n\n            if (fetchTaskDetails.isResolvePicklist()) {\n                boolean isPicklistFieldPresent = taskInfo.getFieldInfoList().stream().anyMatch(\n                        task -> (Boolean) task.getMeta().get(\"isPicklistField\"));\n                if (!isPicklistFieldPresent && taskInfo.getCriteria() != null && taskInfo.getCriteria().getConditions() != null && !taskInfo.getCriteria().getConditions().isEmpty()) {\n                    isPicklistFieldPresent = taskInfo.getCriteria().getConditions().stream().anyMatch(conditions -> conditions.getLeftOperand().getMeta().containsKey(\"isPicklistField\") && (Boolean) conditions.getLeftOperand().getMeta().get(\"isPicklistField\"));\n                }\n                if (isPicklistFieldPresent) {\n\n                    for (FieldInfo field : taskInfo.getFieldInfoList()) {\n                        populatePicklistMap(picklistMap, objectMetaDataFromConnectors, field);\n                    }\n                    if (null != taskInfo.getCriteria() && !taskInfo.getCriteria().getConditions().isEmpty()) {\n                        for (Conditions condition : taskInfo.getCriteria().getConditions()) {\n                            if (!condition.isCustomizedFilterField())\n                                populatePicklistMap(picklistMap, objectMetaDataFromConnectors, condition.getLeftOperand());\n                        }\n                    }\n                }\n            }\n            PaginatedDataExtractionService paginatedDataExtractionService = new PaginatedDataExtractionService();\n            List<com.gainsight.services.utilities.datahighway.dhquerybuilder.constructs.fields.FieldInfo> fieldInfoList = Lists.newArrayList();\n            fetchTaskDetails.getProjections().forEach(projection -> fieldInfoList.add(getFieldInfoList(projection)));\n            DataExtractionRequest dataExtractionRequest = new DataExtractionRequest();\n            dataExtractionRequest.setObjectName(fetchTaskDetails.getExternalEntityName());\n            dataExtractionRequest.setInstanceToken(SecretData.fromValue(connectionDetailsMap.get(IPAAS_INSTANCE_TOKEN).toString()));\n            dataExtractionRequest.setUserToken(SecretData.fromValue(connectionDetailsMap.get(IPAAS_USER_TOKEN).toString()));\n            dataExtractionRequest.setOrgToken(connectionDetailsMap.get(IPAAS_ORG_TOKEN).toString());\n            dataExtractionRequest.setJobId(workflowJobDetails.getJobId());\n            dataExtractionRequest.setConnectorType(ConnectorType.getConnectorType(fetchTaskDetails.getConnectorType()));\n            String ipaasExcludeString = DeploymentProperties.getDeploymentProperties().getValue(IPAAS_EXCLUDE_STRING);\n            if (StringUtils.isNotEmpty(ipaasExcludeString)) {\n                ipaasExcludeString = ipaasExcludeString.concat(\",\");\n            }\n            ipaasExcludeString = ipaasExcludeString.concat(\"\\u0000\");\n            List<String> excludedStringList = Arrays.asList(ipaasExcludeString.split(\",\"));\n            dataExtractionRequest.getProperties().put(\"ceTimeOut\", DeploymentProperties.getDeploymentProperties().getIntegerValue(\"ce.call.timeout.in.milli.secs\", 60000));\n            dataExtractionRequest.setExcludedStrings(excludedStringList);\n            LOGGER.info(\"Excluded Strings: {}\", dataExtractionRequest.getExcludedStrings());\n            dataExtractionRequest.setFilterRule(fetchTaskDetails.getWhereClause());\n            dataExtractionRequest.setFields(fieldInfoList);\n            if (DeploymentProperties.getDeploymentProperties().getBooleanValue(\"default.snowflake.enabled\", true)\n                    || DeploymentProperties.getDeploymentProperties().getValue(\"snowflake.tenant.list\").contains(RequestContextProvider.getTenantId())) {\n                dataExtractionRequest.getProperties().put(\"isJdbcSnowflakeRequired\", true);\n            } else {\n                dataExtractionRequest.getProperties().put(\"isJdbcSnowflakeRequired\", false);\n            }\n            dataExtractionRequest.getProperties().put(\"snowflakeFileSize\", DeploymentProperties.getDeploymentProperties().getLongValue(\"snowflake.file.size\", 200000000));\n            dataExtractionRequest.getProperties().put(\"snowflakeBatchLimit\", DeploymentProperties.getDeploymentProperties().getIntegerValue(\"snowflake.batch.limit\", 10000));\n            dataExtractionRequest.setCloudElementsBaseUrl(connectionDetailsMap.get(\"baseUrl\").toString());\n            dataExtractionRequest.setDateTimeConversionRequired(Boolean.parseBoolean(connectionDetailsMap.get(\"isDateTimeConversionRequired\").toString()));\n            dataExtractionRequest.getProperties().put(PAGE_SIZE, fetchTaskDetails.getPageSize());\n            dataExtractionRequest.getProperties().put(\"skipFieldsAsQueryParam\", fetchTaskDetails.isSkipFieldsForFetch());\n            dataExtractionRequest.setLastModifiedFieldName(fetchTaskDetails.getLastModifieldFieldPath());\n            dataExtractionRequest.setLastModifiedFieldValue(fetchTaskDetails.getLastModifieldFieldValue());\n            dataExtractionRequest.setHonourLastModfiedFieldValueToFetchDeltaData(fetchTaskDetails.isHonourLastModfiedFieldValueToFetchDeltaData());\n            dataExtractionRequest.setIgnorableErrorMessages(fetchTaskDetails.getIgnorableErrorMessages());\n            dataExtractionRequest.setQueryParamForDataFetch(fetchTaskDetails.getQueryParamForDataFetch());\n            dataExtractionRequest.setPicklistOptionMap(picklistMap);\n            dataExtractionRequest.getProperties().putAll(connectionDetailsMap);\n            taskInfo.getFieldInfoList().stream().filter(fieldInfo -> fieldInfo.getMeta().containsKey(\"isPrimaryKey\") && (Boolean) fieldInfo.getMeta().get(\"isPrimaryKey\")).findFirst().ifPresent(fieldInfo -> dataExtractionRequest.setPrimaryField(fieldInfo.getPath()));\n\n\n            if (null != fetchTaskDetails.getOrderByInfo() && !fetchTaskDetails.getOrderByInfo().getOrderByFields().isEmpty()) {\n                if (fetchTaskDetails.getOrderByInfo().isAscending()) {\n                    dataExtractionRequest.setOrderByInfoField(fetchTaskDetails.getOrderByInfo().getOrderByFields().get(0).getJsonPath() + URLEncoder.encode(\" \" + \"asc\", \"UTF-8\"));\n                } else {\n                    dataExtractionRequest.setOrderByInfoField(fetchTaskDetails.getOrderByInfo().getOrderByFields().get(0).getJsonPath() + URLEncoder.encode(\" \" + \"desc\", \"UTF-8\"));\n                }\n            }\n            dataExtractionRequest.setDefaultSleepTimeOnFail(fetchTaskDetails.getDefaultSleepTimeOnFail());\n            dataExtractionRequest.setMaxNoOfRetries(fetchTaskDetails.getMaxNumberOfRetries());\n            if (!ntzFields.isEmpty()) {\n                dataExtractionRequest.getProperties().put(\"NTZ_FIELDS\", ntzFields);\n            }\n\n            if (MapUtils.isNotEmpty(fetchTaskDetails.getAdditionalInformation())) {\n\n                dataExtractionRequest.getProperties().putAll(fetchTaskDetails.getAdditionalInformation());\n            }\n            if (StringUtils.isNotEmpty(fetchTaskDetails.getQuery())) {\n                dataExtractionRequest.getProperties().put(\"CUSTOM_QUERY\", fetchTaskDetails.getQuery());\n            }\n\n            fileList = paginatedDataExtractionService.extractData(dataExtractionRequest);\n            LOGGER.info(\"Ipaas Extraction started, tId- {}, jobId- {}, taskId- {}\", tenantId, jobId, taskId);\n\n\n            if (null != taskInfo.getCriteria()) {\n                taskInfo.getCriteria().getConditions().stream().filter(Objects::nonNull).forEach(criteria -> {\n                    if (criteria.getLeftOperand().getMeta().containsKey(IS_CURRENCY_FIELD)) {\n                        com.gainsight.services.dataprocessing.commons.pojo.fields.FieldInfo fieldInfoForCurrencyValue = new com.gainsight.services.dataprocessing.commons.pojo.fields.FieldInfo();\n                        fieldInfoForCurrencyValue.setDecimalPlaces(16);\n                        fieldInfoForCurrencyValue.setDataType(com.gainsight.services.dataprocessing.commons.pojo.DataType.NUMBER);\n                        fieldInfoForCurrencyValue.setName(criteria.getLeftOperand().getFieldName() + IPaasConstants.CURRENCY_FIELD);\n                        fieldInfoForCurrencyValue.setJsonPath(criteria.getLeftOperand().getFieldName() + IPaasConstants.CURRENCY_FIELD);\n                        fieldInfoForCurrencyValue.setFieldAlias(criteria.getLeftOperand().getFieldAlias() + IPaasConstants.CURRENCY_FIELD);\n                        fieldInfoForCurrencyValue.setFieldType(FieldType.FIELD);\n                        fetchTaskDetails.getProjections().add(fieldInfoForCurrencyValue);\n                    }\n                });\n            }\n            TaskResult taskResult = new TaskResult(fetchTaskDetails.getProjections(), null);\n\n            externalExtractionTaskResult = new ExternalExtractionTaskResult.ExternalExtractionTaskResultBuilder()\n                    .setTaskResult(taskResult)\n                    .setExtractedFiles(fileList.stream().map(file -> file.getAbsolutePath()).collect(Collectors.toList()))\n                    .setJsonData(true)\n                    .setJsonFileContentType(JsonFileContentType.LINE_SEPARATED_OBJECTS)\n                    .setPushExtractedDataToS3(fetchTaskDetails.isEnableDownloadSourceData())\n                    //.setPushExtractedDataToS3(true)\n                    .setExcludedStrings(ipaasExcludeString)\n                    .setIgnoreInvalidData(fetchTaskDetails.isIgnoreInvalidData())\n                    .build();\n            ExternalTaskUtil.saveExternalTaskResult(workflowJobDetails.getTenantId(), jobId, taskId, externalExtractionTaskResult);\n            LOGGER.info(\"Request to ipaas fetch completed in {} secs for tId- {}, jobId- {}, taskId- {}\",\n                    stopwatch.elapsed(TimeUnit.SECONDS), tenantId, jobId, taskId);\n        } catch (Exception ex) {\n            LOGGER.error(\"Exception while executing IpaasExtractiontask external.  tId- {}, jobId- {}, taskId- {}  with error - {}\",\n                    tenantId, jobId, taskId, ex);\n            if (CollectionUtils.isNotEmpty(fileList)) {\n                for (File file : fileList) {\n                    FileUtils.deleteQuietly(file);\n                }\n            }\n            if (ex instanceof ExternalTaskException)\n                throw new ExternalTaskException(((ExternalTaskException) ex).getHttpStatus(),\n                        ((ExternalTaskException) ex).getErrorCode(), ((ExternalTaskException) ex).getErrorMessage(), ex.getMessage());\n            else if (ex instanceof DPSystemException)\n                throw new ExternalTaskException(500, ExternalTasksValidationCode.DP_SYSTEM_EXCPETION,\n                        String.format(\"Failing with DP system exception due to : %s\", ex));\n            else\n                throw new ExternalTaskException(500, ExternalTasksValidationCode.GENERIC_ERROR,\n                        String.format(\"Failing with some exception due to : %s\", ex));\n        }\n    }\n"}
2025-05-13 20:59:51 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 20:59:51 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 20:59:51 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 20:59:51 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    private static void validateMappingsExistInExternalSystem(FieldInfo field, JsonObject objectMetaDataFromConnectors, Set<String> ipaasFields) {\n        JsonObject data;\n        data = objectMetaDataFromConnectors.get(DATA).getAsJsonObject();\n        JsonArray fields = data.get(\"fields\").getAsJsonArray();\n        Iterator<JsonElement> iterator = fields.iterator();\n        boolean found = false;\n        while (iterator.hasNext()) {\n            JsonObject fieldInfo = iterator.next().getAsJsonObject();\n            JsonObject meta = fieldInfo.get(\"meta\").getAsJsonObject();\n            if (meta.getAsJsonObject().get(\"path\").getAsString().equals(field.getPath())) {\n                found = true;\n                break;\n            }\n        }\n        if (!found) {\n            ipaasFields.add(field.getLabel());\n        }\n    }\n"}
2025-05-13 20:59:52 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 20:59:52 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 20:59:52 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 20:59:52 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    private static boolean isUpsertKeyChanged(IpaasStagingDetails ipaasStagingDetails, String newUpsertKey) {\n        boolean upsertKeyChanged = false;\n        if (CollectionUtils.isNotEmpty(ipaasStagingDetails.getFieldInfos()) && StringUtils.isNotEmpty(newUpsertKey)) {\n            Optional<IpaasStagingFieldInfo> ipaasStagingFieldInfo = ipaasStagingDetails.getFieldInfos().stream().filter(fieldInfo -> fieldInfo.isUpsertKey()).findFirst();\n            if (!ipaasStagingFieldInfo.isPresent() || !ipaasStagingFieldInfo.get().getFieldName().equalsIgnoreCase(newUpsertKey)) {\n                upsertKeyChanged = true;\n                LOGGER.info(\"new upsertKey selected. {}\", newUpsertKey);\n            }\n        }\n        return upsertKeyChanged;\n    }\n"}
2025-05-13 20:59:54 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 20:59:54 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 20:59:54 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 20:59:54 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    private static void setDateForHistoricSync(FilterRule rule, String lastModifieldFieldPath) {\n        if (CollectionUtils.isEmpty(rule.getRules())) {\n            if (rule.getFieldInfo().getJsonPath().equalsIgnoreCase(lastModifieldFieldPath) &&\n                    rule.getOp() == FilterOperator.GT) {\n                try {\n                    DateTimeFormatter sourceDateTimeFormatter = DateTimeFormatter.ofPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSSz\");\n                    ZonedDateTime zonedDateTime = ZonedDateTime.parse(\"1970-01-01T00:00:00.000+00:00\", sourceDateTimeFormatter.withZone(ZoneId.of(\"UTC\")));\n\n                    DateTimeFormatter targetDateTimeFormatter = StringUtils.isNotEmpty(rule.getFieldInfo().getDateTimeProperties().getFormat())\n                            ? DateTimeFormatter.ofPattern(rule.getFieldInfo().getDateTimeProperties().getFormat())\n                            : DateTimeFormatter.ISO_OFFSET_DATE_TIME;\n\n                    ZoneId zoneId = StringUtils.isNotBlank(rule.getFieldInfo().getDateTimeProperties().getTimeZoneId())\n                            ? ZoneId.of(rule.getFieldInfo().getDateTimeProperties().getTimeZoneId())\n                            : ZoneId.of(\"UTC\");\n\n                    rule.getValues().get(0).setValue(zonedDateTime.format(targetDateTimeFormatter.withZone(zoneId)));\n\n                } catch (Exception e) {\n                    LOGGER.info(\"Date Parse exception occurred while setting from date. {}\", e);\n                    throw new ExternalTaskException(500, ExternalTasksValidationCode.DATE_PARSE_EXCEPTION,\n                            String.format(\"Date Parse exception occurred while setting from date to January 01, 1970 due to %s\", e));\n                }\n            }\n        } else {\n            rule.getRules().forEach(innerRule -> setDateForHistoricSync(innerRule, lastModifieldFieldPath));\n        }\n    }\n"}
2025-05-13 20:59:55 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 20:59:55 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 20:59:55 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 20:59:55 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    private static com.gainsight.services.utilities.datahighway.dhquerybuilder.constructs.fields.FieldInfo getFieldInfoList(com.gainsight.services.dataprocessing.commons.pojo.fields.FieldInfo fetchTaskFieldInfo) {\n        com.gainsight.services.utilities.datahighway.dhquerybuilder.constructs.fields.FieldInfo fieldInfo = new com.gainsight.services.utilities.datahighway.dhquerybuilder.constructs.fields.FieldInfo();\n        fieldInfo.setName(fetchTaskFieldInfo.getName());\n        fieldInfo.setJsonPath(fetchTaskFieldInfo.getJsonPath());\n        fieldInfo.setFieldAlias(fetchTaskFieldInfo.getFieldAlias());\n        fieldInfo.setDecimalPlaces(fetchTaskFieldInfo.getDecimalPlaces());\n        if (null != fetchTaskFieldInfo.getDateTimeProperties()) {\n            DateTimeProperties dateTimeProperties = new DateTimeProperties();\n            dateTimeProperties.setFormat(fetchTaskFieldInfo.getDateTimeProperties().getFormat());\n            dateTimeProperties.setTimeZoneId(\"UTC\");\n            fieldInfo.setDateTimeProperties(dateTimeProperties);\n\n        }\n        fieldInfo.setDataType(com.gainsight.services.utilities.datahighway.dhcommons.enums.datatype.DataType.getDataType(fetchTaskFieldInfo.getDataType().getDataType()));\n        fieldInfo.setFieldType(com.gainsight.services.utilities.datahighway.dhquerybuilder.constructs.fields.FieldType.FIELD);\n        fieldInfo.setIsCurrencyField(fetchTaskFieldInfo.isIsCurrencyField());\n        return fieldInfo;\n    }\n"}
2025-05-13 20:59:56 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 20:59:56 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 20:59:56 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 20:59:56 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"public class IpaasExtractionTask {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(IpaasExtractionTask.class);\n    public static final String IPAAS_EXTRACT_DETAILS_KEY = \"ipaasExtractDetails\";\n    private static final String DATA = \"data\";\n    private static final String VALUE = \"value\";\n    private static final String IPAAS_INSTANCE_TOKEN = \"IPAAS_INSTANCE_TOKEN\";\n    private static final String IPAAS_ORG_TOKEN = \"IPAAS_ORG_TOKEN\";\n    private static final String IPAAS_USER_TOKEN = \"IPAAS_USER_TOKEN\";\n    private static final String IPAAS_EXCLUDE_STRING = \"uc.ipaas.external.task.excluded.string.list\";\n\n    public static void main(String[] args) {\n        executeTask(ExternalTaskUtil.getExternalTaskRequestContext());\n    }\n\n    private static void executeTask(ExternalTaskRequestContext externalTaskRequestContext) {\n        Stopwatch stopwatch = Stopwatch.createStarted();\n        ExternalExtractionTaskResult externalExtractionTaskResult = null;\n        String jobId = externalTaskRequestContext.getJobId();\n        String taskId = externalTaskRequestContext.getTaskId();\n        //Get workflowJobDetails of given jobId\n        DPWorkflowJobDetailsDTO workflowJobDetails = externalTaskRequestContext.getWorkflowJobDetails();\n        String tenantId = externalTaskRequestContext.getTenantId();\n        LOGGER.info(\"Request to ipaas extraction started !!  tId- {}, jobId- {}, taskId- {}\", tenantId, jobId, taskId);\n        LOGGER.info(\"checking : \", DeploymentProperties.getDeploymentProperties().getValue(MDA_GAINSIGHT_B2B_SECRET));\n        List<File> fileList = null;\n        try {\n            Map<String, String> metaData = externalTaskRequestContext.getMetaData();\n            AuditMetadata auditMetadata = newInstance(workflowJobDetails.getTenantId(), workflowJobDetails.getJobId(),\n                    workflowJobDetails.getExternalId(), taskId, externalTaskRequestContext.getTaskName());\n\n            IpaasExtractionDetails fetchTaskDetails = convertJsonToObject(metaData.get(IPAAS_EXTRACT_DETAILS_KEY), IpaasExtractionDetails.class);//todo remove from constants\n            LOGGER.info(\"MDA call out to fetch ipaas connection info for . connectionId : {}, tId- {}, jobId- {}, taskId- {}\",\n                    fetchTaskDetails.getConnectionId(), tenantId, jobId, taskId);\n            MDACalloutsService mdaCalloutsService = MDACalloutsService.createOrGetInstance(workflowJobDetails.getSystemToken(),\n                    TaskExecutorWorkflowUtils.getConfigSourceUrl(workflowJobDetails), auditMetadata);\n            String ipaasConnectionUrl = \"/connector/ipaas/connection/datahighway/\" + fetchTaskDetails.getConnectionId();\n            JsonObject jsonObject = mdaCalloutsService.getIpaasDetailsFromMDA(ipaasConnectionUrl, workflowJobDetails.getTenantId(), false);\n            isNotNull(jsonObject, GENERIC_SYSTEM_ERROR, \"No connection details found for this connection\");\n            LOGGER.info(\"Ipaas source connection details response :{}  for connectionId : {}, tId- {}, jobId- {}, taskId- {}\",\n                    jsonObject.get(\"result\").getAsBoolean(), fetchTaskDetails.getConnectionId(), tenantId, jobId, taskId);\n            if (!jsonObject.get(\"result\").getAsBoolean()) {\n                throw new ExternalTaskException(500, ExternalTasksValidationCode.IPAAS_CONNECTION_INFO_NOT_FOUND,\n                        String.format(\"Ipaas Connection info not found for id : %s\", fetchTaskDetails.getConnectionId()));\n            }\n            JsonObject data = jsonObject.get(DATA).getAsJsonObject();\n            if (data == null || data.isJsonNull())\n                throw new ExternalTaskException(500, ExternalTasksValidationCode.IPAAS_CONNECTION_INFO_NOT_FOUND,\n                        String.format(\"Ipaas Connection info is empty for id : %s\", fetchTaskDetails.getConnectionId()));\n            JsonObject decryptedObject = new JsonParser().parse(CryptUtil.decrypt(data.get(VALUE).getAsString())).getAsJsonObject();\n            Type type = new TypeToken<Map<String, Object>>() {\n            }.getType();\n            Map<String, Object> connectionDetailsMap = new Gson().fromJson(decryptedObject, type);\n            //extraction from ipaas\n            LOGGER.info(\"Fetching ipaas connection details ended. connectionId- {}, tId- {}, jobId- {}, taskId- {}\",\n                    fetchTaskDetails.getConnectionId(), tenantId, jobId, taskId);\n\n            //fetch dp staging details\n            if (fetchTaskDetails.getStagingConnectionInfo() != null) {\n                stagingDetailsProcessing(workflowJobDetails, tenantId, jobId, taskId, fetchTaskDetails, externalTaskRequestContext);\n            }\n\n            //fetch ipaas job & task details\n            LOGGER.info(\"MDA call out to fetch ipaas job and task details started. connectionId- {}, tId- {}, jobId- {}, taskId- {}\",\n                    fetchTaskDetails.getConnectionId(), tenantId, jobId, taskId);\n            String ipaasJobDetailsUrl = \"/connector/job/datahighway/\" + fetchTaskDetails.getJobId();\n            JsonObject obj = mdaCalloutsService.getIpaasDetailsFromMDA(ipaasJobDetailsUrl, workflowJobDetails.getTenantId(), false);\n\n            Type taskType = new TypeToken<List<TaskInfo>>() {\n            }.getType();\n            List<TaskInfo> taskInfos = new Gson().fromJson(obj.get(DATA).getAsJsonObject().get(\"taskInfo\"), taskType);\n\n            Map<String, String> ntzFields = Maps.newHashMap();\n            if (ConnectorType.SNOWFLAKE.equals(ConnectorType.getConnectorType(fetchTaskDetails.getConnectorType()))) {\n                List<TaskInfo> extractTaskInfos = taskInfos.stream().filter(taskInfo -> taskInfo.getTaskType().equals(TaskType.IPAAS_EXTRACT)).collect(Collectors.toList());\n                if (CollectionUtils.isNotEmpty(extractTaskInfos)) {\n                    extractTaskInfos.stream().forEach(taskInfo -> {\n                        if (CollectionUtils.isNotEmpty(taskInfo.getFieldInfoList())) {\n                            taskInfo.getFieldInfoList().stream().forEach(fieldInfo -> {\n                                        if (fieldInfo.getDataType().equals(\"date-time\") && fieldInfo.getMeta().containsKey(\"NTZ_ZONE_ID\")) {\n                                            ntzFields.put(fieldInfo.getPath(), fieldInfo.getMeta().get(\"NTZ_ZONE_ID\").toString());\n                                        }\n                                    }\n                            );\n                        }\n                    });\n                }\n            }\n\n            TaskInfo taskInfo = taskInfos.stream().filter(i -> i.getTaskId().equalsIgnoreCase(fetchTaskDetails.getTaskId()))\n                    .findFirst().get();\n            LOGGER.info(\"Fetched ipaas job and task details ended. connectionId- {}, tId- {}, jobId- {}, taskId- {}\",\n                    fetchTaskDetails.getConnectionId(), tenantId, jobId, taskId);\n            Map<String, List<PicklistOption>> picklistMap = Maps.newHashMap();\n\n\n            mdaCalloutsService = MDACalloutsService.createOrGetInstance(workflowJobDetails.getSystemToken(),\n                    TaskExecutorWorkflowUtils.getConfigSourceUrl(workflowJobDetails), auditMetadata);\n            StringBuilder objectMetaDataUrl = new StringBuilder(\"/connector/ipaas/metadata/datahighway/\")\n                    .append(taskInfo.getConnectionDetails().getConnectionId())\n                    .append(\"/\")\n                    .append(fetchTaskDetails.getExternalEntityName().trim().replaceAll(UCConstants.SPACE, \"%20\"))\n                    .append(\"/attributes\");\n            JsonObject objectMetaDataFromConnectors = mdaCalloutsService.getIpaasDetailsFromMDA(\n                    objectMetaDataUrl.toString(), workflowJobDetails.getTenantId(), false);\n            Set<String> ipaasFields = Sets.newHashSet();\n\n            for (FieldInfo field : taskInfo.getFieldInfoList()) {\n                validateMappingsExistInExternalSystem(field, objectMetaDataFromConnectors, ipaasFields);\n            }\n            if (null != taskInfo.getCriteria() && !taskInfo.getCriteria().getConditions().isEmpty()) {\n                for (Conditions condition : taskInfo.getCriteria().getConditions()) {\n                    if (!condition.isCustomizedFilterField())\n                        validateMappingsExistInExternalSystem(condition.getLeftOperand(), objectMetaDataFromConnectors, ipaasFields);\n                }\n            }\n\n            if (!ipaasFields.isEmpty()) {\n                if (!ConnectorType.FRESHDESK.equals(ConnectorType.getConnectorType(fetchTaskDetails.getConnectorType()))) {\n                    LOGGER.error(\"Exception while executing externalTask due to validation failure as fields are not present in external system tId- {}, jobId- {}, taskId- {}  with error - {}\",\n                            tenantId, jobId, taskId, ipaasFields);\n                    throw new ExternalTaskException(500, ExternalTasksValidationCode.FIELD_NOT_PRESENT_IN_SYSTEM,\n                            String.format(\"The job cannot be completed as the %s field was either deleted from the source or user is not authorised to access the field.Remove the field from connector mappings and re-run the job.\", ipaasFields));   // throw new DPSystemException(IpaasExtractionValidationCode.FIELD_NOT_PRESENT_IN_SYSTEM,String.format(\"Column %s does not exist. Possible causes: The column is deleted or the Integration/OAuth user does not have read permissions on the field.\", ipaasFields));\n                }else{\n                    LOGGER.warn(\"Not throwing exception for FRESHDESK connector, fields are missing {}\", ipaasFields);\n                }\n            }\n\n            if (fetchTaskDetails.isResolvePicklist()) {\n                boolean isPicklistFieldPresent = taskInfo.getFieldInfoList().stream().anyMatch(\n                        task -> (Boolean) task.getMeta().get(\"isPicklistField\"));\n                if (!isPicklistFieldPresent && taskInfo.getCriteria() != null && taskInfo.getCriteria().getConditions() != null && !taskInfo.getCriteria().getConditions().isEmpty()) {\n                    isPicklistFieldPresent = taskInfo.getCriteria().getConditions().stream().anyMatch(conditions -> conditions.getLeftOperand().getMeta().containsKey(\"isPicklistField\") && (Boolean) conditions.getLeftOperand().getMeta().get(\"isPicklistField\"));\n                }\n                if (isPicklistFieldPresent) {\n\n                    for (FieldInfo field : taskInfo.getFieldInfoList()) {\n                        populatePicklistMap(picklistMap, objectMetaDataFromConnectors, field);\n                    }\n                    if (null != taskInfo.getCriteria() && !taskInfo.getCriteria().getConditions().isEmpty()) {\n                        for (Conditions condition : taskInfo.getCriteria().getConditions()) {\n                            if (!condition.isCustomizedFilterField())\n                                populatePicklistMap(picklistMap, objectMetaDataFromConnectors, condition.getLeftOperand());\n                        }\n                    }\n                }\n            }\n            PaginatedDataExtractionService paginatedDataExtractionService = new PaginatedDataExtractionService();\n            List<com.gainsight.services.utilities.datahighway.dhquerybuilder.constructs.fields.FieldInfo> fieldInfoList = Lists.newArrayList();\n            fetchTaskDetails.getProjections().forEach(projection -> fieldInfoList.add(getFieldInfoList(projection)));\n            DataExtractionRequest dataExtractionRequest = new DataExtractionRequest();\n            dataExtractionRequest.setObjectName(fetchTaskDetails.getExternalEntityName());\n            dataExtractionRequest.setInstanceToken(SecretData.fromValue(connectionDetailsMap.get(IPAAS_INSTANCE_TOKEN).toString()));\n            dataExtractionRequest.setUserToken(SecretData.fromValue(connectionDetailsMap.get(IPAAS_USER_TOKEN).toString()));\n            dataExtractionRequest.setOrgToken(connectionDetailsMap.get(IPAAS_ORG_TOKEN).toString());\n            dataExtractionRequest.setJobId(workflowJobDetails.getJobId());\n            dataExtractionRequest.setConnectorType(ConnectorType.getConnectorType(fetchTaskDetails.getConnectorType()));\n            String ipaasExcludeString = DeploymentProperties.getDeploymentProperties().getValue(IPAAS_EXCLUDE_STRING);\n            if (StringUtils.isNotEmpty(ipaasExcludeString)) {\n                ipaasExcludeString = ipaasExcludeString.concat(\",\");\n            }\n            ipaasExcludeString = ipaasExcludeString.concat(\"\\u0000\");\n            List<String> excludedStringList = Arrays.asList(ipaasExcludeString.split(\",\"));\n            dataExtractionRequest.getProperties().put(\"ceTimeOut\", DeploymentProperties.getDeploymentProperties().getIntegerValue(\"ce.call.timeout.in.milli.secs\", 60000));\n            dataExtractionRequest.setExcludedStrings(excludedStringList);\n            LOGGER.info(\"Excluded Strings: {}\", dataExtractionRequest.getExcludedStrings());\n            dataExtractionRequest.setFilterRule(fetchTaskDetails.getWhereClause());\n            dataExtractionRequest.setFields(fieldInfoList);\n            if (DeploymentProperties.getDeploymentProperties().getBooleanValue(\"default.snowflake.enabled\", true)\n                    || DeploymentProperties.getDeploymentProperties().getValue(\"snowflake.tenant.list\").contains(RequestContextProvider.getTenantId())) {\n                dataExtractionRequest.getProperties().put(\"isJdbcSnowflakeRequired\", true);\n            } else {\n                dataExtractionRequest.getProperties().put(\"isJdbcSnowflakeRequired\", false);\n            }\n            dataExtractionRequest.getProperties().put(\"snowflakeFileSize\", DeploymentProperties.getDeploymentProperties().getLongValue(\"snowflake.file.size\", 200000000));\n            dataExtractionRequest.getProperties().put(\"snowflakeBatchLimit\", DeploymentProperties.getDeploymentProperties().getIntegerValue(\"snowflake.batch.limit\", 10000));\n            dataExtractionRequest.setCloudElementsBaseUrl(connectionDetailsMap.get(\"baseUrl\").toString());\n            dataExtractionRequest.setDateTimeConversionRequired(Boolean.parseBoolean(connectionDetailsMap.get(\"isDateTimeConversionRequired\").toString()));\n            dataExtractionRequest.getProperties().put(PAGE_SIZE, fetchTaskDetails.getPageSize());\n            dataExtractionRequest.getProperties().put(\"skipFieldsAsQueryParam\", fetchTaskDetails.isSkipFieldsForFetch());\n            dataExtractionRequest.setLastModifiedFieldName(fetchTaskDetails.getLastModifieldFieldPath());\n            dataExtractionRequest.setLastModifiedFieldValue(fetchTaskDetails.getLastModifieldFieldValue());\n            dataExtractionRequest.setHonourLastModfiedFieldValueToFetchDeltaData(fetchTaskDetails.isHonourLastModfiedFieldValueToFetchDeltaData());\n            dataExtractionRequest.setIgnorableErrorMessages(fetchTaskDetails.getIgnorableErrorMessages());\n            dataExtractionRequest.setQueryParamForDataFetch(fetchTaskDetails.getQueryParamForDataFetch());\n            dataExtractionRequest.setPicklistOptionMap(picklistMap);\n            dataExtractionRequest.getProperties().putAll(connectionDetailsMap);\n            taskInfo.getFieldInfoList().stream().filter(fieldInfo -> fieldInfo.getMeta().containsKey(\"isPrimaryKey\") && (Boolean) fieldInfo.getMeta().get(\"isPrimaryKey\")).findFirst().ifPresent(fieldInfo -> dataExtractionRequest.setPrimaryField(fieldInfo.getPath()));\n\n\n            if (null != fetchTaskDetails.getOrderByInfo() && !fetchTaskDetails.getOrderByInfo().getOrderByFields().isEmpty()) {\n                if (fetchTaskDetails.getOrderByInfo().isAscending()) {\n                    dataExtractionRequest.setOrderByInfoField(fetchTaskDetails.getOrderByInfo().getOrderByFields().get(0).getJsonPath() + URLEncoder.encode(\" \" + \"asc\", \"UTF-8\"));\n                } else {\n                    dataExtractionRequest.setOrderByInfoField(fetchTaskDetails.getOrderByInfo().getOrderByFields().get(0).getJsonPath() + URLEncoder.encode(\" \" + \"desc\", \"UTF-8\"));\n                }\n            }\n            dataExtractionRequest.setDefaultSleepTimeOnFail(fetchTaskDetails.getDefaultSleepTimeOnFail());\n            dataExtractionRequest.setMaxNoOfRetries(fetchTaskDetails.getMaxNumberOfRetries());\n            if (!ntzFields.isEmpty()) {\n                dataExtractionRequest.getProperties().put(\"NTZ_FIELDS\", ntzFields);\n            }\n\n            if (MapUtils.isNotEmpty(fetchTaskDetails.getAdditionalInformation())) {\n\n                dataExtractionRequest.getProperties().putAll(fetchTaskDetails.getAdditionalInformation());\n            }\n            if (StringUtils.isNotEmpty(fetchTaskDetails.getQuery())) {\n                dataExtractionRequest.getProperties().put(\"CUSTOM_QUERY\", fetchTaskDetails.getQuery());\n            }\n\n            fileList = paginatedDataExtractionService.extractData(dataExtractionRequest);\n            LOGGER.info(\"Ipaas Extraction started, tId- {}, jobId- {}, taskId- {}\", tenantId, jobId, taskId);\n\n\n            if (null != taskInfo.getCriteria()) {\n                taskInfo.getCriteria().getConditions().stream().filter(Objects::nonNull).forEach(criteria -> {\n                    if (criteria.getLeftOperand().getMeta().containsKey(IS_CURRENCY_FIELD)) {\n                        com.gainsight.services.dataprocessing.commons.pojo.fields.FieldInfo fieldInfoForCurrencyValue = new com.gainsight.services.dataprocessing.commons.pojo.fields.FieldInfo();\n                        fieldInfoForCurrencyValue.setDecimalPlaces(16);\n                        fieldInfoForCurrencyValue.setDataType(com.gainsight.services.dataprocessing.commons.pojo.DataType.NUMBER);\n                        fieldInfoForCurrencyValue.setName(criteria.getLeftOperand().getFieldName() + IPaasConstants.CURRENCY_FIELD);\n                        fieldInfoForCurrencyValue.setJsonPath(criteria.getLeftOperand().getFieldName() + IPaasConstants.CURRENCY_FIELD);\n                        fieldInfoForCurrencyValue.setFieldAlias(criteria.getLeftOperand().getFieldAlias() + IPaasConstants.CURRENCY_FIELD);\n                        fieldInfoForCurrencyValue.setFieldType(FieldType.FIELD);\n                        fetchTaskDetails.getProjections().add(fieldInfoForCurrencyValue);\n                    }\n                });\n            }\n            TaskResult taskResult = new TaskResult(fetchTaskDetails.getProjections(), null);\n\n            externalExtractionTaskResult = new ExternalExtractionTaskResult.ExternalExtractionTaskResultBuilder()\n                    .setTaskResult(taskResult)\n                    .setExtractedFiles(fileList.stream().map(file -> file.getAbsolutePath()).collect(Collectors.toList()))\n                    .setJsonData(true)\n                    .setJsonFileContentType(JsonFileContentType.LINE_SEPARATED_OBJECTS)\n                    .setPushExtractedDataToS3(fetchTaskDetails.isEnableDownloadSourceData())\n                    //.setPushExtractedDataToS3(true)\n                    .setExcludedStrings(ipaasExcludeString)\n                    .setIgnoreInvalidData(fetchTaskDetails.isIgnoreInvalidData())\n                    .build();\n            ExternalTaskUtil.saveExternalTaskResult(workflowJobDetails.getTenantId(), jobId, taskId, externalExtractionTaskResult);\n            LOGGER.info(\"Request to ipaas fetch completed in {} secs for tId- {}, jobId- {}, taskId- {}\",\n                    stopwatch.elapsed(TimeUnit.SECONDS), tenantId, jobId, taskId);\n        } catch (Exception ex) {\n            LOGGER.error(\"Exception while executing IpaasExtractiontask external.  tId- {}, jobId- {}, taskId- {}  with error - {}\",\n                    tenantId, jobId, taskId, ex);\n            if (CollectionUtils.isNotEmpty(fileList)) {\n                for (File file : fileList) {\n                    FileUtils.deleteQuietly(file);\n                }\n            }\n            if (ex instanceof ExternalTaskException)\n                throw new ExternalTaskException(((ExternalTaskException) ex).getHttpStatus(),\n                        ((ExternalTaskException) ex).getErrorCode(), ((ExternalTaskException) ex).getErrorMessage(), ex.getMessage());\n            else if (ex instanceof DPSystemException)\n                throw new ExternalTaskException(500, ExternalTasksValidationCode.DP_SYSTEM_EXCPETION,\n                        String.format(\"Failing with DP system exception due to : %s\", ex));\n            else\n                throw new ExternalTaskException(500, ExternalTasksValidationCode.GENERIC_ERROR,\n                        String.format(\"Failing with some exception due to : %s\", ex));\n        }\n    }\n\n    private static void validateMappingsExistInExternalSystem(FieldInfo field, JsonObject objectMetaDataFromConnectors, Set<String> ipaasFields) {\n        JsonObject data;\n        data = objectMetaDataFromConnectors.get(DATA).getAsJsonObject();\n        JsonArray fields = data.get(\"fields\").getAsJsonArray();\n        Iterator<JsonElement> iterator = fields.iterator();\n        boolean found = false;\n        while (iterator.hasNext()) {\n            JsonObject fieldInfo = iterator.next().getAsJsonObject();\n            JsonObject meta = fieldInfo.get(\"meta\").getAsJsonObject();\n            if (meta.getAsJsonObject().get(\"path\").getAsString().equals(field.getPath())) {\n                found = true;\n                break;\n            }\n        }\n        if (!found) {\n            ipaasFields.add(field.getLabel());\n        }\n    }\n\n    private static void populatePicklistMap(Map<String, List<PicklistOption>> picklistMap,\n                                            JsonObject objectMetaDataFromConnectors, FieldInfo field) {\n        JsonObject data;\n\n        if (field.getMeta().containsKey(\"isPicklistField\") && (Boolean) field.getMeta().get(\"isPicklistField\")) {\n            data = objectMetaDataFromConnectors.get(DATA).getAsJsonObject();\n            JsonArray fields = data.get(\"fields\").getAsJsonArray();\n            Iterator<JsonElement> iterator = fields.iterator();\n            List<PicklistOption> picklistList = Lists.newArrayList();\n            while (iterator.hasNext()) {\n                JsonObject fieldInfo = iterator.next().getAsJsonObject();\n                JsonObject meta = fieldInfo.get(\"meta\").getAsJsonObject();\n                if (meta.getAsJsonObject().get(\"path\").getAsString().equals(field.getPath()) &&\n                        meta.getAsJsonObject().get(\"isPicklistField\").getAsBoolean()) {\n                    JsonArray options = fieldInfo.get(\"options\").getAsJsonArray();\n                    options.forEach(option -> {\n                        PicklistOption picklistOption = new PicklistOption();\n                        picklistOption.setPicklistLabel(option.getAsJsonObject().get(\"label\").getAsString());\n                        picklistOption.setPicklistValue(option.getAsJsonObject().get(\"value\").getAsString());\n                        picklistList.add(picklistOption);\n                    });\n                }\n            }\n            picklistMap.put(field.getPath(), picklistList);\n        }\n        LOGGER.info(\"Populated picklist map with {}\", picklistMap);\n    }\n\n    private static void stagingDetailsProcessing(DPWorkflowJobDetailsDTO workflowJobDetails, String tenantId, String jobId,\n                                                 String taskId, IpaasExtractionDetails fetchTaskDetails,\n                                                 ExternalTaskRequestContext externalTaskRequestContext) throws Exception {\n        String configSourceUrl = ExternalTaskUtil.getConfigSourceUrl(workflowJobDetails);\n        String gsB2BSecret = DeploymentProperties.getDeploymentProperties().getValue(MDA_GAINSIGHT_B2B_SECRET);\n        LOGGER.info(\"MDA call out to fetch ipaas staging postgres details started uc connectionId- {}, tId- {}, jobId- {}, taskId- {}\",\n                fetchTaskDetails.getStagingConnectionInfo().getConnectionId(), tenantId, jobId, taskId);\n        MDACalloutsService mdaCalloutsService = new MDACalloutsServiceImpl(gsB2BSecret, configSourceUrl);\n        PNPConnectionInput pnpConnectionInput = mdaCalloutsService.getConnectionDetails(\n                fetchTaskDetails.getStagingConnectionInfo().getConnectionId(), externalTaskRequestContext.getTenantId());\n\n        PNPConnectionsInfo pnpConnectionsInfo = pnpConnectionInput.getPnpConnectionsInfo();\n        RelationalDBConnectionDetail relationalDBConnectionDetail =\n                (RelationalDBConnectionDetail) pnpConnectionsInfo.getConnectionDetail();\n        LOGGER.info(\"Fetching ipaas staging postgres details ended. connectionId- {}, tId- {}, jobId- {}, taskId- {}\",\n                fetchTaskDetails.getStagingConnectionInfo().getConnectionId(), tenantId, jobId, taskId);\n        StringBuilder url = new StringBuilder();\n        url.append(CryptUtil.decrypt(relationalDBConnectionDetail.getHost())).append(\":\")\n                .append(CryptUtil.decrypt(relationalDBConnectionDetail.getPort()));\n        DatabaseConnectionRequest databaseConnectionRequest = new DatabaseConnectionRequest(\n                url.toString(),\n                CryptUtil.decrypt(relationalDBConnectionDetail.getDataBaseName()),\n                CryptUtil.decrypt(relationalDBConnectionDetail.getUser()),\n                CryptUtil.decrypt(relationalDBConnectionDetail.getPwd()),\n                Integer.parseInt(String.valueOf(pnpConnectionsInfo.getProperties().get(\"minIdle\"))),\n                Integer.parseInt(String.valueOf(pnpConnectionsInfo.getProperties().get(\"maxIdle\"))),\n                Integer.parseInt(String.valueOf(pnpConnectionsInfo.getProperties().get(\"initialSize\"))));\n        databaseConnectionRequest.setSslEnabled(relationalDBConnectionDetail.isSslEnabled());\n        BasicDataSource dataSource = DatabaseConnectionPoolUtility.getOrCreateConnection(databaseConnectionRequest);\n        IpaasStagingDetailsDao ipaasStagingDetailsDao = new IpaasStagingDetailsDaoImpl(dataSource);\n        LOGGER.info(\"fetching staging details.  tId- {}, jobId- {}, taskId- {}\", tenantId, jobId, taskId);\n        IpaasStagingDetails ipaasStagingDetails = ipaasStagingDetailsDao.findStagingDetails(workflowJobDetails.getTenantId(),\n                fetchTaskDetails.getTaskId(), fetchTaskDetails.getJobId());\n        LOGGER.info(\"Showing ipaas staging details. tId- {}, jobId- {}, taskId- {}, Ipaas staging details  : {}\",\n                tenantId, jobId, taskId, ipaasStagingDetails);\n\n        //checking and updating field Infos & columns\n        if (ipaasStagingDetails != null && (!ipaasStagingDetails.isInSync() || !checkSyncStatusForStagingDetails(ipaasStagingDetails, fetchTaskDetails.getProjections())\n                || isUpsertKeyChanged(ipaasStagingDetails, fetchTaskDetails.getUpsertkey()))) {\n            LOGGER.info(\"full sync required . Hence changing from date in filter for jobId:{}, taskId:{}, tenantId:{}. \",\n                    jobId, taskId, workflowJobDetails.getTenantId());\n            fetchTaskDetails.setLastModifieldFieldValue(0);\n            //setting from date as 1970-01-01T00:00:00.000Z for fetching historical data\n            if (fetchTaskDetails.getWhereClause() != null && !fetchTaskDetails.getWhereClause().getRules().isEmpty() &&\n                    StringUtils.isNotEmpty(fetchTaskDetails.getLastModifieldFieldPath())) {\n                setDateForHistoricSync(fetchTaskDetails.getWhereClause(), fetchTaskDetails.getLastModifieldFieldPath());\n                ipaasStagingDetailsDao.updateInSyncByJobIdAndTaskId(ipaasStagingDetails);\n            }\n        }\n    }\n\n    private static boolean isUpsertKeyChanged(IpaasStagingDetails ipaasStagingDetails, String newUpsertKey) {\n        boolean upsertKeyChanged = false;\n        if (CollectionUtils.isNotEmpty(ipaasStagingDetails.getFieldInfos()) && StringUtils.isNotEmpty(newUpsertKey)) {\n            Optional<IpaasStagingFieldInfo> ipaasStagingFieldInfo = ipaasStagingDetails.getFieldInfos().stream().filter(fieldInfo -> fieldInfo.isUpsertKey()).findFirst();\n            if (!ipaasStagingFieldInfo.isPresent() || !ipaasStagingFieldInfo.get().getFieldName().equalsIgnoreCase(newUpsertKey)) {\n                upsertKeyChanged = true;\n                LOGGER.info(\"new upsertKey selected. {}\", newUpsertKey);\n            }\n        }\n        return upsertKeyChanged;\n    }\n\n    private static void setDateForHistoricSync(FilterRule rule, String lastModifieldFieldPath) {\n        if (CollectionUtils.isEmpty(rule.getRules())) {\n            if (rule.getFieldInfo().getJsonPath().equalsIgnoreCase(lastModifieldFieldPath) &&\n                    rule.getOp() == FilterOperator.GT) {\n                try {\n                    DateTimeFormatter sourceDateTimeFormatter = DateTimeFormatter.ofPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSSz\");\n                    ZonedDateTime zonedDateTime = ZonedDateTime.parse(\"1970-01-01T00:00:00.000+00:00\", sourceDateTimeFormatter.withZone(ZoneId.of(\"UTC\")));\n\n                    DateTimeFormatter targetDateTimeFormatter = StringUtils.isNotEmpty(rule.getFieldInfo().getDateTimeProperties().getFormat())\n                            ? DateTimeFormatter.ofPattern(rule.getFieldInfo().getDateTimeProperties().getFormat())\n                            : DateTimeFormatter.ISO_OFFSET_DATE_TIME;\n\n                    ZoneId zoneId = StringUtils.isNotBlank(rule.getFieldInfo().getDateTimeProperties().getTimeZoneId())\n                            ? ZoneId.of(rule.getFieldInfo().getDateTimeProperties().getTimeZoneId())\n                            : ZoneId.of(\"UTC\");\n\n                    rule.getValues().get(0).setValue(zonedDateTime.format(targetDateTimeFormatter.withZone(zoneId)));\n\n                } catch (Exception e) {\n                    LOGGER.info(\"Date Parse exception occurred while setting from date. {}\", e);\n                    throw new ExternalTaskException(500, ExternalTasksValidationCode.DATE_PARSE_EXCEPTION,\n                            String.format(\"Date Parse exception occurred while setting from date to January 01, 1970 due to %s\", e));\n                }\n            }\n        } else {\n            rule.getRules().forEach(innerRule -> setDateForHistoricSync(innerRule, lastModifieldFieldPath));\n        }\n    }\n\n    private static com.gainsight.services.utilities.datahighway.dhquerybuilder.constructs.fields.FieldInfo getFieldInfoList(com.gainsight.services.dataprocessing.commons.pojo.fields.FieldInfo fetchTaskFieldInfo) {\n        com.gainsight.services.utilities.datahighway.dhquerybuilder.constructs.fields.FieldInfo fieldInfo = new com.gainsight.services.utilities.datahighway.dhquerybuilder.constructs.fields.FieldInfo();\n        fieldInfo.setName(fetchTaskFieldInfo.getName());\n        fieldInfo.setJsonPath(fetchTaskFieldInfo.getJsonPath());\n        fieldInfo.setFieldAlias(fetchTaskFieldInfo.getFieldAlias());\n        fieldInfo.setDecimalPlaces(fetchTaskFieldInfo.getDecimalPlaces());\n        if (null != fetchTaskFieldInfo.getDateTimeProperties()) {\n            DateTimeProperties dateTimeProperties = new DateTimeProperties();\n            dateTimeProperties.setFormat(fetchTaskFieldInfo.getDateTimeProperties().getFormat());\n            dateTimeProperties.setTimeZoneId(\"UTC\");\n            fieldInfo.setDateTimeProperties(dateTimeProperties);\n\n        }\n        fieldInfo.setDataType(com.gainsight.services.utilities.datahighway.dhcommons.enums.datatype.DataType.getDataType(fetchTaskFieldInfo.getDataType().getDataType()));\n        fieldInfo.setFieldType(com.gainsight.services.utilities.datahighway.dhquerybuilder.constructs.fields.FieldType.FIELD);\n        fieldInfo.setIsCurrencyField(fetchTaskFieldInfo.isIsCurrencyField());\n        return fieldInfo;\n    }\n\n    private static boolean checkSyncStatusForStagingDetails(IpaasStagingDetails ipaasStagingDetails,\n                                                            List<com.gainsight.services.dataprocessing.commons.pojo.fields.FieldInfo> ipaasFetchDetails) {\n        Set<String> sourceFieldNames = ipaasFetchDetails\n                .stream().map(i -> i.getFieldAlias())\n                .collect(Collectors.toSet());\n\n        List<String> existingFieldNames = ipaasStagingDetails.getFieldInfos()\n                .stream().map(i -> i.getFieldName())\n                .collect(Collectors.toList());\n\n        return existingFieldNames.size() == sourceFieldNames.size() && existingFieldNames.containsAll(sourceFieldNames);\n    }\n}\n"}
2025-05-13 20:59:58 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 20:59:58 [main] INFO  c.l.service.impl.BasicL3AgentService - Processed file: /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/code/dp_dynamic_tasks/ipaas-extraction-task/src/main/java/com/gainsight/services/external/ipaas/extraction/task/IpaasExtractionTask.java with 8 chunks
2025-05-13 20:59:58 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 20:59:58 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 20:59:58 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"package com.gainsight.services.external.ipaas.extraction.task;\n\nimport com.fasterxml.jackson.annotation.JsonIgnoreProperties;\nimport com.gainsight.services.dataprocessing.commons.pojo.fields.FieldInfo;\nimport com.gainsight.services.utilities.datahighway.dhcommons.pojo.base.connection.ConnectionInfo;\nimport com.gainsight.services.utilities.datahighway.dhquerybuilder.constructs.filters.FilterRule;\nimport com.gainsight.services.utilities.datahighway.dhquerybuilder.constructs.query.OrderByInfo;\nimport com.google.common.collect.Lists;\n\nimport java.util.List;\nimport java.util.Map;\n\n\n/**\n * @author Manas Ranjan Sur (msur@gainsight.com)\n * created on 20-APR-2020\n * External Task for extracting records from ipaas\n */\n@JsonIgnoreProperties(ignoreUnknown = true)\npublic class IpaasExtractionDetails {\n\n    private static final long serialVersionUID = -11278538782L;\n\n    private String connectionId;\n    private String externalEntityName;\n    private List<FieldInfo> projections;\n    private FilterRule whereClause;\n    private OrderByInfo orderByInfo;\n    private String query;\n    private String connectorType;\n    private String ucId;\n    private String ipaasStagingDetailsId;\n    private String jobId;\n    private String taskId;\n    private ConnectionInfo stagingConnectionInfo;\n    private String lastModifieldFieldPath;\n    private boolean resolvePicklist;\n    private String upsertkey;\n    private Object lastModifieldFieldValue;\n    private boolean honourLastModfiedFieldValueToFetchDeltaData;\n    private int defaultSleepTimeOnFail;\n    private String pageSize;\n    private boolean enableDownloadSourceData;\n    private int maxNumberOfRetries;\n    private boolean ignoreInvalidData;\n    private List<String> ignorableErrorMessages= Lists.newArrayList();\n    private String queryParamForDataFetch;\n    private boolean skipFieldsForFetch;\n\n    private Map<String, Object> additionalInformation;\n    public Map<String, Object> getAdditionalInformation() {\n        return additionalInformation;\n    }\n\n    public void setAdditionalInformation(Map<String, Object> additionalInformation) {\n        this.additionalInformation = additionalInformation;\n    }\n\n    public boolean isSkipFieldsForFetch() {\n        return skipFieldsForFetch;\n    }\n\n    public void setSkipFieldsForFetch(boolean skipFieldsForFetch) {\n        this.skipFieldsForFetch = skipFieldsForFetch;\n    }\n    public String getQueryParamForDataFetch() {\n        return queryParamForDataFetch;\n    }\n\n    public void setQueryParamForDataFetch(String queryParamForDataFetch) {\n        this.queryParamForDataFetch = queryParamForDataFetch;\n    }\n    public int getMaxNumberOfRetries() {\n        return maxNumberOfRetries;\n    }\n\n    public void setMaxNumberOfRetries(int maxNumberOfRetries) {\n        this.maxNumberOfRetries = maxNumberOfRetries;\n    }\n    public String getPageSize() {\n        return pageSize;\n    }\n\n    public void setPageSize(String pageSize) {\n        this.pageSize = pageSize;\n    }\n    public int getDefaultSleepTimeOnFail() {\n        return defaultSleepTimeOnFail;\n    }\n\n    public void setDefaultSleepTimeOnFail(int defaultSleepTimeOnFail) {\n        this.defaultSleepTimeOnFail = defaultSleepTimeOnFail;\n    }\n\n    public boolean isHonourLastModfiedFieldValueToFetchDeltaData() {\n        return honourLastModfiedFieldValueToFetchDeltaData;\n    }\n\n    public void setHonourLastModfiedFieldValueToFetchDeltaData(boolean honourLastModfiedFieldValueToFetchDeltaData) {\n        this.honourLastModfiedFieldValueToFetchDeltaData = honourLastModfiedFieldValueToFetchDeltaData;\n    }\n\n    public String getConnectionId() {\n        return connectionId;\n    }\n\n    public void setConnectionId(String connectionId) {\n        this.connectionId = connectionId;\n    }\n\n    public String getExternalEntityName() {\n        return externalEntityName;\n    }\n\n    public void setExternalEntityName(String externalEntityName) {\n        this.externalEntityName = externalEntityName;\n    }\n\n    public List<FieldInfo> getProjections() {\n        return projections;\n    }\n\n    public void setProjections(List<FieldInfo> projections) {\n        this.projections = projections;\n    }\n\n    public FilterRule getWhereClause() {\n        return whereClause;\n    }\n\n    public void setWhereClause(FilterRule whereClause) {\n        this.whereClause = whereClause;\n    }\n\n    public String getQuery() {\n        return query;\n    }\n\n    public void setQuery(String query) {\n        this.query = query;\n    }\n\n    public String getConnectorType() {\n        return connectorType;\n    }\n\n    public void setConnectorType(String connectorType) {\n        this.connectorType = connectorType;\n    }\n\n    public String getUcId() {\n        return ucId;\n    }\n\n    public void setUcId(String ucId) {\n        this.ucId = ucId;\n    }\n\n    public String getJobId() {\n        return jobId;\n    }\n\n    public void setJobId(String jobId) {\n        this.jobId = jobId;\n    }\n\n    public String getTaskId() {\n        return taskId;\n    }\n\n    public void setTaskId(String taskId) {\n        this.taskId = taskId;\n    }\n\n    public String getIpaasStagingDetailsId() {\n        return ipaasStagingDetailsId;\n    }\n\n    public void setIpaasStagingDetailsId(String ipaasStagingDetailsId) {\n        this.ipaasStagingDetailsId = ipaasStagingDetailsId;\n    }\n\n    public ConnectionInfo getStagingConnectionInfo() {\n        return stagingConnectionInfo;\n    }\n\n    public void setStagingConnectionInfo(ConnectionInfo stagingConnectionInfo) {\n        this.stagingConnectionInfo = stagingConnectionInfo;\n    }\n\n    public String getLastModifieldFieldPath() {\n        return lastModifieldFieldPath;\n    }\n\n    public void setLastModifieldFieldPath(String lastModifieldFieldPath) {\n        this.lastModifieldFieldPath = lastModifieldFieldPath;\n    }\n\n    public boolean isResolvePicklist() {\n        return resolvePicklist;\n    }\n\n    public OrderByInfo getOrderByInfo() {\n        return orderByInfo;\n    }\n\n    public void setOrderByInfo(OrderByInfo orderByInfo) {\n        this.orderByInfo = orderByInfo;\n    }\n\n    public void setResolvePicklist(boolean resolvePicklist) {\n        this.resolvePicklist = resolvePicklist;\n    }\n\n    public String getUpsertkey() {\n        return upsertkey;\n    }\n\n    public void setUpsertkey(String upsertkey) {\n        this.upsertkey = upsertkey;\n    }\n    public Object getLastModifieldFieldValue() {\n        return lastModifieldFieldValue;\n    }\n\n    public void setLastModifieldFieldValue(Object lastModifieldFieldValue) {\n        this.lastModifieldFieldValue = lastModifieldFieldValue;\n    }\n\n    public boolean isEnableDownloadSourceData() {\n        return enableDownloadSourceData;\n    }\n\n    public void setEnableDownloadSourceData(boolean enableDownloadSourceData) {\n        this.enableDownloadSourceData = enableDownloadSourceData;\n    }\n\n    public boolean isIgnoreInvalidData() {\n        return ignoreInvalidData;\n    }\n\n    public void setIgnoreInvalidData(boolean ignoreInvalidData) {\n        this.ignoreInvalidData = ignoreInvalidData;\n    }\n\n    @Override\n    public String toString() {\n        return \"IpaasExtractionDetails{\" +\n                \"connectionId='\" + connectionId + '\\'' +\n                \", externalEntityName='\" + externalEntityName + '\\'' +\n                \", projections=\" + projections +\n                \", whereClause=\" + whereClause +\n                \", orderByInfo=\" + orderByInfo +\n                \", query='\" + query + '\\'' +\n                \", connectorType='\" + connectorType + '\\'' +\n                \", ucId='\" + ucId + '\\'' +\n                \", ipaasStagingDetailsId='\" + ipaasStagingDetailsId + '\\'' +\n                \", jobId='\" + jobId + '\\'' +\n                \", taskId='\" + taskId + '\\'' +\n                \", stagingConnectionInfo=\" + stagingConnectionInfo +\n                \", lastModifieldFieldPath='\" + lastModifieldFieldPath + '\\'' +\n                \", resolvePicklist=\" + resolvePicklist +\n                \", upsertkey='\" + upsertkey + '\\'' +\n                \", lastModifieldFieldValue=\" + lastModifieldFieldValue +\n                \", honourLastModfiedFieldValueToFetchDeltaData=\" + honourLastModfiedFieldValueToFetchDeltaData +\n                \", defaultSleepTimeOnFail=\" + defaultSleepTimeOnFail +\n                \", pageSize='\" + pageSize + '\\'' +\n                \", enableDownloadSourceData=\" + enableDownloadSourceData +\n                \", maxNumberOfRetries=\" + maxNumberOfRetries +\n                \", ignoreInvalidData=\" + ignoreInvalidData +\n                \", ignorableErrorMessages=\" + ignorableErrorMessages +\n                \", queryParamForDataFetch=\" + queryParamForDataFetch +\n                '}';\n    }\n\n    public List<String> getIgnorableErrorMessages() {\n        return ignorableErrorMessages;\n    }\n\n    public void setIgnorableErrorMessages(List<String> ignorableErrorMessages) {\n        this.ignorableErrorMessages = ignorableErrorMessages;\n    }\n}"}
2025-05-13 21:00:00 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:00:00 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:00:00 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:00:00 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    public Map<String, Object> getAdditionalInformation() {\n        return additionalInformation;\n    }\n"}
2025-05-13 21:00:01 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:00:01 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:00:01 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:00:01 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    public void setAdditionalInformation(Map<String, Object> additionalInformation) {\n        this.additionalInformation = additionalInformation;\n    }\n"}
2025-05-13 21:00:03 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:00:03 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:00:03 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:00:03 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    public boolean isSkipFieldsForFetch() {\n        return skipFieldsForFetch;\n    }\n"}
2025-05-13 21:00:05 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:00:05 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:00:05 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:00:05 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    public void setSkipFieldsForFetch(boolean skipFieldsForFetch) {\n        this.skipFieldsForFetch = skipFieldsForFetch;\n    }\n"}
2025-05-13 21:00:06 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:00:06 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:00:06 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:00:06 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    public String getQueryParamForDataFetch() {\n        return queryParamForDataFetch;\n    }\n"}
2025-05-13 21:00:08 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:00:08 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:00:08 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:00:08 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    public void setQueryParamForDataFetch(String queryParamForDataFetch) {\n        this.queryParamForDataFetch = queryParamForDataFetch;\n    }\n"}
2025-05-13 21:00:09 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:00:09 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:00:09 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:00:09 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    public int getMaxNumberOfRetries() {\n        return maxNumberOfRetries;\n    }\n"}
2025-05-13 21:00:11 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:00:11 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:00:11 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:00:11 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    public void setMaxNumberOfRetries(int maxNumberOfRetries) {\n        this.maxNumberOfRetries = maxNumberOfRetries;\n    }\n"}
2025-05-13 21:00:12 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:00:12 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:00:12 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:00:12 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    public String getPageSize() {\n        return pageSize;\n    }\n"}
2025-05-13 21:00:13 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:00:13 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:00:13 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:00:13 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    public void setPageSize(String pageSize) {\n        this.pageSize = pageSize;\n    }\n"}
2025-05-13 21:00:15 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:00:15 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:00:15 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:00:15 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    public int getDefaultSleepTimeOnFail() {\n        return defaultSleepTimeOnFail;\n    }\n"}
2025-05-13 21:00:16 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:00:16 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:00:16 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:00:16 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    public void setDefaultSleepTimeOnFail(int defaultSleepTimeOnFail) {\n        this.defaultSleepTimeOnFail = defaultSleepTimeOnFail;\n    }\n"}
2025-05-13 21:00:18 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:00:18 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:00:18 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:00:18 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    public boolean isHonourLastModfiedFieldValueToFetchDeltaData() {\n        return honourLastModfiedFieldValueToFetchDeltaData;\n    }\n"}
2025-05-13 21:00:19 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:00:19 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:00:19 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:00:19 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    public void setHonourLastModfiedFieldValueToFetchDeltaData(boolean honourLastModfiedFieldValueToFetchDeltaData) {\n        this.honourLastModfiedFieldValueToFetchDeltaData = honourLastModfiedFieldValueToFetchDeltaData;\n    }\n"}
2025-05-13 21:00:21 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:00:21 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:00:21 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:00:21 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    public String getConnectionId() {\n        return connectionId;\n    }\n"}
2025-05-13 21:00:22 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:00:22 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:00:22 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:00:22 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    public void setConnectionId(String connectionId) {\n        this.connectionId = connectionId;\n    }\n"}
2025-05-13 21:00:23 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:00:24 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:00:24 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:00:24 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    public String getExternalEntityName() {\n        return externalEntityName;\n    }\n"}
2025-05-13 21:00:25 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:00:25 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:00:25 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:00:25 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    public void setExternalEntityName(String externalEntityName) {\n        this.externalEntityName = externalEntityName;\n    }\n"}
2025-05-13 21:00:26 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:00:26 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:00:26 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:00:26 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    public List<FieldInfo> getProjections() {\n        return projections;\n    }\n"}
2025-05-13 21:00:28 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:00:28 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:00:28 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:00:28 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    public void setProjections(List<FieldInfo> projections) {\n        this.projections = projections;\n    }\n"}
2025-05-13 21:00:29 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:00:29 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:00:29 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:00:29 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    public FilterRule getWhereClause() {\n        return whereClause;\n    }\n"}
2025-05-13 21:00:31 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:00:31 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:00:31 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:00:31 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    public void setWhereClause(FilterRule whereClause) {\n        this.whereClause = whereClause;\n    }\n"}
2025-05-13 21:00:32 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:00:32 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:00:32 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:00:32 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    public String getQuery() {\n        return query;\n    }\n"}
2025-05-13 21:00:33 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:00:33 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:00:33 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:00:33 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    public void setQuery(String query) {\n        this.query = query;\n    }\n"}
2025-05-13 21:00:35 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:00:35 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:00:35 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:00:35 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    public String getConnectorType() {\n        return connectorType;\n    }\n"}
2025-05-13 21:00:36 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:00:36 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:00:36 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:00:36 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    public void setConnectorType(String connectorType) {\n        this.connectorType = connectorType;\n    }\n"}
2025-05-13 21:00:37 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:00:37 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:00:37 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:00:37 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    public String getUcId() {\n        return ucId;\n    }\n"}
2025-05-13 21:00:39 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:00:39 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:00:39 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:00:39 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    public void setUcId(String ucId) {\n        this.ucId = ucId;\n    }\n"}
2025-05-13 21:00:40 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:00:40 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:00:40 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:00:40 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    public String getJobId() {\n        return jobId;\n    }\n"}
2025-05-13 21:00:41 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:00:42 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:00:42 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:00:42 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    public void setJobId(String jobId) {\n        this.jobId = jobId;\n    }\n"}
2025-05-13 21:00:43 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:00:43 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:00:43 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:00:43 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    public String getTaskId() {\n        return taskId;\n    }\n"}
2025-05-13 21:00:44 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:00:44 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:00:44 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:00:44 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    public void setTaskId(String taskId) {\n        this.taskId = taskId;\n    }\n"}
2025-05-13 21:00:46 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:00:46 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:00:46 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:00:46 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    public String getIpaasStagingDetailsId() {\n        return ipaasStagingDetailsId;\n    }\n"}
2025-05-13 21:00:47 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:00:47 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:00:47 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:00:47 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    public void setIpaasStagingDetailsId(String ipaasStagingDetailsId) {\n        this.ipaasStagingDetailsId = ipaasStagingDetailsId;\n    }\n"}
2025-05-13 21:00:48 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:00:48 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:00:48 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:00:48 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    public ConnectionInfo getStagingConnectionInfo() {\n        return stagingConnectionInfo;\n    }\n"}
2025-05-13 21:00:50 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:00:50 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:00:50 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:00:50 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    public void setStagingConnectionInfo(ConnectionInfo stagingConnectionInfo) {\n        this.stagingConnectionInfo = stagingConnectionInfo;\n    }\n"}
2025-05-13 21:00:51 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:00:51 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:00:51 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:00:51 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    public String getLastModifieldFieldPath() {\n        return lastModifieldFieldPath;\n    }\n"}
2025-05-13 21:00:52 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:00:52 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:00:52 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:00:52 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    public void setLastModifieldFieldPath(String lastModifieldFieldPath) {\n        this.lastModifieldFieldPath = lastModifieldFieldPath;\n    }\n"}
2025-05-13 21:00:54 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:00:54 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:00:54 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:00:54 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    public boolean isResolvePicklist() {\n        return resolvePicklist;\n    }\n"}
2025-05-13 21:00:55 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:00:55 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:00:55 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:00:55 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    public OrderByInfo getOrderByInfo() {\n        return orderByInfo;\n    }\n"}
2025-05-13 21:00:56 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:00:56 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:00:56 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:00:56 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    public void setOrderByInfo(OrderByInfo orderByInfo) {\n        this.orderByInfo = orderByInfo;\n    }\n"}
2025-05-13 21:00:58 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:00:58 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:00:58 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:00:58 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    public void setResolvePicklist(boolean resolvePicklist) {\n        this.resolvePicklist = resolvePicklist;\n    }\n"}
2025-05-13 21:00:59 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:00:59 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:00:59 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:00:59 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    public String getUpsertkey() {\n        return upsertkey;\n    }\n"}
2025-05-13 21:01:00 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:01:00 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:01:00 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:01:00 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    public void setUpsertkey(String upsertkey) {\n        this.upsertkey = upsertkey;\n    }\n"}
2025-05-13 21:01:02 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:01:02 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:01:02 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:01:02 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    public Object getLastModifieldFieldValue() {\n        return lastModifieldFieldValue;\n    }\n"}
2025-05-13 21:01:04 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:01:04 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:01:04 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:01:04 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    public void setLastModifieldFieldValue(Object lastModifieldFieldValue) {\n        this.lastModifieldFieldValue = lastModifieldFieldValue;\n    }\n"}
2025-05-13 21:01:05 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:01:06 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:01:06 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:01:06 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    public boolean isEnableDownloadSourceData() {\n        return enableDownloadSourceData;\n    }\n"}
2025-05-13 21:01:07 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:01:07 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:01:07 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:01:07 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    public void setEnableDownloadSourceData(boolean enableDownloadSourceData) {\n        this.enableDownloadSourceData = enableDownloadSourceData;\n    }\n"}
2025-05-13 21:01:08 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:01:08 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:01:08 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:01:08 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    public boolean isIgnoreInvalidData() {\n        return ignoreInvalidData;\n    }\n"}
2025-05-13 21:01:10 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:01:10 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:01:10 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:01:10 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    public void setIgnoreInvalidData(boolean ignoreInvalidData) {\n        this.ignoreInvalidData = ignoreInvalidData;\n    }\n"}
2025-05-13 21:01:11 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:01:11 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:01:11 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:01:11 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    public String toString() {\n        return \"IpaasExtractionDetails{\" +\n                \"connectionId='\" + connectionId + '\\'' +\n                \", externalEntityName='\" + externalEntityName + '\\'' +\n                \", projections=\" + projections +\n                \", whereClause=\" + whereClause +\n                \", orderByInfo=\" + orderByInfo +\n                \", query='\" + query + '\\'' +\n                \", connectorType='\" + connectorType + '\\'' +\n                \", ucId='\" + ucId + '\\'' +\n                \", ipaasStagingDetailsId='\" + ipaasStagingDetailsId + '\\'' +\n                \", jobId='\" + jobId + '\\'' +\n                \", taskId='\" + taskId + '\\'' +\n                \", stagingConnectionInfo=\" + stagingConnectionInfo +\n                \", lastModifieldFieldPath='\" + lastModifieldFieldPath + '\\'' +\n                \", resolvePicklist=\" + resolvePicklist +\n                \", upsertkey='\" + upsertkey + '\\'' +\n                \", lastModifieldFieldValue=\" + lastModifieldFieldValue +\n                \", honourLastModfiedFieldValueToFetchDeltaData=\" + honourLastModfiedFieldValueToFetchDeltaData +\n                \", defaultSleepTimeOnFail=\" + defaultSleepTimeOnFail +\n                \", pageSize='\" + pageSize + '\\'' +\n                \", enableDownloadSourceData=\" + enableDownloadSourceData +\n                \", maxNumberOfRetries=\" + maxNumberOfRetries +\n                \", ignoreInvalidData=\" + ignoreInvalidData +\n                \", ignorableErrorMessages=\" + ignorableErrorMessages +\n                \", queryParamForDataFetch=\" + queryParamForDataFetch +\n                '}';\n    }\n"}
2025-05-13 21:01:13 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:01:13 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:01:13 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:01:13 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    public List<String> getIgnorableErrorMessages() {\n        return ignorableErrorMessages;\n    }\n"}
2025-05-13 21:01:14 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:01:14 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:01:14 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:01:14 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    public void setIgnorableErrorMessages(List<String> ignorableErrorMessages) {\n        this.ignorableErrorMessages = ignorableErrorMessages;\n    }\n"}
2025-05-13 21:01:16 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:01:16 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:01:16 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:01:16 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"public class IpaasExtractionDetails {\n\n    private static final long serialVersionUID = -11278538782L;\n\n    private String connectionId;\n    private String externalEntityName;\n    private List<FieldInfo> projections;\n    private FilterRule whereClause;\n    private OrderByInfo orderByInfo;\n    private String query;\n    private String connectorType;\n    private String ucId;\n    private String ipaasStagingDetailsId;\n    private String jobId;\n    private String taskId;\n    private ConnectionInfo stagingConnectionInfo;\n    private String lastModifieldFieldPath;\n    private boolean resolvePicklist;\n    private String upsertkey;\n    private Object lastModifieldFieldValue;\n    private boolean honourLastModfiedFieldValueToFetchDeltaData;\n    private int defaultSleepTimeOnFail;\n    private String pageSize;\n    private boolean enableDownloadSourceData;\n    private int maxNumberOfRetries;\n    private boolean ignoreInvalidData;\n    private List<String> ignorableErrorMessages= Lists.newArrayList();\n    private String queryParamForDataFetch;\n    private boolean skipFieldsForFetch;\n\n    private Map<String, Object> additionalInformation;\n    public Map<String, Object> getAdditionalInformation() {\n        return additionalInformation;\n    }\n\n    public void setAdditionalInformation(Map<String, Object> additionalInformation) {\n        this.additionalInformation = additionalInformation;\n    }\n\n    public boolean isSkipFieldsForFetch() {\n        return skipFieldsForFetch;\n    }\n\n    public void setSkipFieldsForFetch(boolean skipFieldsForFetch) {\n        this.skipFieldsForFetch = skipFieldsForFetch;\n    }\n    public String getQueryParamForDataFetch() {\n        return queryParamForDataFetch;\n    }\n\n    public void setQueryParamForDataFetch(String queryParamForDataFetch) {\n        this.queryParamForDataFetch = queryParamForDataFetch;\n    }\n    public int getMaxNumberOfRetries() {\n        return maxNumberOfRetries;\n    }\n\n    public void setMaxNumberOfRetries(int maxNumberOfRetries) {\n        this.maxNumberOfRetries = maxNumberOfRetries;\n    }\n    public String getPageSize() {\n        return pageSize;\n    }\n\n    public void setPageSize(String pageSize) {\n        this.pageSize = pageSize;\n    }\n    public int getDefaultSleepTimeOnFail() {\n        return defaultSleepTimeOnFail;\n    }\n\n    public void setDefaultSleepTimeOnFail(int defaultSleepTimeOnFail) {\n        this.defaultSleepTimeOnFail = defaultSleepTimeOnFail;\n    }\n\n    public boolean isHonourLastModfiedFieldValueToFetchDeltaData() {\n        return honourLastModfiedFieldValueToFetchDeltaData;\n    }\n\n    public void setHonourLastModfiedFieldValueToFetchDeltaData(boolean honourLastModfiedFieldValueToFetchDeltaData) {\n        this.honourLastModfiedFieldValueToFetchDeltaData = honourLastModfiedFieldValueToFetchDeltaData;\n    }\n\n    public String getConnectionId() {\n        return connectionId;\n    }\n\n    public void setConnectionId(String connectionId) {\n        this.connectionId = connectionId;\n    }\n\n    public String getExternalEntityName() {\n        return externalEntityName;\n    }\n\n    public void setExternalEntityName(String externalEntityName) {\n        this.externalEntityName = externalEntityName;\n    }\n\n    public List<FieldInfo> getProjections() {\n        return projections;\n    }\n\n    public void setProjections(List<FieldInfo> projections) {\n        this.projections = projections;\n    }\n\n    public FilterRule getWhereClause() {\n        return whereClause;\n    }\n\n    public void setWhereClause(FilterRule whereClause) {\n        this.whereClause = whereClause;\n    }\n\n    public String getQuery() {\n        return query;\n    }\n\n    public void setQuery(String query) {\n        this.query = query;\n    }\n\n    public String getConnectorType() {\n        return connectorType;\n    }\n\n    public void setConnectorType(String connectorType) {\n        this.connectorType = connectorType;\n    }\n\n    public String getUcId() {\n        return ucId;\n    }\n\n    public void setUcId(String ucId) {\n        this.ucId = ucId;\n    }\n\n    public String getJobId() {\n        return jobId;\n    }\n\n    public void setJobId(String jobId) {\n        this.jobId = jobId;\n    }\n\n    public String getTaskId() {\n        return taskId;\n    }\n\n    public void setTaskId(String taskId) {\n        this.taskId = taskId;\n    }\n\n    public String getIpaasStagingDetailsId() {\n        return ipaasStagingDetailsId;\n    }\n\n    public void setIpaasStagingDetailsId(String ipaasStagingDetailsId) {\n        this.ipaasStagingDetailsId = ipaasStagingDetailsId;\n    }\n\n    public ConnectionInfo getStagingConnectionInfo() {\n        return stagingConnectionInfo;\n    }\n\n    public void setStagingConnectionInfo(ConnectionInfo stagingConnectionInfo) {\n        this.stagingConnectionInfo = stagingConnectionInfo;\n    }\n\n    public String getLastModifieldFieldPath() {\n        return lastModifieldFieldPath;\n    }\n\n    public void setLastModifieldFieldPath(String lastModifieldFieldPath) {\n        this.lastModifieldFieldPath = lastModifieldFieldPath;\n    }\n\n    public boolean isResolvePicklist() {\n        return resolvePicklist;\n    }\n\n    public OrderByInfo getOrderByInfo() {\n        return orderByInfo;\n    }\n\n    public void setOrderByInfo(OrderByInfo orderByInfo) {\n        this.orderByInfo = orderByInfo;\n    }\n\n    public void setResolvePicklist(boolean resolvePicklist) {\n        this.resolvePicklist = resolvePicklist;\n    }\n\n    public String getUpsertkey() {\n        return upsertkey;\n    }\n\n    public void setUpsertkey(String upsertkey) {\n        this.upsertkey = upsertkey;\n    }\n    public Object getLastModifieldFieldValue() {\n        return lastModifieldFieldValue;\n    }\n\n    public void setLastModifieldFieldValue(Object lastModifieldFieldValue) {\n        this.lastModifieldFieldValue = lastModifieldFieldValue;\n    }\n\n    public boolean isEnableDownloadSourceData() {\n        return enableDownloadSourceData;\n    }\n\n    public void setEnableDownloadSourceData(boolean enableDownloadSourceData) {\n        this.enableDownloadSourceData = enableDownloadSourceData;\n    }\n\n    public boolean isIgnoreInvalidData() {\n        return ignoreInvalidData;\n    }\n\n    public void setIgnoreInvalidData(boolean ignoreInvalidData) {\n        this.ignoreInvalidData = ignoreInvalidData;\n    }\n\n    @Override\n    public String toString() {\n        return \"IpaasExtractionDetails{\" +\n                \"connectionId='\" + connectionId + '\\'' +\n                \", externalEntityName='\" + externalEntityName + '\\'' +\n                \", projections=\" + projections +\n                \", whereClause=\" + whereClause +\n                \", orderByInfo=\" + orderByInfo +\n                \", query='\" + query + '\\'' +\n                \", connectorType='\" + connectorType + '\\'' +\n                \", ucId='\" + ucId + '\\'' +\n                \", ipaasStagingDetailsId='\" + ipaasStagingDetailsId + '\\'' +\n                \", jobId='\" + jobId + '\\'' +\n                \", taskId='\" + taskId + '\\'' +\n                \", stagingConnectionInfo=\" + stagingConnectionInfo +\n                \", lastModifieldFieldPath='\" + lastModifieldFieldPath + '\\'' +\n                \", resolvePicklist=\" + resolvePicklist +\n                \", upsertkey='\" + upsertkey + '\\'' +\n                \", lastModifieldFieldValue=\" + lastModifieldFieldValue +\n                \", honourLastModfiedFieldValueToFetchDeltaData=\" + honourLastModfiedFieldValueToFetchDeltaData +\n                \", defaultSleepTimeOnFail=\" + defaultSleepTimeOnFail +\n                \", pageSize='\" + pageSize + '\\'' +\n                \", enableDownloadSourceData=\" + enableDownloadSourceData +\n                \", maxNumberOfRetries=\" + maxNumberOfRetries +\n                \", ignoreInvalidData=\" + ignoreInvalidData +\n                \", ignorableErrorMessages=\" + ignorableErrorMessages +\n                \", queryParamForDataFetch=\" + queryParamForDataFetch +\n                '}';\n    }\n\n    public List<String> getIgnorableErrorMessages() {\n        return ignorableErrorMessages;\n    }\n\n    public void setIgnorableErrorMessages(List<String> ignorableErrorMessages) {\n        this.ignorableErrorMessages = ignorableErrorMessages;\n    }\n}\n"}
2025-05-13 21:01:17 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:01:17 [main] INFO  c.l.service.impl.BasicL3AgentService - Processed file: /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/code/dp_dynamic_tasks/ipaas-extraction-task/src/main/java/com/gainsight/services/external/ipaas/extraction/task/IpaasExtractionDetails.java with 55 chunks
2025-05-13 21:01:17 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:01:17 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:01:17 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"package com.gainsight.services.external.mssql.extraction.task;\n\nimport com.fasterxml.jackson.core.type.TypeReference;\nimport com.gainsight.services.datahighway.storage.db.commons.pojo.ConnectionParamPojo;\nimport com.gainsight.services.datahighway.storage.db.commons.pojo.DBResultPojo;\nimport com.gainsight.services.dataprocessing.commons.audit.AuditMetadata;\nimport com.gainsight.services.dataprocessing.commons.cryptography.CryptUtil;\nimport com.gainsight.services.dataprocessing.commons.exception.DPSystemException;\nimport com.gainsight.services.dataprocessing.commons.exception.ValidationCode;\nimport com.gainsight.services.dataprocessing.commons.pojo.fields.FieldInfo;\nimport com.gainsight.services.dataprocessing.commons.pojo.workflow.DPWorkflowJobDetailsDTO;\nimport com.gainsight.services.dataprocessing.commons.proxy.mda.CustomerCurrencyDTO;\nimport com.gainsight.services.dataprocessing.commons.system.CsvFile;\nimport com.gainsight.services.dataprocessing.commons.system.Precondition;\nimport com.gainsight.services.dataprocessing.commons.utils.DPUtils;\nimport com.gainsight.services.dataprocessing.dataprocessor.dagdataprocessor.pojo.ExternalExtractionTaskResult;\nimport com.gainsight.services.dataprocessing.dataprocessor.dagdataprocessor.pojo.TaskResult;\nimport com.gainsight.services.dataprocessing.dataprocessor.dagdataprocessor.utils.CustomerCurrencyUtil;\nimport com.gainsight.services.dataprocessing.external.task.ExternalTaskRequestContext;\nimport com.gainsight.services.dataprocessing.external.task.ExternalTaskUtil;\nimport com.gainsight.services.utilities.datahighway.dhcommons.enums.datatype.DataType;\nimport com.gainsight.services.utilities.datahighway.dhcommons.pojo.account.UDMAccountType;\nimport com.gainsight.services.utilities.datahighway.dhcommons.pojo.base.connection.ConnectorType;\nimport com.gainsight.services.utilities.datahighway.dhcommons.pojo.base.connection.RelationalDBConnectionDetail;\nimport com.gainsight.services.utilities.datahighway.dhcommons.pojo.query.QuerySourceType;\nimport com.gainsight.services.utilities.datahighway.dhquerybuilder.builders.FreeFormQueryBuilder;\nimport com.gainsight.services.utilities.datahighway.dhquerybuilder.constructs.query.OrderByInfo;\nimport com.gainsight.services.utilities.datahighway.dhquerybuilder.constructs.query.QueryBuilderResponse;\nimport com.gainsight.services.utilities.datahighway.dhquerybuilder.constructs.query.SQLQueryInfo;\nimport com.gainsight.services.utilities.datahighway.dhquerybuilder.helpers.SqlQueryBuilderHelper;\nimport org.apache.commons.collections.CollectionUtils;\nimport org.apache.commons.csv.CSVFormat;\nimport org.apache.commons.csv.CSVPrinter;\nimport org.apache.commons.csv.QuoteMode;\nimport org.apache.commons.io.IOUtils;\nimport org.json.JSONArray;\nimport org.json.JSONObject;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.sql.*;\nimport java.util.*;\n\nimport static com.gainsight.services.dataprocessing.commons.audit.AuditMetadata.newInstance;\nimport static com.gainsight.services.dataprocessing.commons.constants.Constants.WorkflowConstants.SQL_EXTRACTION_DETAILS_KEY;\nimport static com.gainsight.services.dataprocessing.commons.utils.DPUtils.convertJsonToObject;\nimport static com.gainsight.services.dataprocessing.commons.utils.DPUtils.msg;\n\n/**\n * @author sthammishetty on 16/03/20\n */\npublic class MsSqlExtractionTask {\n    private static final Logger LOGGER = LoggerFactory.getLogger(MsSqlExtractionTask.class);\n    private static final int SQL_EXTRACTION_QUERY_LIMIT = 10000;\n\n    public static void main(String[] args) {\n        executeTask(ExternalTaskUtil.getExternalTaskRequestContext());\n    }\n\n    private static void executeTask(ExternalTaskRequestContext externalTaskRequestContext) {\n        ExternalExtractionTaskResult externalExtractionTaskResult = null;\n        try {\n            Map<String, Object> systemProperties = externalTaskRequestContext.getWorkflowSystemProperties();\n            String jobId = externalTaskRequestContext.getJobId();\n\n            //Get workflowJobDetails of given jobId\n            DPWorkflowJobDetailsDTO workflowJobDetails = externalTaskRequestContext.getWorkflowJobDetails();\n            UDMAccountType connectorType = null;\n            RelationalDBConnectionDetail relationalDBConnectionDetail = null;\n            Map<String, String> metaData = externalTaskRequestContext.getMetaData();\n            SQLQueryInfo sqlQueryInfo = convertJsonToObject(metaData.get(SQL_EXTRACTION_DETAILS_KEY), SQLQueryInfo.class);\n            Precondition.isNotNull(sqlQueryInfo, ValidationCode.GENERIC_SYSTEM_ERROR, \"Sql Extraction details cannot be empty. Missing extractionDetails information in task metadata\");\n            String mdaBaseUrl = Objects.nonNull(workflowJobDetails.getConfigSourceUrl()) ? workflowJobDetails.getConfigSourceUrl() : workflowJobDetails.getCallbackUrl();\n            String taskId = externalTaskRequestContext.getTaskId();\n            AuditMetadata auditMetadata = newInstance(workflowJobDetails.getTenantId(), workflowJobDetails.getJobId(), workflowJobDetails.getExternalId(), taskId, externalTaskRequestContext.getTaskName());\n\n            if (sqlQueryInfo.getConnectionDetail() instanceof RelationalDBConnectionDetail) {\n                relationalDBConnectionDetail = (RelationalDBConnectionDetail) sqlQueryInfo.getConnectionDetail();\n                connectorType = UDMAccountType.valueOf(relationalDBConnectionDetail.getType());\n            } else {\n                throw new DPSystemException(\"Please provide either valid MsSql ConnectionDetails\");\n            }\n\n            if (connectorType == null || !UDMAccountType.MSSQL.equals(connectorType))\n                throw new DPSystemException(msg(\"Invalid ConnectorType :{}. Only Supports MsSql ConnectorType.\", connectorType));\n\n            List<FieldInfo> headers = DPUtils.convertJsonToObject(DPUtils.convertObjectToJson(sqlQueryInfo.getShowFields()), new TypeReference<List<FieldInfo>>() {\n            });\n            CsvFile csvFile = executeQuery(systemProperties, sqlQueryInfo, relationalDBConnectionDetail, externalTaskRequestContext);\n\n            //Creating instance of TaskResult\n            TaskResult taskResult = new TaskResult(headers, null);\n            char delimiter = csvFile.getDelimiter() != null ? csvFile.getDelimiter().charAt(0) : null;\n\n            // Creating instance of ExternalExtractionTaskResult\n            Map<String, CustomerCurrencyDTO> currencyConversionMap = null;\n            if (DPUtils.isCurrencyConversionMapRequired(headers)) {\n                currencyConversionMap = CustomerCurrencyUtil.getCustomerCurrencyConversionMap(mdaBaseUrl, auditMetadata, true);\n            }\n            //If no csvRecord parsing handler is added, DefaultCsvRecordParsingHandler is set for parsing each csvRecord.\n            externalExtractionTaskResult = new ExternalExtractionTaskResult.ExternalExtractionTaskResultBuilder()\n                    .setWithHeader(csvFile.getHeaders() != null)\n                    .setDelimiter(delimiter)\n                    .setExtractedFiles(Collections.singletonList(csvFile.getAbsolutePath()))\n                    .setTaskResult(taskResult)\n                    .setCurrencyConversionMap(currencyConversionMap)\n                    .build();\n\n            //Saving externalTask Result.\n            ExternalTaskUtil.saveExternalTaskResult(workflowJobDetails.getTenantId(), jobId, taskId, externalExtractionTaskResult);\n        } catch (Exception ex) {\n            LOGGER.error(\"Exception while executing externalTask {}-{}\", ex.getMessage(), ex);\n            throw new DPSystemException(ex.getMessage(), ex);\n\n        }\n    }\n\n    private static CsvFile executeQuery(Map<String, Object> workflowSystemProperties, SQLQueryInfo sqlQueryInfo, RelationalDBConnectionDetail dbConnectionDetail, ExternalTaskRequestContext externalTaskRequestContext) {\n        CsvFile csvFile = null;\n        try {\n            if (Objects.isNull(sqlQueryInfo.getOrderByInfo())) {\n                OrderByInfo orderByInfo = new OrderByInfo();\n                orderByInfo.setOrderByFields(Collections.singletonList(sqlQueryInfo.getShowFields().get(0)));\n                sqlQueryInfo.setOrderByInfo(orderByInfo);\n            }\n\n            QueryBuilderResponse msSqlExtract = new FreeFormQueryBuilder().with(sqlQueryInfo)\n                    .withQueryBuilderHelper(new SqlQueryBuilderHelper(ConnectorType.MSSQL))\n                    .withQuerySourceType(QuerySourceType.SQL)\n                    .withSystemProperties(workflowSystemProperties)\n                    .withNullLastInOrderByClause(false).build();\n            String msSqlExtractQuery = msSqlExtract.getQuery();\n            LOGGER.info(\"MsSql Extract Query: {}\", msSqlExtractQuery);\n            String connectionUrl = \"jdbc:sqlserver://\" + CryptUtil.decrypt(dbConnectionDetail.getHost()) + \":\" + CryptUtil.decrypt(dbConnectionDetail.getPort()) + \";databaseName=\" + CryptUtil.decrypt(dbConnectionDetail.getDataBaseName());\n            if (dbConnectionDetail.isSslEnabled()) {\n                connectionUrl += \";encrypt=true\";\n            }\n            ConnectionParamPojo connectionParamPojo = new ConnectionParamPojo(connectionUrl, CryptUtil.decrypt(dbConnectionDetail.getUser()), CryptUtil.decrypt(dbConnectionDetail.getPwd()), 1, null, dbConnectionDetail.isSslEnabled());\n            csvFile = executeQuery(connectionParamPojo, msSqlExtractQuery, sqlQueryInfo, externalTaskRequestContext);\n        } catch (Exception ex) {\n            LOGGER.error(\"{}-{}\", ex.getMessage(), ex);\n            throw new DPSystemException(ex.getMessage(), ex);\n        }\n        return csvFile;\n    }\n\n    private static CsvFile executeQuery(ConnectionParamPojo connectionParamPojo, String query, SQLQueryInfo sqlQueryInfo, ExternalTaskRequestContext externalTaskRequestContext) throws IOException {\n        int offset = 0;\n        int recordsRetrieved = 0;\n        Connection connection = null;\n        CsvFile csvFile = null;\n        CSVPrinter csvPrinter = null;\n        try {\n            csvFile = getCsvFileForSQLExtract(externalTaskRequestContext);\n            List<String> headers = new ArrayList<>();\n            sqlQueryInfo.getShowFields().forEach(showField -> headers.add(showField.getFieldAlias()));\n            csvFile.setHeaders(headers);\n            csvPrinter = new CSVPrinter(new BufferedWriter(new FileWriter(csvFile)), CSVFormat.DEFAULT.withQuoteMode(QuoteMode.NON_NUMERIC).withHeader(headers.toArray(new String[headers.size()])));\n            connection = getConnectionObject(connectionParamPojo);\n            List<JSONObject> dbResultSetRows = new ArrayList<>();\n            do {\n                dbResultSetRows.clear();\n                String queryToExecute = query.trim() + \" offset \" + offset + \" ROWS FETCH NEXT \" + SQL_EXTRACTION_QUERY_LIMIT + \" ROWS ONLY\";\n                DBResultPojo dbResult = executeQuery(connection, queryToExecute);\n                if (!dbResult.isSucceded()) {\n                    throw new DPSystemException(msg(\"Query execution failed because of: {}\", dbResult.getCause().getMessage()));\n                }\n                JSONArray resultData = (JSONArray) dbResult.getResult();\n                for (int i = 0; i < resultData.length(); i++) {\n                    dbResultSetRows.add(resultData.getJSONObject(i));\n                }\n                List<Object> recordList = new ArrayList<>();\n                if (CollectionUtils.isNotEmpty(dbResultSetRows)) {\n                    for (JSONObject jsonObject : dbResultSetRows) {\n                        sqlQueryInfo.getShowFields().forEach(showField -> {\n                            String key = showField.getFieldAlias().toLowerCase();\n                            if (jsonObject.isNull(key)) {\n                                recordList.add(null);\n                            } else {\n                                if (showField.getDataType().equals(DataType.NUMBER)) {\n                                    recordList.add(jsonObject.getDouble(key));\n                                } else {\n                                    recordList.add(jsonObject.get(key));\n                                }\n                            }\n                        });\n                        csvPrinter.printRecord(recordList);\n                        recordList.clear();\n                    }\n                }\n                offset = offset + SQL_EXTRACTION_QUERY_LIMIT;\n                recordsRetrieved = recordsRetrieved + dbResultSetRows.size();\n                LOGGER.info(\"Retrieved {} records so far.\", recordsRetrieved);\n            } while (dbResultSetRows.size() == SQL_EXTRACTION_QUERY_LIMIT && !Thread.currentThread().isInterrupted());\n            csvFile.setNumRecords(recordsRetrieved);\n            LOGGER.info(\"Total {} records retrieved for this task.\", recordsRetrieved);\n            csvPrinter.flush();\n        } catch (Exception ex) {\n            LOGGER.error(\"Unable to process SQL extract! {}-{}\", ex.getMessage(), ex);\n            throw new DPSystemException(ex.getMessage(), ex);\n        } finally {\n            IOUtils.closeQuietly(csvPrinter);\n            if (connection != null) {\n                try {\n                    connection.close();\n                } catch (SQLException e) {\n                    LOGGER.warn(\"Could not close connection to: {}\", connectionParamPojo.getJdbcUrl());\n                }\n            }\n\n        }\n        return csvFile;\n    }\n\n    private static DBResultPojo executeQuery(Connection connection, String queryToExecute) {\n        Statement statement = null;\n        DBResultPojo dbResultPojo = new DBResultPojo();\n        try {\n            statement = connection.createStatement();\n            ResultSet resultSet = statement.executeQuery(queryToExecute);\n            dbResultPojo.setSucceded(true);\n            dbResultPojo.setResult(convertToJSON(resultSet));\n        } catch (Exception exception) {\n            dbResultPojo.setSucceded(false);\n            dbResultPojo.setCause(exception);\n            if (exception instanceof SQLException) {\n                dbResultPojo.setErrorCode(com.gainsight.services.utilities.datahighway.dhcommons.exception.ValidationCode.DB_ERROR);\n            } else if (exception instanceof IOException) {\n                dbResultPojo.setErrorCode(com.gainsight.services.utilities.datahighway.dhcommons.exception.ValidationCode.IO_ERROR);\n            } else {\n                dbResultPojo.setErrorCode(com.gainsight.services.utilities.datahighway.dhcommons.exception.ValidationCode.UNKNOWN_SERVER_ERROR);\n            }\n        } finally {\n            if (statement != null) {\n                try {\n                    statement.close();\n                } catch (SQLException e) {\n                    LOGGER.warn(\"Error while closing jdbc statement object \");\n                }\n            }\n        }\n        return dbResultPojo;\n    }\n\n    private static JSONArray convertToJSON(ResultSet resultSet) throws Exception {\n        JSONArray jsonArray = new JSONArray();\n        while (resultSet.next()) {\n            int columnCount = resultSet.getMetaData().getColumnCount();\n            JSONObject jsonObject = new JSONObject();\n            for (int i = 0; i < columnCount; ++i) {\n                Object object = resultSet.getObject(i + 1);\n                if (object == null) {\n                    object = JSONObject.NULL;\n                }\n                jsonObject.put(resultSet.getMetaData().getColumnLabel(i + 1).toLowerCase(), object);\n            }\n            jsonArray.put(jsonObject);\n        }\n        return jsonArray;\n    }\n\n    private static CsvFile getCsvFileForSQLExtract(ExternalTaskRequestContext externalTaskRequestContext) throws IOException {\n        String tempFilePath = DPUtils.getTempFilePath(externalTaskRequestContext.getTenantId(), externalTaskRequestContext.getJobId(), externalTaskRequestContext.getTaskId(), UUID.randomUUID().toString() + \".csv\");\n        File file = new File(tempFilePath);\n        Files.createDirectories(Paths.get(file.getParent()));\n        Files.createFile(Paths.get(file.getAbsolutePath()));\n\n        CsvFile csvFile = new CsvFile(tempFilePath);\n        csvFile.setFirstRecordHeader(true);\n        csvFile.setQuoteMode(QuoteMode.NON_NUMERIC);\n        return csvFile;\n    }\n\n    private static Connection getConnectionObject(ConnectionParamPojo connectionParamPojo) throws SQLException, ClassNotFoundException {\n        Properties properties = new Properties();\n        properties.setProperty(\"user\", connectionParamPojo.getUserName());\n        properties.setProperty(\"password\", connectionParamPojo.getPassword());\n        properties.setProperty(\"tcpKeepAlive\", Boolean.TRUE.toString());\n        Class.forName(\"com.microsoft.sqlserver.jdbc.SQLServerDriver\");\n        return DriverManager.getConnection(connectionParamPojo.getJdbcUrl(), properties);\n    }\n}\n"}
2025-05-13 21:01:19 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:01:19 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:01:19 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:01:19 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    public static void main(String[] args) {\n        executeTask(ExternalTaskUtil.getExternalTaskRequestContext());\n    }\n"}
2025-05-13 21:01:20 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:01:20 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:01:20 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:01:20 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    private static void executeTask(ExternalTaskRequestContext externalTaskRequestContext) {\n        ExternalExtractionTaskResult externalExtractionTaskResult = null;\n        try {\n            Map<String, Object> systemProperties = externalTaskRequestContext.getWorkflowSystemProperties();\n            String jobId = externalTaskRequestContext.getJobId();\n\n            //Get workflowJobDetails of given jobId\n            DPWorkflowJobDetailsDTO workflowJobDetails = externalTaskRequestContext.getWorkflowJobDetails();\n            UDMAccountType connectorType = null;\n            RelationalDBConnectionDetail relationalDBConnectionDetail = null;\n            Map<String, String> metaData = externalTaskRequestContext.getMetaData();\n            SQLQueryInfo sqlQueryInfo = convertJsonToObject(metaData.get(SQL_EXTRACTION_DETAILS_KEY), SQLQueryInfo.class);\n            Precondition.isNotNull(sqlQueryInfo, ValidationCode.GENERIC_SYSTEM_ERROR, \"Sql Extraction details cannot be empty. Missing extractionDetails information in task metadata\");\n            String mdaBaseUrl = Objects.nonNull(workflowJobDetails.getConfigSourceUrl()) ? workflowJobDetails.getConfigSourceUrl() : workflowJobDetails.getCallbackUrl();\n            String taskId = externalTaskRequestContext.getTaskId();\n            AuditMetadata auditMetadata = newInstance(workflowJobDetails.getTenantId(), workflowJobDetails.getJobId(), workflowJobDetails.getExternalId(), taskId, externalTaskRequestContext.getTaskName());\n\n            if (sqlQueryInfo.getConnectionDetail() instanceof RelationalDBConnectionDetail) {\n                relationalDBConnectionDetail = (RelationalDBConnectionDetail) sqlQueryInfo.getConnectionDetail();\n                connectorType = UDMAccountType.valueOf(relationalDBConnectionDetail.getType());\n            } else {\n                throw new DPSystemException(\"Please provide either valid MsSql ConnectionDetails\");\n            }\n\n            if (connectorType == null || !UDMAccountType.MSSQL.equals(connectorType))\n                throw new DPSystemException(msg(\"Invalid ConnectorType :{}. Only Supports MsSql ConnectorType.\", connectorType));\n\n            List<FieldInfo> headers = DPUtils.convertJsonToObject(DPUtils.convertObjectToJson(sqlQueryInfo.getShowFields()), new TypeReference<List<FieldInfo>>() {\n            });\n            CsvFile csvFile = executeQuery(systemProperties, sqlQueryInfo, relationalDBConnectionDetail, externalTaskRequestContext);\n\n            //Creating instance of TaskResult\n            TaskResult taskResult = new TaskResult(headers, null);\n            char delimiter = csvFile.getDelimiter() != null ? csvFile.getDelimiter().charAt(0) : null;\n\n            // Creating instance of ExternalExtractionTaskResult\n            Map<String, CustomerCurrencyDTO> currencyConversionMap = null;\n            if (DPUtils.isCurrencyConversionMapRequired(headers)) {\n                currencyConversionMap = CustomerCurrencyUtil.getCustomerCurrencyConversionMap(mdaBaseUrl, auditMetadata, true);\n            }\n            //If no csvRecord parsing handler is added, DefaultCsvRecordParsingHandler is set for parsing each csvRecord.\n            externalExtractionTaskResult = new ExternalExtractionTaskResult.ExternalExtractionTaskResultBuilder()\n                    .setWithHeader(csvFile.getHeaders() != null)\n                    .setDelimiter(delimiter)\n                    .setExtractedFiles(Collections.singletonList(csvFile.getAbsolutePath()))\n                    .setTaskResult(taskResult)\n                    .setCurrencyConversionMap(currencyConversionMap)\n                    .build();\n\n            //Saving externalTask Result.\n            ExternalTaskUtil.saveExternalTaskResult(workflowJobDetails.getTenantId(), jobId, taskId, externalExtractionTaskResult);\n        } catch (Exception ex) {\n            LOGGER.error(\"Exception while executing externalTask {}-{}\", ex.getMessage(), ex);\n            throw new DPSystemException(ex.getMessage(), ex);\n\n        }\n    }\n"}
2025-05-13 21:01:22 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:01:22 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:01:22 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:01:22 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    private static CsvFile executeQuery(Map<String, Object> workflowSystemProperties, SQLQueryInfo sqlQueryInfo, RelationalDBConnectionDetail dbConnectionDetail, ExternalTaskRequestContext externalTaskRequestContext) {\n        CsvFile csvFile = null;\n        try {\n            if (Objects.isNull(sqlQueryInfo.getOrderByInfo())) {\n                OrderByInfo orderByInfo = new OrderByInfo();\n                orderByInfo.setOrderByFields(Collections.singletonList(sqlQueryInfo.getShowFields().get(0)));\n                sqlQueryInfo.setOrderByInfo(orderByInfo);\n            }\n\n            QueryBuilderResponse msSqlExtract = new FreeFormQueryBuilder().with(sqlQueryInfo)\n                    .withQueryBuilderHelper(new SqlQueryBuilderHelper(ConnectorType.MSSQL))\n                    .withQuerySourceType(QuerySourceType.SQL)\n                    .withSystemProperties(workflowSystemProperties)\n                    .withNullLastInOrderByClause(false).build();\n            String msSqlExtractQuery = msSqlExtract.getQuery();\n            LOGGER.info(\"MsSql Extract Query: {}\", msSqlExtractQuery);\n            String connectionUrl = \"jdbc:sqlserver://\" + CryptUtil.decrypt(dbConnectionDetail.getHost()) + \":\" + CryptUtil.decrypt(dbConnectionDetail.getPort()) + \";databaseName=\" + CryptUtil.decrypt(dbConnectionDetail.getDataBaseName());\n            if (dbConnectionDetail.isSslEnabled()) {\n                connectionUrl += \";encrypt=true\";\n            }\n            ConnectionParamPojo connectionParamPojo = new ConnectionParamPojo(connectionUrl, CryptUtil.decrypt(dbConnectionDetail.getUser()), CryptUtil.decrypt(dbConnectionDetail.getPwd()), 1, null, dbConnectionDetail.isSslEnabled());\n            csvFile = executeQuery(connectionParamPojo, msSqlExtractQuery, sqlQueryInfo, externalTaskRequestContext);\n        } catch (Exception ex) {\n            LOGGER.error(\"{}-{}\", ex.getMessage(), ex);\n            throw new DPSystemException(ex.getMessage(), ex);\n        }\n        return csvFile;\n    }\n"}
2025-05-13 21:01:23 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:01:23 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:01:23 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:01:23 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    private static CsvFile executeQuery(ConnectionParamPojo connectionParamPojo, String query, SQLQueryInfo sqlQueryInfo, ExternalTaskRequestContext externalTaskRequestContext) throws IOException {\n        int offset = 0;\n        int recordsRetrieved = 0;\n        Connection connection = null;\n        CsvFile csvFile = null;\n        CSVPrinter csvPrinter = null;\n        try {\n            csvFile = getCsvFileForSQLExtract(externalTaskRequestContext);\n            List<String> headers = new ArrayList<>();\n            sqlQueryInfo.getShowFields().forEach(showField -> headers.add(showField.getFieldAlias()));\n            csvFile.setHeaders(headers);\n            csvPrinter = new CSVPrinter(new BufferedWriter(new FileWriter(csvFile)), CSVFormat.DEFAULT.withQuoteMode(QuoteMode.NON_NUMERIC).withHeader(headers.toArray(new String[headers.size()])));\n            connection = getConnectionObject(connectionParamPojo);\n            List<JSONObject> dbResultSetRows = new ArrayList<>();\n            do {\n                dbResultSetRows.clear();\n                String queryToExecute = query.trim() + \" offset \" + offset + \" ROWS FETCH NEXT \" + SQL_EXTRACTION_QUERY_LIMIT + \" ROWS ONLY\";\n                DBResultPojo dbResult = executeQuery(connection, queryToExecute);\n                if (!dbResult.isSucceded()) {\n                    throw new DPSystemException(msg(\"Query execution failed because of: {}\", dbResult.getCause().getMessage()));\n                }\n                JSONArray resultData = (JSONArray) dbResult.getResult();\n                for (int i = 0; i < resultData.length(); i++) {\n                    dbResultSetRows.add(resultData.getJSONObject(i));\n                }\n                List<Object> recordList = new ArrayList<>();\n                if (CollectionUtils.isNotEmpty(dbResultSetRows)) {\n                    for (JSONObject jsonObject : dbResultSetRows) {\n                        sqlQueryInfo.getShowFields().forEach(showField -> {\n                            String key = showField.getFieldAlias().toLowerCase();\n                            if (jsonObject.isNull(key)) {\n                                recordList.add(null);\n                            } else {\n                                if (showField.getDataType().equals(DataType.NUMBER)) {\n                                    recordList.add(jsonObject.getDouble(key));\n                                } else {\n                                    recordList.add(jsonObject.get(key));\n                                }\n                            }\n                        });\n                        csvPrinter.printRecord(recordList);\n                        recordList.clear();\n                    }\n                }\n                offset = offset + SQL_EXTRACTION_QUERY_LIMIT;\n                recordsRetrieved = recordsRetrieved + dbResultSetRows.size();\n                LOGGER.info(\"Retrieved {} records so far.\", recordsRetrieved);\n            } while (dbResultSetRows.size() == SQL_EXTRACTION_QUERY_LIMIT && !Thread.currentThread().isInterrupted());\n            csvFile.setNumRecords(recordsRetrieved);\n            LOGGER.info(\"Total {} records retrieved for this task.\", recordsRetrieved);\n            csvPrinter.flush();\n        } catch (Exception ex) {\n            LOGGER.error(\"Unable to process SQL extract! {}-{}\", ex.getMessage(), ex);\n            throw new DPSystemException(ex.getMessage(), ex);\n        } finally {\n            IOUtils.closeQuietly(csvPrinter);\n            if (connection != null) {\n                try {\n                    connection.close();\n                } catch (SQLException e) {\n                    LOGGER.warn(\"Could not close connection to: {}\", connectionParamPojo.getJdbcUrl());\n                }\n            }\n\n        }\n        return csvFile;\n    }\n"}
2025-05-13 21:01:25 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:01:25 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:01:25 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:01:25 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    private static DBResultPojo executeQuery(Connection connection, String queryToExecute) {\n        Statement statement = null;\n        DBResultPojo dbResultPojo = new DBResultPojo();\n        try {\n            statement = connection.createStatement();\n            ResultSet resultSet = statement.executeQuery(queryToExecute);\n            dbResultPojo.setSucceded(true);\n            dbResultPojo.setResult(convertToJSON(resultSet));\n        } catch (Exception exception) {\n            dbResultPojo.setSucceded(false);\n            dbResultPojo.setCause(exception);\n            if (exception instanceof SQLException) {\n                dbResultPojo.setErrorCode(com.gainsight.services.utilities.datahighway.dhcommons.exception.ValidationCode.DB_ERROR);\n            } else if (exception instanceof IOException) {\n                dbResultPojo.setErrorCode(com.gainsight.services.utilities.datahighway.dhcommons.exception.ValidationCode.IO_ERROR);\n            } else {\n                dbResultPojo.setErrorCode(com.gainsight.services.utilities.datahighway.dhcommons.exception.ValidationCode.UNKNOWN_SERVER_ERROR);\n            }\n        } finally {\n            if (statement != null) {\n                try {\n                    statement.close();\n                } catch (SQLException e) {\n                    LOGGER.warn(\"Error while closing jdbc statement object \");\n                }\n            }\n        }\n        return dbResultPojo;\n    }\n"}
2025-05-13 21:01:26 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:01:26 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:01:26 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:01:26 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    private static JSONArray convertToJSON(ResultSet resultSet) throws Exception {\n        JSONArray jsonArray = new JSONArray();\n        while (resultSet.next()) {\n            int columnCount = resultSet.getMetaData().getColumnCount();\n            JSONObject jsonObject = new JSONObject();\n            for (int i = 0; i < columnCount; ++i) {\n                Object object = resultSet.getObject(i + 1);\n                if (object == null) {\n                    object = JSONObject.NULL;\n                }\n                jsonObject.put(resultSet.getMetaData().getColumnLabel(i + 1).toLowerCase(), object);\n            }\n            jsonArray.put(jsonObject);\n        }\n        return jsonArray;\n    }\n"}
2025-05-13 21:01:27 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:01:27 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:01:27 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:01:27 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    private static CsvFile getCsvFileForSQLExtract(ExternalTaskRequestContext externalTaskRequestContext) throws IOException {\n        String tempFilePath = DPUtils.getTempFilePath(externalTaskRequestContext.getTenantId(), externalTaskRequestContext.getJobId(), externalTaskRequestContext.getTaskId(), UUID.randomUUID().toString() + \".csv\");\n        File file = new File(tempFilePath);\n        Files.createDirectories(Paths.get(file.getParent()));\n        Files.createFile(Paths.get(file.getAbsolutePath()));\n\n        CsvFile csvFile = new CsvFile(tempFilePath);\n        csvFile.setFirstRecordHeader(true);\n        csvFile.setQuoteMode(QuoteMode.NON_NUMERIC);\n        return csvFile;\n    }\n"}
2025-05-13 21:01:29 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:01:29 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:01:29 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:01:29 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    private static Connection getConnectionObject(ConnectionParamPojo connectionParamPojo) throws SQLException, ClassNotFoundException {\n        Properties properties = new Properties();\n        properties.setProperty(\"user\", connectionParamPojo.getUserName());\n        properties.setProperty(\"password\", connectionParamPojo.getPassword());\n        properties.setProperty(\"tcpKeepAlive\", Boolean.TRUE.toString());\n        Class.forName(\"com.microsoft.sqlserver.jdbc.SQLServerDriver\");\n        return DriverManager.getConnection(connectionParamPojo.getJdbcUrl(), properties);\n    }\n"}
2025-05-13 21:01:30 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:01:30 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:01:30 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:01:30 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"public class MsSqlExtractionTask {\n    private static final Logger LOGGER = LoggerFactory.getLogger(MsSqlExtractionTask.class);\n    private static final int SQL_EXTRACTION_QUERY_LIMIT = 10000;\n\n    public static void main(String[] args) {\n        executeTask(ExternalTaskUtil.getExternalTaskRequestContext());\n    }\n\n    private static void executeTask(ExternalTaskRequestContext externalTaskRequestContext) {\n        ExternalExtractionTaskResult externalExtractionTaskResult = null;\n        try {\n            Map<String, Object> systemProperties = externalTaskRequestContext.getWorkflowSystemProperties();\n            String jobId = externalTaskRequestContext.getJobId();\n\n            //Get workflowJobDetails of given jobId\n            DPWorkflowJobDetailsDTO workflowJobDetails = externalTaskRequestContext.getWorkflowJobDetails();\n            UDMAccountType connectorType = null;\n            RelationalDBConnectionDetail relationalDBConnectionDetail = null;\n            Map<String, String> metaData = externalTaskRequestContext.getMetaData();\n            SQLQueryInfo sqlQueryInfo = convertJsonToObject(metaData.get(SQL_EXTRACTION_DETAILS_KEY), SQLQueryInfo.class);\n            Precondition.isNotNull(sqlQueryInfo, ValidationCode.GENERIC_SYSTEM_ERROR, \"Sql Extraction details cannot be empty. Missing extractionDetails information in task metadata\");\n            String mdaBaseUrl = Objects.nonNull(workflowJobDetails.getConfigSourceUrl()) ? workflowJobDetails.getConfigSourceUrl() : workflowJobDetails.getCallbackUrl();\n            String taskId = externalTaskRequestContext.getTaskId();\n            AuditMetadata auditMetadata = newInstance(workflowJobDetails.getTenantId(), workflowJobDetails.getJobId(), workflowJobDetails.getExternalId(), taskId, externalTaskRequestContext.getTaskName());\n\n            if (sqlQueryInfo.getConnectionDetail() instanceof RelationalDBConnectionDetail) {\n                relationalDBConnectionDetail = (RelationalDBConnectionDetail) sqlQueryInfo.getConnectionDetail();\n                connectorType = UDMAccountType.valueOf(relationalDBConnectionDetail.getType());\n            } else {\n                throw new DPSystemException(\"Please provide either valid MsSql ConnectionDetails\");\n            }\n\n            if (connectorType == null || !UDMAccountType.MSSQL.equals(connectorType))\n                throw new DPSystemException(msg(\"Invalid ConnectorType :{}. Only Supports MsSql ConnectorType.\", connectorType));\n\n            List<FieldInfo> headers = DPUtils.convertJsonToObject(DPUtils.convertObjectToJson(sqlQueryInfo.getShowFields()), new TypeReference<List<FieldInfo>>() {\n            });\n            CsvFile csvFile = executeQuery(systemProperties, sqlQueryInfo, relationalDBConnectionDetail, externalTaskRequestContext);\n\n            //Creating instance of TaskResult\n            TaskResult taskResult = new TaskResult(headers, null);\n            char delimiter = csvFile.getDelimiter() != null ? csvFile.getDelimiter().charAt(0) : null;\n\n            // Creating instance of ExternalExtractionTaskResult\n            Map<String, CustomerCurrencyDTO> currencyConversionMap = null;\n            if (DPUtils.isCurrencyConversionMapRequired(headers)) {\n                currencyConversionMap = CustomerCurrencyUtil.getCustomerCurrencyConversionMap(mdaBaseUrl, auditMetadata, true);\n            }\n            //If no csvRecord parsing handler is added, DefaultCsvRecordParsingHandler is set for parsing each csvRecord.\n            externalExtractionTaskResult = new ExternalExtractionTaskResult.ExternalExtractionTaskResultBuilder()\n                    .setWithHeader(csvFile.getHeaders() != null)\n                    .setDelimiter(delimiter)\n                    .setExtractedFiles(Collections.singletonList(csvFile.getAbsolutePath()))\n                    .setTaskResult(taskResult)\n                    .setCurrencyConversionMap(currencyConversionMap)\n                    .build();\n\n            //Saving externalTask Result.\n            ExternalTaskUtil.saveExternalTaskResult(workflowJobDetails.getTenantId(), jobId, taskId, externalExtractionTaskResult);\n        } catch (Exception ex) {\n            LOGGER.error(\"Exception while executing externalTask {}-{}\", ex.getMessage(), ex);\n            throw new DPSystemException(ex.getMessage(), ex);\n\n        }\n    }\n\n    private static CsvFile executeQuery(Map<String, Object> workflowSystemProperties, SQLQueryInfo sqlQueryInfo, RelationalDBConnectionDetail dbConnectionDetail, ExternalTaskRequestContext externalTaskRequestContext) {\n        CsvFile csvFile = null;\n        try {\n            if (Objects.isNull(sqlQueryInfo.getOrderByInfo())) {\n                OrderByInfo orderByInfo = new OrderByInfo();\n                orderByInfo.setOrderByFields(Collections.singletonList(sqlQueryInfo.getShowFields().get(0)));\n                sqlQueryInfo.setOrderByInfo(orderByInfo);\n            }\n\n            QueryBuilderResponse msSqlExtract = new FreeFormQueryBuilder().with(sqlQueryInfo)\n                    .withQueryBuilderHelper(new SqlQueryBuilderHelper(ConnectorType.MSSQL))\n                    .withQuerySourceType(QuerySourceType.SQL)\n                    .withSystemProperties(workflowSystemProperties)\n                    .withNullLastInOrderByClause(false).build();\n            String msSqlExtractQuery = msSqlExtract.getQuery();\n            LOGGER.info(\"MsSql Extract Query: {}\", msSqlExtractQuery);\n            String connectionUrl = \"jdbc:sqlserver://\" + CryptUtil.decrypt(dbConnectionDetail.getHost()) + \":\" + CryptUtil.decrypt(dbConnectionDetail.getPort()) + \";databaseName=\" + CryptUtil.decrypt(dbConnectionDetail.getDataBaseName());\n            if (dbConnectionDetail.isSslEnabled()) {\n                connectionUrl += \";encrypt=true\";\n            }\n            ConnectionParamPojo connectionParamPojo = new ConnectionParamPojo(connectionUrl, CryptUtil.decrypt(dbConnectionDetail.getUser()), CryptUtil.decrypt(dbConnectionDetail.getPwd()), 1, null, dbConnectionDetail.isSslEnabled());\n            csvFile = executeQuery(connectionParamPojo, msSqlExtractQuery, sqlQueryInfo, externalTaskRequestContext);\n        } catch (Exception ex) {\n            LOGGER.error(\"{}-{}\", ex.getMessage(), ex);\n            throw new DPSystemException(ex.getMessage(), ex);\n        }\n        return csvFile;\n    }\n\n    private static CsvFile executeQuery(ConnectionParamPojo connectionParamPojo, String query, SQLQueryInfo sqlQueryInfo, ExternalTaskRequestContext externalTaskRequestContext) throws IOException {\n        int offset = 0;\n        int recordsRetrieved = 0;\n        Connection connection = null;\n        CsvFile csvFile = null;\n        CSVPrinter csvPrinter = null;\n        try {\n            csvFile = getCsvFileForSQLExtract(externalTaskRequestContext);\n            List<String> headers = new ArrayList<>();\n            sqlQueryInfo.getShowFields().forEach(showField -> headers.add(showField.getFieldAlias()));\n            csvFile.setHeaders(headers);\n            csvPrinter = new CSVPrinter(new BufferedWriter(new FileWriter(csvFile)), CSVFormat.DEFAULT.withQuoteMode(QuoteMode.NON_NUMERIC).withHeader(headers.toArray(new String[headers.size()])));\n            connection = getConnectionObject(connectionParamPojo);\n            List<JSONObject> dbResultSetRows = new ArrayList<>();\n            do {\n                dbResultSetRows.clear();\n                String queryToExecute = query.trim() + \" offset \" + offset + \" ROWS FETCH NEXT \" + SQL_EXTRACTION_QUERY_LIMIT + \" ROWS ONLY\";\n                DBResultPojo dbResult = executeQuery(connection, queryToExecute);\n                if (!dbResult.isSucceded()) {\n                    throw new DPSystemException(msg(\"Query execution failed because of: {}\", dbResult.getCause().getMessage()));\n                }\n                JSONArray resultData = (JSONArray) dbResult.getResult();\n                for (int i = 0; i < resultData.length(); i++) {\n                    dbResultSetRows.add(resultData.getJSONObject(i));\n                }\n                List<Object> recordList = new ArrayList<>();\n                if (CollectionUtils.isNotEmpty(dbResultSetRows)) {\n                    for (JSONObject jsonObject : dbResultSetRows) {\n                        sqlQueryInfo.getShowFields().forEach(showField -> {\n                            String key = showField.getFieldAlias().toLowerCase();\n                            if (jsonObject.isNull(key)) {\n                                recordList.add(null);\n                            } else {\n                                if (showField.getDataType().equals(DataType.NUMBER)) {\n                                    recordList.add(jsonObject.getDouble(key));\n                                } else {\n                                    recordList.add(jsonObject.get(key));\n                                }\n                            }\n                        });\n                        csvPrinter.printRecord(recordList);\n                        recordList.clear();\n                    }\n                }\n                offset = offset + SQL_EXTRACTION_QUERY_LIMIT;\n                recordsRetrieved = recordsRetrieved + dbResultSetRows.size();\n                LOGGER.info(\"Retrieved {} records so far.\", recordsRetrieved);\n            } while (dbResultSetRows.size() == SQL_EXTRACTION_QUERY_LIMIT && !Thread.currentThread().isInterrupted());\n            csvFile.setNumRecords(recordsRetrieved);\n            LOGGER.info(\"Total {} records retrieved for this task.\", recordsRetrieved);\n            csvPrinter.flush();\n        } catch (Exception ex) {\n            LOGGER.error(\"Unable to process SQL extract! {}-{}\", ex.getMessage(), ex);\n            throw new DPSystemException(ex.getMessage(), ex);\n        } finally {\n            IOUtils.closeQuietly(csvPrinter);\n            if (connection != null) {\n                try {\n                    connection.close();\n                } catch (SQLException e) {\n                    LOGGER.warn(\"Could not close connection to: {}\", connectionParamPojo.getJdbcUrl());\n                }\n            }\n\n        }\n        return csvFile;\n    }\n\n    private static DBResultPojo executeQuery(Connection connection, String queryToExecute) {\n        Statement statement = null;\n        DBResultPojo dbResultPojo = new DBResultPojo();\n        try {\n            statement = connection.createStatement();\n            ResultSet resultSet = statement.executeQuery(queryToExecute);\n            dbResultPojo.setSucceded(true);\n            dbResultPojo.setResult(convertToJSON(resultSet));\n        } catch (Exception exception) {\n            dbResultPojo.setSucceded(false);\n            dbResultPojo.setCause(exception);\n            if (exception instanceof SQLException) {\n                dbResultPojo.setErrorCode(com.gainsight.services.utilities.datahighway.dhcommons.exception.ValidationCode.DB_ERROR);\n            } else if (exception instanceof IOException) {\n                dbResultPojo.setErrorCode(com.gainsight.services.utilities.datahighway.dhcommons.exception.ValidationCode.IO_ERROR);\n            } else {\n                dbResultPojo.setErrorCode(com.gainsight.services.utilities.datahighway.dhcommons.exception.ValidationCode.UNKNOWN_SERVER_ERROR);\n            }\n        } finally {\n            if (statement != null) {\n                try {\n                    statement.close();\n                } catch (SQLException e) {\n                    LOGGER.warn(\"Error while closing jdbc statement object \");\n                }\n            }\n        }\n        return dbResultPojo;\n    }\n\n    private static JSONArray convertToJSON(ResultSet resultSet) throws Exception {\n        JSONArray jsonArray = new JSONArray();\n        while (resultSet.next()) {\n            int columnCount = resultSet.getMetaData().getColumnCount();\n            JSONObject jsonObject = new JSONObject();\n            for (int i = 0; i < columnCount; ++i) {\n                Object object = resultSet.getObject(i + 1);\n                if (object == null) {\n                    object = JSONObject.NULL;\n                }\n                jsonObject.put(resultSet.getMetaData().getColumnLabel(i + 1).toLowerCase(), object);\n            }\n            jsonArray.put(jsonObject);\n        }\n        return jsonArray;\n    }\n\n    private static CsvFile getCsvFileForSQLExtract(ExternalTaskRequestContext externalTaskRequestContext) throws IOException {\n        String tempFilePath = DPUtils.getTempFilePath(externalTaskRequestContext.getTenantId(), externalTaskRequestContext.getJobId(), externalTaskRequestContext.getTaskId(), UUID.randomUUID().toString() + \".csv\");\n        File file = new File(tempFilePath);\n        Files.createDirectories(Paths.get(file.getParent()));\n        Files.createFile(Paths.get(file.getAbsolutePath()));\n\n        CsvFile csvFile = new CsvFile(tempFilePath);\n        csvFile.setFirstRecordHeader(true);\n        csvFile.setQuoteMode(QuoteMode.NON_NUMERIC);\n        return csvFile;\n    }\n\n    private static Connection getConnectionObject(ConnectionParamPojo connectionParamPojo) throws SQLException, ClassNotFoundException {\n        Properties properties = new Properties();\n        properties.setProperty(\"user\", connectionParamPojo.getUserName());\n        properties.setProperty(\"password\", connectionParamPojo.getPassword());\n        properties.setProperty(\"tcpKeepAlive\", Boolean.TRUE.toString());\n        Class.forName(\"com.microsoft.sqlserver.jdbc.SQLServerDriver\");\n        return DriverManager.getConnection(connectionParamPojo.getJdbcUrl(), properties);\n    }\n}\n"}
2025-05-13 21:01:32 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:01:32 [main] INFO  c.l.service.impl.BasicL3AgentService - Processed file: /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/code/dp_dynamic_tasks/mssql-extraction-task/src/main/java/com/gainsight/services/external/mssql/extraction/task/MsSqlExtractionTask.java with 10 chunks
2025-05-13 21:01:32 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:01:32 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:01:32 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"package com.gainsight.services.external.conf.file.reader.task;\n\n\nimport com.gainsight.services.dataprocessing.commons.pojo.DataType;\nimport com.gainsight.services.dataprocessing.commons.pojo.fields.FieldInfo;\nimport com.gainsight.services.dataprocessing.commons.properties.DeploymentProperties;\nimport com.gainsight.services.dataprocessing.dataprocessor.dagdataprocessor.pojo.ExternalTaskResult;\nimport com.gainsight.services.dataprocessing.dataprocessor.dagdataprocessor.pojo.TaskResult;\nimport com.gainsight.services.dataprocessing.external.task.ExternalTaskRequestContext;\nimport com.gainsight.services.dataprocessing.external.task.ExternalTaskUtil;\nimport org.apache.commons.lang3.StringUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.Collections;\n\n/**\n * @author sthammishetty on 04/05/20\n * <p>\n * ExternalTask to read config properties from classpath resource file [task.conf]. 'task.conf' is packaged along with the jar.\n *\n */\npublic class ExternalTask {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(ExternalTask.class);\n\n    public static void main(String[] args) {\n        executeTask(ExternalTaskUtil.getExternalTaskRequestContext());\n    }\n\n    private static void executeTask(ExternalTaskRequestContext externalTaskRequestContext) {\n\n        LOGGER.info(\"Hello World. This is DynamicTask\");\n        LOGGER.info(\"Reading properties from config file ['task.conf']\");\n        String fileName = DeploymentProperties.getDeploymentProperties().getValue(\"file.name\");\n        String sampleKeyValue = DeploymentProperties.getDeploymentProperties().getValue(\"sample.key\");\n\n        if (StringUtils.isNotBlank(fileName) && StringUtils.isNotBlank(sampleKeyValue)) {\n            LOGGER.info(\"Read fileName from conf file 'file.name' : \" + fileName);\n            LOGGER.info(\"Value of 'sample.key' : \" + sampleKeyValue);\n        } else {\n            throw new RuntimeException(\"Failed to read properties ['file.name', 'sample.key'] from conf file\");\n\n        }\n        FieldInfo fieldInfo = new FieldInfo();\n        fieldInfo.setName(\"dummy_column\");\n        fieldInfo.setDataType(DataType.STRING);\n        fieldInfo.setFieldAlias(fieldInfo.getName());\n        TaskResult taskResult = new TaskResult(Collections.singletonList(fieldInfo), null);\n        ExternalTaskUtil.saveExternalTaskResult(externalTaskRequestContext, new ExternalTaskResult(taskResult, true));\n    }\n}\n"}
2025-05-13 21:01:33 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:01:33 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:01:33 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:01:33 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    public static void main(String[] args) {\n        executeTask(ExternalTaskUtil.getExternalTaskRequestContext());\n    }\n"}
2025-05-13 21:01:34 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:01:34 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:01:34 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:01:34 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    private static void executeTask(ExternalTaskRequestContext externalTaskRequestContext) {\n\n        LOGGER.info(\"Hello World. This is DynamicTask\");\n        LOGGER.info(\"Reading properties from config file ['task.conf']\");\n        String fileName = DeploymentProperties.getDeploymentProperties().getValue(\"file.name\");\n        String sampleKeyValue = DeploymentProperties.getDeploymentProperties().getValue(\"sample.key\");\n\n        if (StringUtils.isNotBlank(fileName) && StringUtils.isNotBlank(sampleKeyValue)) {\n            LOGGER.info(\"Read fileName from conf file 'file.name' : \" + fileName);\n            LOGGER.info(\"Value of 'sample.key' : \" + sampleKeyValue);\n        } else {\n            throw new RuntimeException(\"Failed to read properties ['file.name', 'sample.key'] from conf file\");\n\n        }\n        FieldInfo fieldInfo = new FieldInfo();\n        fieldInfo.setName(\"dummy_column\");\n        fieldInfo.setDataType(DataType.STRING);\n        fieldInfo.setFieldAlias(fieldInfo.getName());\n        TaskResult taskResult = new TaskResult(Collections.singletonList(fieldInfo), null);\n        ExternalTaskUtil.saveExternalTaskResult(externalTaskRequestContext, new ExternalTaskResult(taskResult, true));\n    }\n"}
2025-05-13 21:01:36 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:01:36 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:01:36 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:01:36 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"public class ExternalTask {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(ExternalTask.class);\n\n    public static void main(String[] args) {\n        executeTask(ExternalTaskUtil.getExternalTaskRequestContext());\n    }\n\n    private static void executeTask(ExternalTaskRequestContext externalTaskRequestContext) {\n\n        LOGGER.info(\"Hello World. This is DynamicTask\");\n        LOGGER.info(\"Reading properties from config file ['task.conf']\");\n        String fileName = DeploymentProperties.getDeploymentProperties().getValue(\"file.name\");\n        String sampleKeyValue = DeploymentProperties.getDeploymentProperties().getValue(\"sample.key\");\n\n        if (StringUtils.isNotBlank(fileName) && StringUtils.isNotBlank(sampleKeyValue)) {\n            LOGGER.info(\"Read fileName from conf file 'file.name' : \" + fileName);\n            LOGGER.info(\"Value of 'sample.key' : \" + sampleKeyValue);\n        } else {\n            throw new RuntimeException(\"Failed to read properties ['file.name', 'sample.key'] from conf file\");\n\n        }\n        FieldInfo fieldInfo = new FieldInfo();\n        fieldInfo.setName(\"dummy_column\");\n        fieldInfo.setDataType(DataType.STRING);\n        fieldInfo.setFieldAlias(fieldInfo.getName());\n        TaskResult taskResult = new TaskResult(Collections.singletonList(fieldInfo), null);\n        ExternalTaskUtil.saveExternalTaskResult(externalTaskRequestContext, new ExternalTaskResult(taskResult, true));\n    }\n}\n"}
2025-05-13 21:01:37 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:01:37 [main] INFO  c.l.service.impl.BasicL3AgentService - Processed file: /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/code/dp_dynamic_tasks/conf-file-reader-task/src/main/java/com/gainsight/services/external/conf/file/reader/task/ExternalTask.java with 4 chunks
2025-05-13 21:01:37 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:01:37 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:01:37 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"package com.gainsight.services.external.too.many.open.file.task;\n\nimport com.gainsight.services.dataprocessing.commons.pojo.DataType;\nimport com.gainsight.services.dataprocessing.commons.pojo.fields.FieldInfo;\nimport com.gainsight.services.dataprocessing.dataprocessor.dagdataprocessor.pojo.ExternalTaskResult;\nimport com.gainsight.services.dataprocessing.dataprocessor.dagdataprocessor.pojo.TaskResult;\nimport com.gainsight.services.dataprocessing.external.task.ExternalTaskRequestContext;\nimport com.gainsight.services.dataprocessing.external.task.ExternalTaskUtil;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.UUID;\n\n/**\n * @author sthammishetty on 09/06/20\n * External task to test 'too many open files'.\n */\npublic class TooManyOpenFilesTask {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TooManyOpenFilesTask.class.getName());\n\n    public static void main(String[] args) {\n        executeTask(ExternalTaskUtil.getExternalTaskRequestContext());\n    }\n\n    private static void executeTask(ExternalTaskRequestContext externalTaskRequestContext) {\n\n        List<FileWriter> files = new ArrayList();\n        try {\n            File file = File.createTempFile(UUID.randomUUID().toString() + \"_dummy\", \".txt\");\n            FileWriter fileWriter;\n            int batchSize = 1000;\n            for (int i = 0; i < 5000; i++) {\n                try {\n                    fileWriter = new FileWriter(file);\n                    files.add(fileWriter);\n                    if (batchSize == 0) {\n                        try {\n                            Thread.sleep(1000);\n                        } catch (InterruptedException e) {\n                            LOGGER.error(e.getMessage(), e);\n                        }\n                        batchSize = 1000;\n                    }\n                    batchSize--;\n                } catch (Exception e) {\n                    LOGGER.error(\"error creating temp file {}\", e.getMessage(), e);\n                    throw new RuntimeException(e);\n                }\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n\n        FieldInfo fieldInfo = new FieldInfo();\n        fieldInfo.setName(\"dummy_column\");\n        fieldInfo.setDataType(DataType.STRING);\n        fieldInfo.setFieldAlias(fieldInfo.getName());\n        TaskResult taskResult = new TaskResult(Collections.singletonList(fieldInfo), null);\n        ExternalTaskUtil.saveExternalTaskResult(externalTaskRequestContext, new ExternalTaskResult(taskResult, true));\n    }\n}\n"}
2025-05-13 21:01:39 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:01:39 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:01:39 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:01:39 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    public static void main(String[] args) {\n        executeTask(ExternalTaskUtil.getExternalTaskRequestContext());\n    }\n"}
2025-05-13 21:01:40 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:01:40 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:01:40 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:01:40 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    private static void executeTask(ExternalTaskRequestContext externalTaskRequestContext) {\n\n        List<FileWriter> files = new ArrayList();\n        try {\n            File file = File.createTempFile(UUID.randomUUID().toString() + \"_dummy\", \".txt\");\n            FileWriter fileWriter;\n            int batchSize = 1000;\n            for (int i = 0; i < 5000; i++) {\n                try {\n                    fileWriter = new FileWriter(file);\n                    files.add(fileWriter);\n                    if (batchSize == 0) {\n                        try {\n                            Thread.sleep(1000);\n                        } catch (InterruptedException e) {\n                            LOGGER.error(e.getMessage(), e);\n                        }\n                        batchSize = 1000;\n                    }\n                    batchSize--;\n                } catch (Exception e) {\n                    LOGGER.error(\"error creating temp file {}\", e.getMessage(), e);\n                    throw new RuntimeException(e);\n                }\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n\n        FieldInfo fieldInfo = new FieldInfo();\n        fieldInfo.setName(\"dummy_column\");\n        fieldInfo.setDataType(DataType.STRING);\n        fieldInfo.setFieldAlias(fieldInfo.getName());\n        TaskResult taskResult = new TaskResult(Collections.singletonList(fieldInfo), null);\n        ExternalTaskUtil.saveExternalTaskResult(externalTaskRequestContext, new ExternalTaskResult(taskResult, true));\n    }\n"}
2025-05-13 21:01:41 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:01:41 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:01:41 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:01:41 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"public class TooManyOpenFilesTask {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TooManyOpenFilesTask.class.getName());\n\n    public static void main(String[] args) {\n        executeTask(ExternalTaskUtil.getExternalTaskRequestContext());\n    }\n\n    private static void executeTask(ExternalTaskRequestContext externalTaskRequestContext) {\n\n        List<FileWriter> files = new ArrayList();\n        try {\n            File file = File.createTempFile(UUID.randomUUID().toString() + \"_dummy\", \".txt\");\n            FileWriter fileWriter;\n            int batchSize = 1000;\n            for (int i = 0; i < 5000; i++) {\n                try {\n                    fileWriter = new FileWriter(file);\n                    files.add(fileWriter);\n                    if (batchSize == 0) {\n                        try {\n                            Thread.sleep(1000);\n                        } catch (InterruptedException e) {\n                            LOGGER.error(e.getMessage(), e);\n                        }\n                        batchSize = 1000;\n                    }\n                    batchSize--;\n                } catch (Exception e) {\n                    LOGGER.error(\"error creating temp file {}\", e.getMessage(), e);\n                    throw new RuntimeException(e);\n                }\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n\n        FieldInfo fieldInfo = new FieldInfo();\n        fieldInfo.setName(\"dummy_column\");\n        fieldInfo.setDataType(DataType.STRING);\n        fieldInfo.setFieldAlias(fieldInfo.getName());\n        TaskResult taskResult = new TaskResult(Collections.singletonList(fieldInfo), null);\n        ExternalTaskUtil.saveExternalTaskResult(externalTaskRequestContext, new ExternalTaskResult(taskResult, true));\n    }\n}\n"}
2025-05-13 21:01:43 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:01:43 [main] INFO  c.l.service.impl.BasicL3AgentService - Processed file: /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/code/dp_dynamic_tasks/too-many-open-files-task/src/main/java/com/gainsight/services/external/too/many/open/file/task/TooManyOpenFilesTask.java with 4 chunks
2025-05-13 21:01:43 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:01:43 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:01:43 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"package com.gainsight.services.external.commons;\n\nimport com.gainsight.services.dataprocessing.commons.properties.DeploymentProperties;\nimport com.gainsight.services.utilities.datahighway.dhcommons.logback.AbstractObfuscationTurboFilter;\nimport com.gainsight.services.utilities.datahighway.dhcommons.logback.DHLogObfuscationUtil;\nimport com.gainsight.services.utilities.datahighway.dhcommons.logback.pojo.DHOBFConfigProperties;\nimport com.gainsight.services.utilities.datahighway.dhcommons.pojo.ExpiryCache;\nimport com.gainsight.services.utilities.datahighway.dhcommons.utils.DHFeatureUtils;\nimport com.gainsight.services.utilities.datahighway.dhcommons.utils.DHUtils;\nimport com.gainsight.services.utilities.datahighway.dhcommons.utils.Precondition;\nimport com.google.common.collect.Lists;\nimport org.apache.commons.lang3.StringUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.slf4j.MDC;\n\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.regex.Pattern;\n\nimport static com.gainsight.services.dataprocessing.commons.constants.Constants.*;\nimport static com.gainsight.services.dataprocessing.commons.constants.Constants.WebConstants.FEATURE_CONFIG_EVALUATE_PATH;\nimport static com.gainsight.services.dataprocessing.commons.constants.Constants.WorkflowConstants.FEATURE_CONFIG_URL;\nimport static com.gainsight.services.utilities.datahighway.dhcommons.constants.DHConstants.DUMMY_STRING;\nimport static com.gainsight.services.utilities.datahighway.dhcommons.constants.DHConstants.ObfuscationConstants.GS_LOG_OBFUSCATION_CONFIG_PROPERTY_KEY;\nimport static com.gainsight.services.utilities.datahighway.dhcommons.constants.DHConstants.ObfuscationConstants.GS_LOG_OBFUSCATION_CONFIG_PROPS_CACHE_TTL_MILLIS;\nimport static com.gainsight.services.utilities.datahighway.dhcommons.constants.DHConstants.TENANT_ID_KEY;\nimport static com.gainsight.services.utilities.datahighway.dhcommons.exception.ValidationCode.GENERIC_SYSTEM_ERROR;\n\n/**\n * @author sabhishekh\n * Created On: 14/11/24\n * <p>\n * This class is exact replica of DPLogbackTurboFilter and it should be like that only.\n * Any changes done to original file should be maintained here too.\n * This was needed because separate thread pertaining to each individual dynamic jar was not taking original turbo filter file via external dependency.\n * We had to make the turbo filter class available in same repo where each dynamic tasks are being written.\n */\npublic class DPDynamicTaskTurboFilter extends AbstractObfuscationTurboFilter {\n\n    private static final Logger DPDTF = LoggerFactory.getLogger(\"DPDTF\");\n\n    // List of packages disabled for obfuscation(Corresponding to the individual repositories)\n    private static final List<String> packagesDisabledForObfuscation = Lists.newArrayList();\n    private static ExpiryCache<String, DHOBFConfigProperties> DH_OBF_CONFIG_PROPERTIES_EXPIRY_CACHE = null;\n\n    static {\n        packagesDisabledForObfuscation.add(\"DPDTF\");\n        packagesDisabledForObfuscation.add(\"com.gainsight.services.external.commons.DPDynamicTaskTurboFilter\");\n        packagesDisabledForObfuscation.add(\"com.gainsight.services.dataprocessing.commons.properties\");\n        packagesDisabledForObfuscation.add(\"com.gainsight.services.dataprocessing.commons.cryptography\");\n    }\n\n    /**\n     * Retrieves the list of packages enabled for obfuscation.\n     *\n     * @return List of package names enabled for obfuscation.\n     */\n    @Override\n    public List<String> getPackagesEnabledForObfuscation() {\n        return getDHOBFConfigProperties().getGsLogOBFPackagesEnabled();\n    }\n\n    /**\n     * Retrieves the list of packages disabled for obfuscation.\n     *\n     * @return List of package names disabled for obfuscation.\n     */\n    @Override\n    public List<String> getPackagesDisabledForObfuscation() {\n        List<String> packages = DHLogObfuscationUtil.disabledPackagesForObfuscation(getDHOBFConfigProperties());\n        packages.addAll(packagesDisabledForObfuscation);\n        return packages;\n    }\n\n    /**\n     * Retrieves the obfuscation patterns for the tenant.\n     *\n     * @return List of regex patterns for tenant obfuscation.\n     * <p>\n     * DHFeatureUtil is utility method which needs to be called by the respective repository to get the obfuscation patterns.\n     */\n    @Override\n    public List<Pattern> getTenantObfuscationPattern() {\n        try {\n            if (StringUtils.isBlank(MDC.get(TENANT_ID_KEY)) || MDC.get(TENANT_ID_KEY).equalsIgnoreCase(DUMMY_STRING)) {\n                return Collections.emptyList();\n            } else {\n                DHOBFConfigProperties dhobfConfigProperties = getDHOBFConfigProperties();\n                DHFeatureUtils dhFeatureUtils = DHFeatureUtils.getInstance(DeploymentProperties.getDeploymentProperties().getValue(FEATURE_CONFIG_URL),\n                        DeploymentProperties.getDeploymentProperties().getValue(FEATURE_CONFIG_EVALUATE_PATH, \"/v1/features/evaluate/\"),\n                        DeploymentProperties.getDeploymentProperties().getValue(FEATURE_CONFIG_ENVIRONMENT), DeploymentProperties.getDeploymentProperties().getValue(MDA_GAINSIGHT_B2B_SECRET),\n                        dhobfConfigProperties.getGsLogObfuscationFeatureVariationCacheExpiry(), dhobfConfigProperties.getGsLogObfuscationPatternCacheExpiry());\n                return dhFeatureUtils.getTenantLogObfuscationPatterns(MDC.get(TENANT_ID_KEY), MDC.get(REQUEST_ID_KEY));\n            }\n        } catch (Exception ex) {//NOSONAR\n            DPDTF.warn(\"[NO_OBF] Error in getting tenant obfuscation patterns: {}\", ex.getMessage(), ex);\n            return Collections.emptyList();\n        }\n    }\n\n    /**\n     * Checks if obfuscation is enabled in the application.\n     *\n     * @return true if obfuscation is enabled, false otherwise.\n     */\n    @Override\n    public boolean isObfuscationEnabledInApp() {\n        return getDHOBFConfigProperties().isGsLogOBFEnabled();\n    }\n\n    /**\n     * Checks if obfuscation metric logging is enabled.\n     *\n     * @return true if obfuscation metric logging is enabled, false otherwise.\n     */\n    @Override\n    public boolean isObfuscationMetricLogEnabled() {\n        return getDHOBFConfigProperties().isGsLogOBFEnableFilterMetricLog();\n    }\n\n    /**\n     * Retrieves the obfuscation configuration properties from dh_env_config.\n     *\n     * @return DHOBFConfigProperties object containing obfuscation configuration.\n     */\n    private DHOBFConfigProperties getDHOBFConfigProperties() {\n        try {\n            /*This is initialization block for the expiry cache which will happen once.\n            and since we already short-circuited if DeploymentProperties is not initialized, we can safely initialize the cache here.\n             */\n            if (Objects.isNull(DH_OBF_CONFIG_PROPERTIES_EXPIRY_CACHE)) {\n                DH_OBF_CONFIG_PROPERTIES_EXPIRY_CACHE = new ExpiryCache<>(DeploymentProperties.getDeploymentProperties().getLongValue(GS_LOG_OBFUSCATION_CONFIG_PROPS_CACHE_TTL_MILLIS, 60 * 60 * 1000));\n            }\n            //Checking in cache if property exists\n            if (Objects.nonNull(DH_OBF_CONFIG_PROPERTIES_EXPIRY_CACHE.get(GS_LOG_OBFUSCATION_CONFIG_PROPERTY_KEY))) {\n                return DH_OBF_CONFIG_PROPERTIES_EXPIRY_CACHE.get(GS_LOG_OBFUSCATION_CONFIG_PROPERTY_KEY);\n            }\n            //If not present in cache, fetching from DeploymentProperties and storing in cache\n            String configValue = DeploymentProperties.getDeploymentProperties().getValue(GS_LOG_OBFUSCATION_CONFIG_PROPERTY_KEY);\n            Precondition.isNotBlank(configValue, GENERIC_SYSTEM_ERROR, \"[NO_OBF] Obfuscation config is not present in dynamic app's config server\");\n            DHOBFConfigProperties dhobfConfigProperties = DHUtils.convertJsonToObject(configValue, DHOBFConfigProperties.class);\n            DH_OBF_CONFIG_PROPERTIES_EXPIRY_CACHE.put(GS_LOG_OBFUSCATION_CONFIG_PROPERTY_KEY, dhobfConfigProperties);\n            return dhobfConfigProperties;\n        } catch (Exception ex) {\n            //Ignoring the exception as we don't want to fail the application startup in cases when DeploymentProperties hasn't been initialized\n            DPDTF.warn(\"[NO_OBF] Error in getting DHOBFConfigProperties: {}\", ex.getMessage(), ex);\n        }\n        return new DHOBFConfigProperties();\n    }\n\n    /**\n     * Checks if class loading should be short-circuited where DeploymentProperties is yet to be initialized.\n     *\n     * @return true if class loading should be short-circuited, false otherwise.\n     */\n    @Override\n    public boolean shortCircuitClassLoad() {\n        try {\n            return DeploymentProperties.isPropertiesServiceInitialized();\n        } catch (Throwable throwable) {\n            return false;\n        }\n    }\n}\n"}
2025-05-13 21:01:44 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:01:44 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:01:44 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:01:44 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":" * We had to make the turbo filter class available in same repo where each dynamic tasks are being written.\n */\npublic class DPDynamicTaskTurboFilter extends AbstractObfuscationTurboFilter {\n"}
2025-05-13 21:01:45 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:01:45 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:01:45 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:01:45 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    public List<String> getPackagesEnabledForObfuscation() {\n        return getDHOBFConfigProperties().getGsLogOBFPackagesEnabled();\n    }\n"}
2025-05-13 21:01:47 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:01:47 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:01:47 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:01:47 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    public List<String> getPackagesDisabledForObfuscation() {\n        List<String> packages = DHLogObfuscationUtil.disabledPackagesForObfuscation(getDHOBFConfigProperties());\n        packages.addAll(packagesDisabledForObfuscation);\n        return packages;\n    }\n"}
2025-05-13 21:01:48 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:01:48 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:01:48 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:01:48 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    public List<Pattern> getTenantObfuscationPattern() {\n        try {\n            if (StringUtils.isBlank(MDC.get(TENANT_ID_KEY)) || MDC.get(TENANT_ID_KEY).equalsIgnoreCase(DUMMY_STRING)) {\n                return Collections.emptyList();\n            } else {\n                DHOBFConfigProperties dhobfConfigProperties = getDHOBFConfigProperties();\n                DHFeatureUtils dhFeatureUtils = DHFeatureUtils.getInstance(DeploymentProperties.getDeploymentProperties().getValue(FEATURE_CONFIG_URL),\n                        DeploymentProperties.getDeploymentProperties().getValue(FEATURE_CONFIG_EVALUATE_PATH, \"/v1/features/evaluate/\"),\n                        DeploymentProperties.getDeploymentProperties().getValue(FEATURE_CONFIG_ENVIRONMENT), DeploymentProperties.getDeploymentProperties().getValue(MDA_GAINSIGHT_B2B_SECRET),\n                        dhobfConfigProperties.getGsLogObfuscationFeatureVariationCacheExpiry(), dhobfConfigProperties.getGsLogObfuscationPatternCacheExpiry());\n                return dhFeatureUtils.getTenantLogObfuscationPatterns(MDC.get(TENANT_ID_KEY), MDC.get(REQUEST_ID_KEY));\n            }\n        } catch (Exception ex) {//NOSONAR\n            DPDTF.warn(\"[NO_OBF] Error in getting tenant obfuscation patterns: {}\", ex.getMessage(), ex);\n            return Collections.emptyList();\n        }\n    }\n"}
2025-05-13 21:01:49 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:01:49 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:01:49 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:01:49 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    public boolean isObfuscationEnabledInApp() {\n        return getDHOBFConfigProperties().isGsLogOBFEnabled();\n    }\n"}
2025-05-13 21:01:51 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:01:51 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:01:51 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:01:51 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    public boolean isObfuscationMetricLogEnabled() {\n        return getDHOBFConfigProperties().isGsLogOBFEnableFilterMetricLog();\n    }\n"}
2025-05-13 21:01:52 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:01:52 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:01:52 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:01:52 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    private DHOBFConfigProperties getDHOBFConfigProperties() {\n        try {\n            /*This is initialization block for the expiry cache which will happen once.\n            and since we already short-circuited if DeploymentProperties is not initialized, we can safely initialize the cache here.\n             */\n            if (Objects.isNull(DH_OBF_CONFIG_PROPERTIES_EXPIRY_CACHE)) {\n                DH_OBF_CONFIG_PROPERTIES_EXPIRY_CACHE = new ExpiryCache<>(DeploymentProperties.getDeploymentProperties().getLongValue(GS_LOG_OBFUSCATION_CONFIG_PROPS_CACHE_TTL_MILLIS, 60 * 60 * 1000));\n            }\n            //Checking in cache if property exists\n            if (Objects.nonNull(DH_OBF_CONFIG_PROPERTIES_EXPIRY_CACHE.get(GS_LOG_OBFUSCATION_CONFIG_PROPERTY_KEY))) {\n                return DH_OBF_CONFIG_PROPERTIES_EXPIRY_CACHE.get(GS_LOG_OBFUSCATION_CONFIG_PROPERTY_KEY);\n            }\n            //If not present in cache, fetching from DeploymentProperties and storing in cache\n            String configValue = DeploymentProperties.getDeploymentProperties().getValue(GS_LOG_OBFUSCATION_CONFIG_PROPERTY_KEY);\n            Precondition.isNotBlank(configValue, GENERIC_SYSTEM_ERROR, \"[NO_OBF] Obfuscation config is not present in dynamic app's config server\");\n            DHOBFConfigProperties dhobfConfigProperties = DHUtils.convertJsonToObject(configValue, DHOBFConfigProperties.class);\n            DH_OBF_CONFIG_PROPERTIES_EXPIRY_CACHE.put(GS_LOG_OBFUSCATION_CONFIG_PROPERTY_KEY, dhobfConfigProperties);\n            return dhobfConfigProperties;\n        } catch (Exception ex) {\n            //Ignoring the exception as we don't want to fail the application startup in cases when DeploymentProperties hasn't been initialized\n            DPDTF.warn(\"[NO_OBF] Error in getting DHOBFConfigProperties: {}\", ex.getMessage(), ex);\n        }\n        return new DHOBFConfigProperties();\n    }\n"}
2025-05-13 21:01:53 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:01:53 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:01:53 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:01:53 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"public class DPDynamicTaskTurboFilter extends AbstractObfuscationTurboFilter {\n\n    private static final Logger DPDTF = LoggerFactory.getLogger(\"DPDTF\");\n\n    // List of packages disabled for obfuscation(Corresponding to the individual repositories)\n    private static final List<String> packagesDisabledForObfuscation = Lists.newArrayList();\n    private static ExpiryCache<String, DHOBFConfigProperties> DH_OBF_CONFIG_PROPERTIES_EXPIRY_CACHE = null;\n\n    static {\n        packagesDisabledForObfuscation.add(\"DPDTF\");\n        packagesDisabledForObfuscation.add(\"com.gainsight.services.external.commons.DPDynamicTaskTurboFilter\");\n        packagesDisabledForObfuscation.add(\"com.gainsight.services.dataprocessing.commons.properties\");\n        packagesDisabledForObfuscation.add(\"com.gainsight.services.dataprocessing.commons.cryptography\");\n    }\n\n    /**\n     * Retrieves the list of packages enabled for obfuscation.\n     *\n     * @return List of package names enabled for obfuscation.\n     */\n    @Override\n    public List<String> getPackagesEnabledForObfuscation() {\n        return getDHOBFConfigProperties().getGsLogOBFPackagesEnabled();\n    }\n\n    /**\n     * Retrieves the list of packages disabled for obfuscation.\n     *\n     * @return List of package names disabled for obfuscation.\n     */\n    @Override\n    public List<String> getPackagesDisabledForObfuscation() {\n        List<String> packages = DHLogObfuscationUtil.disabledPackagesForObfuscation(getDHOBFConfigProperties());\n        packages.addAll(packagesDisabledForObfuscation);\n        return packages;\n    }\n\n    /**\n     * Retrieves the obfuscation patterns for the tenant.\n     *\n     * @return List of regex patterns for tenant obfuscation.\n     * <p>\n     * DHFeatureUtil is utility method which needs to be called by the respective repository to get the obfuscation patterns.\n     */\n    @Override\n    public List<Pattern> getTenantObfuscationPattern() {\n        try {\n            if (StringUtils.isBlank(MDC.get(TENANT_ID_KEY)) || MDC.get(TENANT_ID_KEY).equalsIgnoreCase(DUMMY_STRING)) {\n                return Collections.emptyList();\n            } else {\n                DHOBFConfigProperties dhobfConfigProperties = getDHOBFConfigProperties();\n                DHFeatureUtils dhFeatureUtils = DHFeatureUtils.getInstance(DeploymentProperties.getDeploymentProperties().getValue(FEATURE_CONFIG_URL),\n                        DeploymentProperties.getDeploymentProperties().getValue(FEATURE_CONFIG_EVALUATE_PATH, \"/v1/features/evaluate/\"),\n                        DeploymentProperties.getDeploymentProperties().getValue(FEATURE_CONFIG_ENVIRONMENT), DeploymentProperties.getDeploymentProperties().getValue(MDA_GAINSIGHT_B2B_SECRET),\n                        dhobfConfigProperties.getGsLogObfuscationFeatureVariationCacheExpiry(), dhobfConfigProperties.getGsLogObfuscationPatternCacheExpiry());\n                return dhFeatureUtils.getTenantLogObfuscationPatterns(MDC.get(TENANT_ID_KEY), MDC.get(REQUEST_ID_KEY));\n            }\n        } catch (Exception ex) {//NOSONAR\n            DPDTF.warn(\"[NO_OBF] Error in getting tenant obfuscation patterns: {}\", ex.getMessage(), ex);\n            return Collections.emptyList();\n        }\n    }\n\n    /**\n     * Checks if obfuscation is enabled in the application.\n     *\n     * @return true if obfuscation is enabled, false otherwise.\n     */\n    @Override\n    public boolean isObfuscationEnabledInApp() {\n        return getDHOBFConfigProperties().isGsLogOBFEnabled();\n    }\n\n    /**\n     * Checks if obfuscation metric logging is enabled.\n     *\n     * @return true if obfuscation metric logging is enabled, false otherwise.\n     */\n    @Override\n    public boolean isObfuscationMetricLogEnabled() {\n        return getDHOBFConfigProperties().isGsLogOBFEnableFilterMetricLog();\n    }\n\n    /**\n     * Retrieves the obfuscation configuration properties from dh_env_config.\n     *\n     * @return DHOBFConfigProperties object containing obfuscation configuration.\n     */\n    private DHOBFConfigProperties getDHOBFConfigProperties() {\n        try {\n            /*This is initialization block for the expiry cache which will happen once.\n            and since we already short-circuited if DeploymentProperties is not initialized, we can safely initialize the cache here.\n             */\n            if (Objects.isNull(DH_OBF_CONFIG_PROPERTIES_EXPIRY_CACHE)) {\n                DH_OBF_CONFIG_PROPERTIES_EXPIRY_CACHE = new ExpiryCache<>(DeploymentProperties.getDeploymentProperties().getLongValue(GS_LOG_OBFUSCATION_CONFIG_PROPS_CACHE_TTL_MILLIS, 60 * 60 * 1000));\n            }\n            //Checking in cache if property exists\n            if (Objects.nonNull(DH_OBF_CONFIG_PROPERTIES_EXPIRY_CACHE.get(GS_LOG_OBFUSCATION_CONFIG_PROPERTY_KEY))) {\n                return DH_OBF_CONFIG_PROPERTIES_EXPIRY_CACHE.get(GS_LOG_OBFUSCATION_CONFIG_PROPERTY_KEY);\n            }\n            //If not present in cache, fetching from DeploymentProperties and storing in cache\n            String configValue = DeploymentProperties.getDeploymentProperties().getValue(GS_LOG_OBFUSCATION_CONFIG_PROPERTY_KEY);\n            Precondition.isNotBlank(configValue, GENERIC_SYSTEM_ERROR, \"[NO_OBF] Obfuscation config is not present in dynamic app's config server\");\n            DHOBFConfigProperties dhobfConfigProperties = DHUtils.convertJsonToObject(configValue, DHOBFConfigProperties.class);\n            DH_OBF_CONFIG_PROPERTIES_EXPIRY_CACHE.put(GS_LOG_OBFUSCATION_CONFIG_PROPERTY_KEY, dhobfConfigProperties);\n            return dhobfConfigProperties;\n        } catch (Exception ex) {\n            //Ignoring the exception as we don't want to fail the application startup in cases when DeploymentProperties hasn't been initialized\n            DPDTF.warn(\"[NO_OBF] Error in getting DHOBFConfigProperties: {}\", ex.getMessage(), ex);\n        }\n        return new DHOBFConfigProperties();\n    }\n\n    /**\n     * Checks if class loading should be short-circuited where DeploymentProperties is yet to be initialized.\n"}
2025-05-13 21:01:55 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:01:55 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:01:55 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:01:55 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"     * Checks if class loading should be short-circuited where DeploymentProperties is yet to be initialized.\n     *\n     * @return true if class loading should be short-circuited, false otherwise.\n"}
2025-05-13 21:01:56 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:01:56 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:01:56 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:01:56 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    public boolean shortCircuitClassLoad() {\n        try {\n            return DeploymentProperties.isPropertiesServiceInitialized();\n        } catch (Throwable throwable) {\n            return false;\n        }\n    }\n"}
2025-05-13 21:01:57 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:01:57 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:01:57 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:01:57 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"     * @return true if class loading should be short-circuited, false otherwise.\n     */\n    @Override\n    public boolean shortCircuitClassLoad() {\n        try {\n            return DeploymentProperties.isPropertiesServiceInitialized();\n        } catch (Throwable throwable) {\n            return false;\n        }\n    }\n}\n"}
2025-05-13 21:01:59 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:01:59 [main] INFO  c.l.service.impl.BasicL3AgentService - Processed file: /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/code/dp_dynamic_tasks/dp-dynamic-commons/src/main/java/com/gainsight/services/external/commons/DPDynamicTaskTurboFilter.java with 12 chunks
2025-05-13 21:01:59 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:01:59 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:01:59 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"package com.gainsight.service.external.placeholder.task;\n\nimport com.gainsight.services.dataprocessing.commons.exception.DPSystemException;\nimport com.gainsight.services.dataprocessing.commons.pojo.workflow.DPWorkflowTaskDetails;\nimport com.gainsight.services.dataprocessing.dataprocessor.dagdataprocessor.pojo.ExternalTaskResult;\nimport com.gainsight.services.dataprocessing.dataprocessor.dagdataprocessor.pojo.S3OutputDirType;\nimport com.gainsight.services.dataprocessing.dataprocessor.dagdataprocessor.pojo.TaskResult;\nimport com.gainsight.services.dataprocessing.dataprocessor.dagdataprocessor.utils.DbApiUtil;\nimport com.gainsight.services.dataprocessing.external.task.ExternalTaskRequestContext;\nimport com.gainsight.services.dataprocessing.external.task.ExternalTaskUtil;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport static com.gainsight.services.dataprocessing.commons.pojo.workflow.WorkflowJobStatus.SUCCESS;\nimport static com.gainsight.services.dataprocessing.commons.utils.DPUtils.msg;\n\n/**\n * @author sthammishetty on 26/03/20\n */\npublic class PlaceholderTask {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(PlaceholderTask.class);\n\n    public static void main(String[] args) {\n        executeTask(ExternalTaskUtil.getExternalTaskRequestContext());\n    }\n\n    private static void executeTask(ExternalTaskRequestContext externalTaskRequestContext) {\n        String taskId = externalTaskRequestContext.getTaskId();\n\n        String primaryJobId = externalTaskRequestContext.getPrimaryJobId();\n        DPWorkflowTaskDetails taskDetailsFromDB = DbApiUtil.getTaskDetailsWithPrimaryJobFromDB(primaryJobId, taskId);\n        if (!taskDetailsFromDB.getTaskStatus().equals(SUCCESS.name())) {\n            String message = msg(\"Task with taskId {} in job with primaryJobId {} is not in SUCCESS state, current state of this task is {}, can not continue with this execution.\", taskId, primaryJobId, taskDetailsFromDB.getTaskStatus());\n            LOGGER.error(message);\n            throw new DPSystemException(message);\n        }\n\n        TaskResult taskResult = new TaskResult(ExternalTaskUtil.getS3OutputFilePath(externalTaskRequestContext, S3OutputDirType.INTERNAL), taskDetailsFromDB.getRecordCount(), null, null);\n        ExternalTaskUtil.saveExternalTaskResult(externalTaskRequestContext, new ExternalTaskResult(taskResult));\n    }\n\n}\n"}
2025-05-13 21:02:00 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:02:00 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:02:00 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:02:00 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    public static void main(String[] args) {\n        executeTask(ExternalTaskUtil.getExternalTaskRequestContext());\n    }\n"}
2025-05-13 21:02:02 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:02:02 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:02:02 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:02:02 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    private static void executeTask(ExternalTaskRequestContext externalTaskRequestContext) {\n        String taskId = externalTaskRequestContext.getTaskId();\n\n        String primaryJobId = externalTaskRequestContext.getPrimaryJobId();\n        DPWorkflowTaskDetails taskDetailsFromDB = DbApiUtil.getTaskDetailsWithPrimaryJobFromDB(primaryJobId, taskId);\n        if (!taskDetailsFromDB.getTaskStatus().equals(SUCCESS.name())) {\n            String message = msg(\"Task with taskId {} in job with primaryJobId {} is not in SUCCESS state, current state of this task is {}, can not continue with this execution.\", taskId, primaryJobId, taskDetailsFromDB.getTaskStatus());\n            LOGGER.error(message);\n            throw new DPSystemException(message);\n        }\n\n        TaskResult taskResult = new TaskResult(ExternalTaskUtil.getS3OutputFilePath(externalTaskRequestContext, S3OutputDirType.INTERNAL), taskDetailsFromDB.getRecordCount(), null, null);\n        ExternalTaskUtil.saveExternalTaskResult(externalTaskRequestContext, new ExternalTaskResult(taskResult));\n    }\n"}
2025-05-13 21:02:03 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:02:03 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:02:03 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:02:03 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"public class PlaceholderTask {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(PlaceholderTask.class);\n\n    public static void main(String[] args) {\n        executeTask(ExternalTaskUtil.getExternalTaskRequestContext());\n    }\n\n    private static void executeTask(ExternalTaskRequestContext externalTaskRequestContext) {\n        String taskId = externalTaskRequestContext.getTaskId();\n\n        String primaryJobId = externalTaskRequestContext.getPrimaryJobId();\n        DPWorkflowTaskDetails taskDetailsFromDB = DbApiUtil.getTaskDetailsWithPrimaryJobFromDB(primaryJobId, taskId);\n        if (!taskDetailsFromDB.getTaskStatus().equals(SUCCESS.name())) {\n            String message = msg(\"Task with taskId {} in job with primaryJobId {} is not in SUCCESS state, current state of this task is {}, can not continue with this execution.\", taskId, primaryJobId, taskDetailsFromDB.getTaskStatus());\n            LOGGER.error(message);\n            throw new DPSystemException(message);\n        }\n\n        TaskResult taskResult = new TaskResult(ExternalTaskUtil.getS3OutputFilePath(externalTaskRequestContext, S3OutputDirType.INTERNAL), taskDetailsFromDB.getRecordCount(), null, null);\n        ExternalTaskUtil.saveExternalTaskResult(externalTaskRequestContext, new ExternalTaskResult(taskResult));\n    }\n\n}\n"}
2025-05-13 21:02:04 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:02:04 [main] INFO  c.l.service.impl.BasicL3AgentService - Processed file: /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/code/dp_dynamic_tasks/placeholder-task/src/main/java/com/gainsight/service/external/placeholder/task/PlaceholderTask.java with 4 chunks
2025-05-13 21:02:04 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:02:04 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:02:04 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"package com.gainsight.services.external.mysql.extraction.task;\n\nimport com.fasterxml.jackson.core.type.TypeReference;\nimport com.gainsight.services.datahighway.storage.db.commons.pojo.ConnectionParamPojo;\nimport com.gainsight.services.datahighway.storage.db.commons.pojo.DBResultPojo;\nimport com.gainsight.services.dataprocessing.commons.audit.AuditMetadata;\nimport com.gainsight.services.dataprocessing.commons.cryptography.CryptUtil;\nimport com.gainsight.services.dataprocessing.commons.exception.DPSystemException;\nimport com.gainsight.services.dataprocessing.commons.exception.ValidationCode;\nimport com.gainsight.services.dataprocessing.commons.pojo.fields.FieldInfo;\nimport com.gainsight.services.dataprocessing.commons.pojo.workflow.DPWorkflowJobDetailsDTO;\nimport com.gainsight.services.dataprocessing.commons.proxy.mda.CustomerCurrencyDTO;\nimport com.gainsight.services.dataprocessing.commons.system.CsvFile;\nimport com.gainsight.services.dataprocessing.commons.system.Precondition;\nimport com.gainsight.services.dataprocessing.commons.utils.DPUtils;\nimport com.gainsight.services.dataprocessing.dataprocessor.dagdataprocessor.pojo.ExternalExtractionTaskResult;\nimport com.gainsight.services.dataprocessing.dataprocessor.dagdataprocessor.pojo.TaskResult;\nimport com.gainsight.services.dataprocessing.dataprocessor.dagdataprocessor.utils.CustomerCurrencyUtil;\nimport com.gainsight.services.dataprocessing.external.task.ExternalTaskRequestContext;\nimport com.gainsight.services.dataprocessing.external.task.ExternalTaskUtil;\nimport com.gainsight.services.utilities.datahighway.dhcommons.enums.datatype.DataType;\nimport com.gainsight.services.utilities.datahighway.dhcommons.pojo.account.UDMAccountType;\nimport com.gainsight.services.utilities.datahighway.dhcommons.pojo.base.connection.ConnectorType;\nimport com.gainsight.services.utilities.datahighway.dhcommons.pojo.base.connection.RelationalDBConnectionDetail;\nimport com.gainsight.services.utilities.datahighway.dhcommons.pojo.query.QuerySourceType;\nimport com.gainsight.services.utilities.datahighway.dhquerybuilder.builders.FreeFormQueryBuilder;\nimport com.gainsight.services.utilities.datahighway.dhquerybuilder.constructs.query.QueryBuilderResponse;\nimport com.gainsight.services.utilities.datahighway.dhquerybuilder.constructs.query.SQLQueryInfo;\nimport com.gainsight.services.utilities.datahighway.dhquerybuilder.helpers.SqlQueryBuilderHelper;\nimport com.mysql.cj.jdbc.AbandonedConnectionCleanupThread;\nimport org.apache.commons.collections.CollectionUtils;\nimport org.apache.commons.csv.CSVFormat;\nimport org.apache.commons.csv.CSVPrinter;\nimport org.apache.commons.csv.QuoteMode;\nimport org.apache.commons.io.IOUtils;\nimport org.json.JSONArray;\nimport org.json.JSONObject;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.sql.*;\nimport java.util.*;\n\nimport static com.gainsight.services.dataprocessing.commons.audit.AuditMetadata.newInstance;\nimport static com.gainsight.services.dataprocessing.commons.constants.Constants.WorkflowConstants.SQL_EXTRACTION_DETAILS_KEY;\nimport static com.gainsight.services.dataprocessing.commons.utils.DPUtils.convertJsonToObject;\nimport static com.gainsight.services.dataprocessing.commons.utils.DPUtils.msg;\n\n/**\n * Sample ExternalTask implementation for mysql extraction  {@link com.gainsight.services.dataprocessing.commons.pojo.DPTaskType#EXTERNALTASK }\n */\npublic class MySqlExtractionTask {\n    private static final Logger LOGGER = LoggerFactory.getLogger(MySqlExtractionTask.class);\n    private static final int SQL_EXTRACTION_QUERY_LIMIT = 10000;\n\n    public static void main(String[] args) {\n        executeTask(ExternalTaskUtil.getExternalTaskRequestContext());\n    }\n\n    private static void executeTask(ExternalTaskRequestContext externalTaskRequestContext) {\n        ExternalExtractionTaskResult externalExtractionTaskResult = null;\n        try {\n            Map<String, Object> systemProperties = externalTaskRequestContext.getWorkflowSystemProperties();\n            String jobId = externalTaskRequestContext.getJobId();\n\n            //Get workflowJobDetails of given jobId\n            DPWorkflowJobDetailsDTO workflowJobDetails = externalTaskRequestContext.getWorkflowJobDetails();\n            UDMAccountType connectorType = null;\n            RelationalDBConnectionDetail relationalDBConnectionDetail = null;\n            Map<String, String> metaData = externalTaskRequestContext.getMetaData();\n            SQLQueryInfo sqlQueryInfo = convertJsonToObject(metaData.get(SQL_EXTRACTION_DETAILS_KEY), SQLQueryInfo.class);\n            Precondition.isNotNull(sqlQueryInfo, ValidationCode.GENERIC_SYSTEM_ERROR, \"Sql Extraction details cannot be empty. Missing extractionDetails information in task metadata\");\n            String mdaBaseUrl = Objects.nonNull(workflowJobDetails.getConfigSourceUrl()) ? workflowJobDetails.getConfigSourceUrl() : workflowJobDetails.getCallbackUrl();\n            String taskId = externalTaskRequestContext.getTaskId();\n            AuditMetadata auditMetadata = newInstance(workflowJobDetails.getTenantId(), workflowJobDetails.getJobId(), workflowJobDetails.getExternalId(), taskId, externalTaskRequestContext.getTaskName());\n\n            if (sqlQueryInfo.getConnectionDetail() instanceof RelationalDBConnectionDetail) {\n                relationalDBConnectionDetail = (RelationalDBConnectionDetail) sqlQueryInfo.getConnectionDetail();\n                connectorType = UDMAccountType.valueOf(relationalDBConnectionDetail.getType());\n            } else {\n                throw new DPSystemException(\"Please provide either valid MySql ConnectionInfo \");\n            }\n\n            if (connectorType == null || !UDMAccountType.MYSQL.equals(connectorType))\n                throw new DPSystemException(msg(\"Invalid ConnectorType :{}. Only Supports MySql ConnectorType.\", connectorType));\n\n            List<FieldInfo> headers = DPUtils.convertJsonToObject(DPUtils.convertObjectToJson(sqlQueryInfo.getShowFields()), new TypeReference<List<FieldInfo>>() {\n            });\n            CsvFile csvFile = executeQuery(systemProperties, sqlQueryInfo, relationalDBConnectionDetail, externalTaskRequestContext);\n\n            //Creating instance of TaskResult\n            TaskResult taskResult = new TaskResult(headers, null);\n            char delimiter = csvFile.getDelimiter() != null ? csvFile.getDelimiter().charAt(0) : null;\n\n            // Creating instance of ExternalExtractionTaskResult\n            Map<String, CustomerCurrencyDTO> currencyConversionMap = null;\n            if (DPUtils.isCurrencyConversionMapRequired(headers)) {\n                currencyConversionMap = CustomerCurrencyUtil.getCustomerCurrencyConversionMap(mdaBaseUrl, auditMetadata, true);\n            }\n            //If no csvRecord parsing handler is added, DefaultCsvRecordParsingHandler is set for parsing each csvRecord.\n            externalExtractionTaskResult = new ExternalExtractionTaskResult.ExternalExtractionTaskResultBuilder()\n                    .setWithHeader(csvFile.getHeaders() != null)\n                    .setDelimiter(delimiter)\n                    .setTaskResult(taskResult)\n                    .setCurrencyConversionMap(currencyConversionMap)\n                    .setExtractedFiles(Collections.singletonList(csvFile.getAbsolutePath()))\n                    .build();\n\n            //Saving externalTask Result.\n            saveExtractionTaskResult(workflowJobDetails.getTenantId(), jobId, taskId, externalExtractionTaskResult);\n        } catch (Exception ex) {\n            LOGGER.error(\"Exception while executing externalTask {}-{}\", ex.getMessage(), ex);\n            throw new DPSystemException(ex.getMessage(), ex);\n\n        }\n    }\n\n    private static void saveExtractionTaskResult(String tenantId, String jobId, String taskId, ExternalExtractionTaskResult taskResult) {\n        ExternalTaskUtil.saveExternalTaskResult(tenantId, jobId, taskId, taskResult);\n    }\n\n    private static CsvFile executeQuery(Map<String, Object> workflowSystemProperties, SQLQueryInfo sqlQueryInfo, RelationalDBConnectionDetail dbConnectionDetail, ExternalTaskRequestContext externalTaskRequestContext) {\n        CsvFile csvFile = null;\n        try {\n            QueryBuilderResponse mysqlExtract = new FreeFormQueryBuilder().with(sqlQueryInfo)\n                    .withQueryBuilderHelper(new SqlQueryBuilderHelper(ConnectorType.MYSQL))\n                    .withQuerySourceType(QuerySourceType.SQL)\n                    .withSystemProperties(workflowSystemProperties)\n                    .withNullLastInOrderByClause(false).build();\n            String mySqlExtractQuery = mysqlExtract.getQuery();\n            LOGGER.info(\"MySql Extract Query: {}\", mySqlExtractQuery);\n            String connectionUrl = \"jdbc:mysql://\" + CryptUtil.decrypt(dbConnectionDetail.getHost()) + \":\" + CryptUtil.decrypt(dbConnectionDetail.getPort()) + \"/\" + CryptUtil.decrypt(dbConnectionDetail.getDataBaseName());\n            ConnectionParamPojo connectionParamPojo = new ConnectionParamPojo(connectionUrl, CryptUtil.decrypt(dbConnectionDetail.getUser()), CryptUtil.decrypt(dbConnectionDetail.getPwd()), 1, null, dbConnectionDetail.isSslEnabled());\n            csvFile = executeQuery(connectionParamPojo, mySqlExtractQuery, sqlQueryInfo, externalTaskRequestContext);\n        } catch (Exception ex) {\n            LOGGER.error(\"{}-{}\", ex.getMessage(), ex);\n            throw new DPSystemException(ex.getMessage(), ex);\n        }\n        return csvFile;\n    }\n\n    private static CsvFile executeQuery(ConnectionParamPojo connectionParamPojo, String query, SQLQueryInfo sqlQueryInfo, ExternalTaskRequestContext externalTaskRequestContext) throws IOException {\n        int offset = 0;\n        int recordsRetrieved = 0;\n        Connection connection = null;\n        CsvFile csvFile = null;\n        CSVPrinter csvPrinter = null;\n        try {\n            csvFile = getCsvFileForSQLExtract(externalTaskRequestContext);\n            List<String> headers = new ArrayList<>();\n            sqlQueryInfo.getShowFields().forEach(showField -> headers.add(showField.getFieldAlias()));\n            csvFile.setHeaders(headers);\n            csvPrinter = new CSVPrinter(new BufferedWriter(new FileWriter(csvFile)), CSVFormat.DEFAULT.withQuoteMode(QuoteMode.NON_NUMERIC).withHeader(headers.toArray(new String[headers.size()])));\n            connection = getConnectionObject(connectionParamPojo);\n            List<JSONObject> dbResultSetRows = new ArrayList<>();\n            do {\n                dbResultSetRows.clear();\n                String queryToExecute = query.trim() + \" limit \" + offset + \", \" + SQL_EXTRACTION_QUERY_LIMIT;\n                DBResultPojo dbResult = executeQuery(connection, queryToExecute);\n                if (!dbResult.isSucceded()) {\n                    throw new DPSystemException(msg(\"Query execution failed because of: {}\", dbResult.getCause().getMessage()));\n                }\n                JSONArray resultData = (JSONArray) dbResult.getResult();\n                for (int i = 0; i < resultData.length(); i++) {\n                    dbResultSetRows.add(resultData.getJSONObject(i));\n                }\n                List<Object> recordList = new ArrayList<>();\n                if (CollectionUtils.isNotEmpty(dbResultSetRows)) {\n                    for (JSONObject jsonObject : dbResultSetRows) {\n                        sqlQueryInfo.getShowFields().forEach(showField -> {\n                            String key = showField.getFieldAlias().toLowerCase();\n                            if (jsonObject.isNull(key)) {\n                                recordList.add(null);\n                            } else {\n                                if (showField.getDataType().equals(DataType.NUMBER)) {\n                                    recordList.add(jsonObject.getDouble(key));\n                                } else {\n                                    recordList.add(jsonObject.get(key));\n                                }\n                            }\n                        });\n                        csvPrinter.printRecord(recordList);\n                        recordList.clear();\n                    }\n                }\n                offset = offset + SQL_EXTRACTION_QUERY_LIMIT;\n                recordsRetrieved = recordsRetrieved + dbResultSetRows.size();\n                LOGGER.info(\"Retrieved {} records so far.\", recordsRetrieved);\n            } while (dbResultSetRows.size() == SQL_EXTRACTION_QUERY_LIMIT && !Thread.currentThread().isInterrupted());\n            csvFile.setNumRecords(recordsRetrieved);\n            LOGGER.info(\"Total {} records retrieved for this task.\", recordsRetrieved);\n            csvPrinter.flush();\n        } catch (Exception ex) {\n            LOGGER.error(\"Unable to process SQL extract! {}-{}\", ex.getMessage(), ex);\n            throw new DPSystemException(ex.getMessage(), ex);\n        } finally {\n            IOUtils.closeQuietly(csvPrinter);\n            if (connection != null) {\n                try {\n                    connection.close();\n                } catch (SQLException e) {\n                    LOGGER.warn(\"Could not close connection to: {}\", connectionParamPojo.getJdbcUrl());\n                }\n            }\n\n            /**\n             * Has to explicitly shutdown AbandonedConnectionCleanupThread to avoid memory leak.\n             * Memory Leak:\n             *      Static block inside @see AbandonedConnectionCleanupThread class is spawning a new thread , which is holding a reference to the current classLoader object.\n             * @see AbandonedConnectionCleanupThread#checkedShutdown() explictly shoutdowns the executorService that created the thread, thereby removing the reference to current classLoader.\n             */\n            AbandonedConnectionCleanupThread.checkedShutdown();\n            Enumeration<Driver> drivers = DriverManager.getDrivers();\n            while (drivers.hasMoreElements()) {\n                Driver driver = drivers.nextElement();\n                if (driver.getClass().equals(com.mysql.cj.jdbc.Driver.class)) {\n                    try {\n                        DriverManager.deregisterDriver(driver);\n                    } catch (SQLException e) {\n                        LOGGER.error(\"Failed to deregister Driver : {}\", driver.getClass().getName());\n                    }\n                    break;\n                }\n            }\n        }\n        return csvFile;\n    }\n\n    private static DBResultPojo executeQuery(Connection connection, String queryToExecute) {\n        Statement statement = null;\n        DBResultPojo dbResultPojo = new DBResultPojo();\n        try {\n            statement = connection.createStatement();\n            ResultSet resultSet = statement.executeQuery(queryToExecute);\n            dbResultPojo.setSucceded(true);\n            dbResultPojo.setResult(convertToJSON(resultSet));\n        } catch (Exception exception) {\n            dbResultPojo.setSucceded(false);\n            dbResultPojo.setCause(exception);\n            if (exception instanceof SQLException) {\n                dbResultPojo.setErrorCode(com.gainsight.services.utilities.datahighway.dhcommons.exception.ValidationCode.DB_ERROR);\n            } else if (exception instanceof IOException) {\n                dbResultPojo.setErrorCode(com.gainsight.services.utilities.datahighway.dhcommons.exception.ValidationCode.IO_ERROR);\n            } else {\n                dbResultPojo.setErrorCode(com.gainsight.services.utilities.datahighway.dhcommons.exception.ValidationCode.UNKNOWN_SERVER_ERROR);\n            }\n        } finally {\n            if (statement != null) {\n                try {\n                    statement.close();\n                } catch (SQLException e) {\n                    LOGGER.warn(\"Error while closing jdbc statement object \");\n                }\n            }\n        }\n        return dbResultPojo;\n    }\n\n    private static JSONArray convertToJSON(ResultSet resultSet) throws Exception {\n        JSONArray jsonArray = new JSONArray();\n        while (resultSet.next()) {\n            int columnCount = resultSet.getMetaData().getColumnCount();\n            JSONObject jsonObject = new JSONObject();\n            for (int i = 0; i < columnCount; ++i) {\n                Object object = resultSet.getObject(i + 1);\n                if (object == null) {\n                    object = JSONObject.NULL;\n                }\n                jsonObject.put(resultSet.getMetaData().getColumnLabel(i + 1).toLowerCase(), object);\n            }\n            jsonArray.put(jsonObject);\n        }\n        return jsonArray;\n    }\n\n    private static CsvFile getCsvFileForSQLExtract(ExternalTaskRequestContext externalTaskRequestContext) throws IOException {\n        String tempFilePath = DPUtils.getTempFilePath(externalTaskRequestContext.getTenantId(), externalTaskRequestContext.getJobId(), externalTaskRequestContext.getTaskId(), UUID.randomUUID().toString() + \".csv\");\n        File file = new File(tempFilePath);\n        Files.createDirectories(Paths.get(file.getParent()));\n        Files.createFile(Paths.get(file.getAbsolutePath()));\n\n        CsvFile csvFile = new CsvFile(tempFilePath);\n        csvFile.setFirstRecordHeader(true);\n        csvFile.setQuoteMode(QuoteMode.NON_NUMERIC);\n        return csvFile;\n    }\n\n    private static Connection getConnectionObject(ConnectionParamPojo connectionParamPojo) throws SQLException, ClassNotFoundException {\n        Properties properties = new Properties();\n        properties.setProperty(\"user\", connectionParamPojo.getUserName());\n        properties.setProperty(\"password\", connectionParamPojo.getPassword());\n        properties.setProperty(\"tcpKeepAlive\", Boolean.TRUE.toString());\n        Class.forName(\"com.mysql.jdbc.Driver\");\n        return DriverManager.getConnection(connectionParamPojo.getJdbcUrl(), properties);\n    }\n}"}
2025-05-13 21:02:06 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:02:06 [main] INFO  c.l.s.impl.HnswVectorStoreService - Saved index for namespace default to /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/vector-store/default/hnsw_index.bin
2025-05-13 21:02:06 [main] INFO  c.l.s.impl.HnswVectorStoreService - Saved metadata for namespace default to /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/vector-store/default/embedding_metadata.json
2025-05-13 21:02:06 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:02:06 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:02:06 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    public static void main(String[] args) {\n        executeTask(ExternalTaskUtil.getExternalTaskRequestContext());\n    }\n"}
2025-05-13 21:02:07 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:02:07 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:02:07 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:02:07 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    private static void executeTask(ExternalTaskRequestContext externalTaskRequestContext) {\n        ExternalExtractionTaskResult externalExtractionTaskResult = null;\n        try {\n            Map<String, Object> systemProperties = externalTaskRequestContext.getWorkflowSystemProperties();\n            String jobId = externalTaskRequestContext.getJobId();\n\n            //Get workflowJobDetails of given jobId\n            DPWorkflowJobDetailsDTO workflowJobDetails = externalTaskRequestContext.getWorkflowJobDetails();\n            UDMAccountType connectorType = null;\n            RelationalDBConnectionDetail relationalDBConnectionDetail = null;\n            Map<String, String> metaData = externalTaskRequestContext.getMetaData();\n            SQLQueryInfo sqlQueryInfo = convertJsonToObject(metaData.get(SQL_EXTRACTION_DETAILS_KEY), SQLQueryInfo.class);\n            Precondition.isNotNull(sqlQueryInfo, ValidationCode.GENERIC_SYSTEM_ERROR, \"Sql Extraction details cannot be empty. Missing extractionDetails information in task metadata\");\n            String mdaBaseUrl = Objects.nonNull(workflowJobDetails.getConfigSourceUrl()) ? workflowJobDetails.getConfigSourceUrl() : workflowJobDetails.getCallbackUrl();\n            String taskId = externalTaskRequestContext.getTaskId();\n            AuditMetadata auditMetadata = newInstance(workflowJobDetails.getTenantId(), workflowJobDetails.getJobId(), workflowJobDetails.getExternalId(), taskId, externalTaskRequestContext.getTaskName());\n\n            if (sqlQueryInfo.getConnectionDetail() instanceof RelationalDBConnectionDetail) {\n                relationalDBConnectionDetail = (RelationalDBConnectionDetail) sqlQueryInfo.getConnectionDetail();\n                connectorType = UDMAccountType.valueOf(relationalDBConnectionDetail.getType());\n            } else {\n                throw new DPSystemException(\"Please provide either valid MySql ConnectionInfo \");\n            }\n\n            if (connectorType == null || !UDMAccountType.MYSQL.equals(connectorType))\n                throw new DPSystemException(msg(\"Invalid ConnectorType :{}. Only Supports MySql ConnectorType.\", connectorType));\n\n            List<FieldInfo> headers = DPUtils.convertJsonToObject(DPUtils.convertObjectToJson(sqlQueryInfo.getShowFields()), new TypeReference<List<FieldInfo>>() {\n            });\n            CsvFile csvFile = executeQuery(systemProperties, sqlQueryInfo, relationalDBConnectionDetail, externalTaskRequestContext);\n\n            //Creating instance of TaskResult\n            TaskResult taskResult = new TaskResult(headers, null);\n            char delimiter = csvFile.getDelimiter() != null ? csvFile.getDelimiter().charAt(0) : null;\n\n            // Creating instance of ExternalExtractionTaskResult\n            Map<String, CustomerCurrencyDTO> currencyConversionMap = null;\n            if (DPUtils.isCurrencyConversionMapRequired(headers)) {\n                currencyConversionMap = CustomerCurrencyUtil.getCustomerCurrencyConversionMap(mdaBaseUrl, auditMetadata, true);\n            }\n            //If no csvRecord parsing handler is added, DefaultCsvRecordParsingHandler is set for parsing each csvRecord.\n            externalExtractionTaskResult = new ExternalExtractionTaskResult.ExternalExtractionTaskResultBuilder()\n                    .setWithHeader(csvFile.getHeaders() != null)\n                    .setDelimiter(delimiter)\n                    .setTaskResult(taskResult)\n                    .setCurrencyConversionMap(currencyConversionMap)\n                    .setExtractedFiles(Collections.singletonList(csvFile.getAbsolutePath()))\n                    .build();\n\n            //Saving externalTask Result.\n            saveExtractionTaskResult(workflowJobDetails.getTenantId(), jobId, taskId, externalExtractionTaskResult);\n        } catch (Exception ex) {\n            LOGGER.error(\"Exception while executing externalTask {}-{}\", ex.getMessage(), ex);\n            throw new DPSystemException(ex.getMessage(), ex);\n\n        }\n    }\n"}
2025-05-13 21:02:09 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:02:09 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:02:09 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:02:09 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    private static void saveExtractionTaskResult(String tenantId, String jobId, String taskId, ExternalExtractionTaskResult taskResult) {\n        ExternalTaskUtil.saveExternalTaskResult(tenantId, jobId, taskId, taskResult);\n    }\n"}
2025-05-13 21:02:10 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:02:10 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:02:10 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:02:10 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    private static CsvFile executeQuery(Map<String, Object> workflowSystemProperties, SQLQueryInfo sqlQueryInfo, RelationalDBConnectionDetail dbConnectionDetail, ExternalTaskRequestContext externalTaskRequestContext) {\n        CsvFile csvFile = null;\n        try {\n            QueryBuilderResponse mysqlExtract = new FreeFormQueryBuilder().with(sqlQueryInfo)\n                    .withQueryBuilderHelper(new SqlQueryBuilderHelper(ConnectorType.MYSQL))\n                    .withQuerySourceType(QuerySourceType.SQL)\n                    .withSystemProperties(workflowSystemProperties)\n                    .withNullLastInOrderByClause(false).build();\n            String mySqlExtractQuery = mysqlExtract.getQuery();\n            LOGGER.info(\"MySql Extract Query: {}\", mySqlExtractQuery);\n            String connectionUrl = \"jdbc:mysql://\" + CryptUtil.decrypt(dbConnectionDetail.getHost()) + \":\" + CryptUtil.decrypt(dbConnectionDetail.getPort()) + \"/\" + CryptUtil.decrypt(dbConnectionDetail.getDataBaseName());\n            ConnectionParamPojo connectionParamPojo = new ConnectionParamPojo(connectionUrl, CryptUtil.decrypt(dbConnectionDetail.getUser()), CryptUtil.decrypt(dbConnectionDetail.getPwd()), 1, null, dbConnectionDetail.isSslEnabled());\n            csvFile = executeQuery(connectionParamPojo, mySqlExtractQuery, sqlQueryInfo, externalTaskRequestContext);\n        } catch (Exception ex) {\n            LOGGER.error(\"{}-{}\", ex.getMessage(), ex);\n            throw new DPSystemException(ex.getMessage(), ex);\n        }\n        return csvFile;\n    }\n"}
2025-05-13 21:02:12 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:02:12 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:02:12 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:02:12 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    private static CsvFile executeQuery(ConnectionParamPojo connectionParamPojo, String query, SQLQueryInfo sqlQueryInfo, ExternalTaskRequestContext externalTaskRequestContext) throws IOException {\n        int offset = 0;\n        int recordsRetrieved = 0;\n        Connection connection = null;\n        CsvFile csvFile = null;\n        CSVPrinter csvPrinter = null;\n        try {\n            csvFile = getCsvFileForSQLExtract(externalTaskRequestContext);\n            List<String> headers = new ArrayList<>();\n            sqlQueryInfo.getShowFields().forEach(showField -> headers.add(showField.getFieldAlias()));\n            csvFile.setHeaders(headers);\n            csvPrinter = new CSVPrinter(new BufferedWriter(new FileWriter(csvFile)), CSVFormat.DEFAULT.withQuoteMode(QuoteMode.NON_NUMERIC).withHeader(headers.toArray(new String[headers.size()])));\n            connection = getConnectionObject(connectionParamPojo);\n            List<JSONObject> dbResultSetRows = new ArrayList<>();\n            do {\n                dbResultSetRows.clear();\n                String queryToExecute = query.trim() + \" limit \" + offset + \", \" + SQL_EXTRACTION_QUERY_LIMIT;\n                DBResultPojo dbResult = executeQuery(connection, queryToExecute);\n                if (!dbResult.isSucceded()) {\n                    throw new DPSystemException(msg(\"Query execution failed because of: {}\", dbResult.getCause().getMessage()));\n                }\n                JSONArray resultData = (JSONArray) dbResult.getResult();\n                for (int i = 0; i < resultData.length(); i++) {\n                    dbResultSetRows.add(resultData.getJSONObject(i));\n                }\n                List<Object> recordList = new ArrayList<>();\n                if (CollectionUtils.isNotEmpty(dbResultSetRows)) {\n                    for (JSONObject jsonObject : dbResultSetRows) {\n                        sqlQueryInfo.getShowFields().forEach(showField -> {\n                            String key = showField.getFieldAlias().toLowerCase();\n                            if (jsonObject.isNull(key)) {\n                                recordList.add(null);\n                            } else {\n                                if (showField.getDataType().equals(DataType.NUMBER)) {\n                                    recordList.add(jsonObject.getDouble(key));\n                                } else {\n                                    recordList.add(jsonObject.get(key));\n                                }\n                            }\n                        });\n                        csvPrinter.printRecord(recordList);\n                        recordList.clear();\n                    }\n                }\n                offset = offset + SQL_EXTRACTION_QUERY_LIMIT;\n                recordsRetrieved = recordsRetrieved + dbResultSetRows.size();\n                LOGGER.info(\"Retrieved {} records so far.\", recordsRetrieved);\n            } while (dbResultSetRows.size() == SQL_EXTRACTION_QUERY_LIMIT && !Thread.currentThread().isInterrupted());\n            csvFile.setNumRecords(recordsRetrieved);\n            LOGGER.info(\"Total {} records retrieved for this task.\", recordsRetrieved);\n            csvPrinter.flush();\n        } catch (Exception ex) {\n            LOGGER.error(\"Unable to process SQL extract! {}-{}\", ex.getMessage(), ex);\n            throw new DPSystemException(ex.getMessage(), ex);\n        } finally {\n            IOUtils.closeQuietly(csvPrinter);\n            if (connection != null) {\n                try {\n                    connection.close();\n                } catch (SQLException e) {\n                    LOGGER.warn(\"Could not close connection to: {}\", connectionParamPojo.getJdbcUrl());\n                }\n            }\n\n            /**\n             * Has to explicitly shutdown AbandonedConnectionCleanupThread to avoid memory leak.\n             * Memory Leak:\n             *      Static block inside @see AbandonedConnectionCleanupThread class is spawning a new thread , which is holding a reference to the current classLoader object.\n             * @see AbandonedConnectionCleanupThread#checkedShutdown() explictly shoutdowns the executorService that created the thread, thereby removing the reference to current classLoader.\n             */\n            AbandonedConnectionCleanupThread.checkedShutdown();\n            Enumeration<Driver> drivers = DriverManager.getDrivers();\n            while (drivers.hasMoreElements()) {\n                Driver driver = drivers.nextElement();\n                if (driver.getClass().equals(com.mysql.cj.jdbc.Driver.class)) {\n                    try {\n                        DriverManager.deregisterDriver(driver);\n                    } catch (SQLException e) {\n                        LOGGER.error(\"Failed to deregister Driver : {}\", driver.getClass().getName());\n                    }\n                    break;\n                }\n            }\n        }\n        return csvFile;\n    }\n"}
2025-05-13 21:02:13 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:02:13 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:02:13 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:02:13 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    private static DBResultPojo executeQuery(Connection connection, String queryToExecute) {\n        Statement statement = null;\n        DBResultPojo dbResultPojo = new DBResultPojo();\n        try {\n            statement = connection.createStatement();\n            ResultSet resultSet = statement.executeQuery(queryToExecute);\n            dbResultPojo.setSucceded(true);\n            dbResultPojo.setResult(convertToJSON(resultSet));\n        } catch (Exception exception) {\n            dbResultPojo.setSucceded(false);\n            dbResultPojo.setCause(exception);\n            if (exception instanceof SQLException) {\n                dbResultPojo.setErrorCode(com.gainsight.services.utilities.datahighway.dhcommons.exception.ValidationCode.DB_ERROR);\n            } else if (exception instanceof IOException) {\n                dbResultPojo.setErrorCode(com.gainsight.services.utilities.datahighway.dhcommons.exception.ValidationCode.IO_ERROR);\n            } else {\n                dbResultPojo.setErrorCode(com.gainsight.services.utilities.datahighway.dhcommons.exception.ValidationCode.UNKNOWN_SERVER_ERROR);\n            }\n        } finally {\n            if (statement != null) {\n                try {\n                    statement.close();\n                } catch (SQLException e) {\n                    LOGGER.warn(\"Error while closing jdbc statement object \");\n                }\n            }\n        }\n        return dbResultPojo;\n    }\n"}
2025-05-13 21:02:14 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:02:14 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:02:14 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:02:14 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    private static JSONArray convertToJSON(ResultSet resultSet) throws Exception {\n        JSONArray jsonArray = new JSONArray();\n        while (resultSet.next()) {\n            int columnCount = resultSet.getMetaData().getColumnCount();\n            JSONObject jsonObject = new JSONObject();\n            for (int i = 0; i < columnCount; ++i) {\n                Object object = resultSet.getObject(i + 1);\n                if (object == null) {\n                    object = JSONObject.NULL;\n                }\n                jsonObject.put(resultSet.getMetaData().getColumnLabel(i + 1).toLowerCase(), object);\n            }\n            jsonArray.put(jsonObject);\n        }\n        return jsonArray;\n    }\n"}
2025-05-13 21:02:15 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:02:16 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:02:16 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:02:16 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    private static CsvFile getCsvFileForSQLExtract(ExternalTaskRequestContext externalTaskRequestContext) throws IOException {\n        String tempFilePath = DPUtils.getTempFilePath(externalTaskRequestContext.getTenantId(), externalTaskRequestContext.getJobId(), externalTaskRequestContext.getTaskId(), UUID.randomUUID().toString() + \".csv\");\n        File file = new File(tempFilePath);\n        Files.createDirectories(Paths.get(file.getParent()));\n        Files.createFile(Paths.get(file.getAbsolutePath()));\n\n        CsvFile csvFile = new CsvFile(tempFilePath);\n        csvFile.setFirstRecordHeader(true);\n        csvFile.setQuoteMode(QuoteMode.NON_NUMERIC);\n        return csvFile;\n    }\n"}
2025-05-13 21:02:17 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:02:17 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:02:17 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:02:17 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    private static Connection getConnectionObject(ConnectionParamPojo connectionParamPojo) throws SQLException, ClassNotFoundException {\n        Properties properties = new Properties();\n        properties.setProperty(\"user\", connectionParamPojo.getUserName());\n        properties.setProperty(\"password\", connectionParamPojo.getPassword());\n        properties.setProperty(\"tcpKeepAlive\", Boolean.TRUE.toString());\n        Class.forName(\"com.mysql.jdbc.Driver\");\n        return DriverManager.getConnection(connectionParamPojo.getJdbcUrl(), properties);\n    }\n"}
2025-05-13 21:02:18 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:02:18 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:02:18 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:02:18 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"             *      Static block inside @see AbandonedConnectionCleanupThread class is spawning a new thread , which is holding a reference to the current classLoader object.\n             * @see AbandonedConnectionCleanupThread#checkedShutdown() explictly shoutdowns the executorService that created the thread, thereby removing the reference to current classLoader.\n             */\n            AbandonedConnectionCleanupThread.checkedShutdown();\n            Enumeration<Driver> drivers = DriverManager.getDrivers();\n            while (drivers.hasMoreElements()) {\n                Driver driver = drivers.nextElement();\n                if (driver.getClass().equals(com.mysql.cj.jdbc.Driver.class)) {\n                    try {\n                        DriverManager.deregisterDriver(driver);\n                    } catch (SQLException e) {\n                        LOGGER.error(\"Failed to deregister Driver : {}\", driver.getClass().getName());\n                    }\n                    break;\n                }\n            }\n        }\n        return csvFile;\n    }\n\n    private static DBResultPojo executeQuery(Connection connection, String queryToExecute) {\n        Statement statement = null;\n        DBResultPojo dbResultPojo = new DBResultPojo();\n        try {\n            statement = connection.createStatement();\n            ResultSet resultSet = statement.executeQuery(queryToExecute);\n            dbResultPojo.setSucceded(true);\n            dbResultPojo.setResult(convertToJSON(resultSet));\n        } catch (Exception exception) {\n            dbResultPojo.setSucceded(false);\n            dbResultPojo.setCause(exception);\n            if (exception instanceof SQLException) {\n                dbResultPojo.setErrorCode(com.gainsight.services.utilities.datahighway.dhcommons.exception.ValidationCode.DB_ERROR);\n            } else if (exception instanceof IOException) {\n                dbResultPojo.setErrorCode(com.gainsight.services.utilities.datahighway.dhcommons.exception.ValidationCode.IO_ERROR);\n            } else {\n                dbResultPojo.setErrorCode(com.gainsight.services.utilities.datahighway.dhcommons.exception.ValidationCode.UNKNOWN_SERVER_ERROR);\n            }\n        } finally {\n            if (statement != null) {\n                try {\n                    statement.close();\n                } catch (SQLException e) {\n                    LOGGER.warn(\"Error while closing jdbc statement object \");\n                }\n            }\n        }\n        return dbResultPojo;\n    }\n\n    private static JSONArray convertToJSON(ResultSet resultSet) throws Exception {\n        JSONArray jsonArray = new JSONArray();\n        while (resultSet.next()) {\n            int columnCount = resultSet.getMetaData().getColumnCount();\n            JSONObject jsonObject = new JSONObject();\n            for (int i = 0; i < columnCount; ++i) {\n                Object object = resultSet.getObject(i + 1);\n                if (object == null) {\n                    object = JSONObject.NULL;\n                }\n                jsonObject.put(resultSet.getMetaData().getColumnLabel(i + 1).toLowerCase(), object);\n            }\n            jsonArray.put(jsonObject);\n        }\n        return jsonArray;\n    }\n\n    private static CsvFile getCsvFileForSQLExtract(ExternalTaskRequestContext externalTaskRequestContext) throws IOException {\n        String tempFilePath = DPUtils.getTempFilePath(externalTaskRequestContext.getTenantId(), externalTaskRequestContext.getJobId(), externalTaskRequestContext.getTaskId(), UUID.randomUUID().toString() + \".csv\");\n        File file = new File(tempFilePath);\n        Files.createDirectories(Paths.get(file.getParent()));\n        Files.createFile(Paths.get(file.getAbsolutePath()));\n\n        CsvFile csvFile = new CsvFile(tempFilePath);\n        csvFile.setFirstRecordHeader(true);\n        csvFile.setQuoteMode(QuoteMode.NON_NUMERIC);\n        return csvFile;\n    }\n\n    private static Connection getConnectionObject(ConnectionParamPojo connectionParamPojo) throws SQLException, ClassNotFoundException {\n        Properties properties = new Properties();\n        properties.setProperty(\"user\", connectionParamPojo.getUserName());\n        properties.setProperty(\"password\", connectionParamPojo.getPassword());\n        properties.setProperty(\"tcpKeepAlive\", Boolean.TRUE.toString());\n        Class.forName(\"com.mysql.jdbc.Driver\");\n        return DriverManager.getConnection(connectionParamPojo.getJdbcUrl(), properties);\n    }\n}\n"}
2025-05-13 21:02:20 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:02:20 [main] INFO  c.l.service.impl.BasicL3AgentService - Processed file: /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/code/dp_dynamic_tasks/mysql-extraction-task/src/main/java/com/gainsight/services/external/mysql/extraction/task/MySqlExtractionTask.java with 11 chunks
2025-05-13 21:02:20 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:02:20 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:02:20 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"package com.gainsight.services.external.px.extraction.task;\n\nimport com.gainsight.services.dataprocessing.commons.exception.DPSystemException;\nimport com.gainsight.services.dataprocessing.commons.parquet.writer.TextRecordParquetWriterBuilder;\nimport com.gainsight.services.dataprocessing.commons.pojo.DataType;\nimport com.gainsight.services.dataprocessing.commons.pojo.fields.EpochUnit;\nimport com.gainsight.services.dataprocessing.commons.pojo.fields.FieldInfo;\nimport com.gainsight.services.dataprocessing.commons.pojo.pxextract.PXAccessDetails;\nimport com.gainsight.services.dataprocessing.commons.pojo.pxextract.PXExtractInfo;\nimport com.gainsight.services.dataprocessing.commons.pojo.pxextract.PXExtractionDetails;\nimport com.gainsight.services.dataprocessing.commons.pojo.pxextract.PXResponse;\nimport com.gainsight.services.dataprocessing.commons.pojo.workflow.DPWorkflowJobDetailsDTO;\nimport com.gainsight.services.dataprocessing.commons.proxy.mda.TenantDetailsDTO;\nimport com.gainsight.services.dataprocessing.commons.querybuilders.expressions.helpers.FunctionHelper;\nimport com.gainsight.services.dataprocessing.commons.system.DPFile;\nimport com.gainsight.services.dataprocessing.commons.system.ParquetFile;\nimport com.gainsight.services.dataprocessing.commons.utils.DateTimeUtils;\nimport com.gainsight.services.dataprocessing.dataprocessor.dagdataprocessor.pojo.ExternalExtractionTaskResult;\nimport com.gainsight.services.dataprocessing.dataprocessor.dagdataprocessor.pojo.TaskResult;\nimport com.gainsight.services.dataprocessing.dataprocessor.dagdataprocessor.utils.px.PxUtil;\nimport com.gainsight.services.dataprocessing.external.task.ExternalTaskRequestContext;\nimport com.gainsight.services.dataprocessing.external.task.ExternalTaskUtil;\nimport com.gainsight.services.utilities.datahighway.dhcommons.utils.DHUtils;\nimport com.google.common.collect.Iterables;\nimport com.google.common.collect.Sets;\nimport org.apache.commons.csv.CSVFormat;\nimport org.apache.commons.csv.CSVPrinter;\nimport org.apache.commons.lang3.BooleanUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.tuple.Pair;\nimport org.apache.hadoop.fs.Path;\nimport org.apache.parquet.hadoop.ParquetFileWriter;\nimport org.apache.parquet.hadoop.ParquetWriter;\nimport org.apache.parquet.hadoop.metadata.CompressionCodecName;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.text.NumberFormat;\nimport java.text.ParseException;\nimport java.time.ZoneId;\nimport java.time.format.DateTimeFormatter;\nimport java.util.*;\nimport java.util.stream.Collectors;\n\nimport static com.gainsight.services.dataprocessing.commons.constants.Constants.ExternalTaskConstants.DEFAULT_DATE_FORMAT_KEY;\nimport static com.gainsight.services.dataprocessing.commons.constants.Constants.WorkflowConstants.PX_ACCESS_DETAILS_KEY;\nimport static com.gainsight.services.dataprocessing.commons.constants.Constants.WorkflowConstants.PX_EXTRACT_DETAILS_KEY;\nimport static com.gainsight.services.dataprocessing.commons.properties.DeploymentProperties.getDeploymentProperties;\nimport static com.gainsight.services.dataprocessing.commons.properties.DeploymentProperties.getProperties;\nimport static com.gainsight.services.dataprocessing.commons.utils.DPUtils.getTempFilePath;\nimport static com.gainsight.services.utilities.datahighway.dhcommons.utils.DHUtils.msg;\nimport static java.time.format.DateTimeFormatter.ISO_OFFSET_DATE_TIME;\n\n\n/**\n * @author sthammishetty on 17/11/20\n */\npublic class PxExtractionTask {\n    private static final Logger LOGGER = LoggerFactory.getLogger(PxExtractionTask.class);\n    private static final String DEFAULT_PAGE_SIZE = \"1000\";\n\n    public static void main(String[] args) {\n        executeTask(ExternalTaskUtil.getExternalTaskRequestContext());\n    }\n\n    private static void executeTask(ExternalTaskRequestContext externalTaskRequestContext) {\n        String jobId = externalTaskRequestContext.getJobId();\n        DPWorkflowJobDetailsDTO workflowJobDetails = externalTaskRequestContext.getWorkflowJobDetails();\n        String tenantId = externalTaskRequestContext.getTenantId();\n        String taskId = externalTaskRequestContext.getTaskId();\n        ParquetWriter<List<String>> parquetWriter = null;\n        DPFile errorFile;\n        CSVPrinter errorWriter = null;\n        ParquetFile parquetFile = null;\n        try {\n            Map<String, String> metaData = externalTaskRequestContext.getMetaData();\n            PXExtractionDetails pxExtractionDetails = DHUtils.convertJsonToObject(metaData.get(PX_EXTRACT_DETAILS_KEY), PXExtractionDetails.class);\n            PXAccessDetails accessDetails = DHUtils.convertJsonToObject(metaData.get(PX_ACCESS_DETAILS_KEY), PXAccessDetails.class);\n\n            String connectorId = accessDetails.getConnectorId();\n            Pair<String, String> aptrinsicKeyURLPair = PxUtil.getAptrinsicKey(tenantId, ExternalTaskUtil.getConfigSourceUrl(workflowJobDetails), connectorId);\n            String apiKey = aptrinsicKeyURLPair.getKey();\n            String pxURL = aptrinsicKeyURLPair.getValue();\n            PxUtil.convertDateFilterToEpochInFilterRule(pxExtractionDetails.getWhereClause(), ExternalTaskUtil.getExternalTaskRequestContext().getWorkflowSystemProperties(), getDeploymentProperties().getValue(DEFAULT_DATE_FORMAT_KEY));\n            TenantDetailsDTO tenantDetailsDTO = externalTaskRequestContext.getTenantDetailsDTO();\n            parquetFile = new ParquetFile(getTempFilePath(tenantId, jobId, externalTaskRequestContext.getTaskId(), UUID.randomUUID().toString() + \".parquet\"));\n            errorFile = getErrorFile(taskId + \"_error.csv\");\n            List<String> showFieldsList = getFieldNames(pxExtractionDetails.getShowFields());\n            errorWriter = getErrorWriter(showFieldsList, errorFile);\n            parquetWriter = getParquetWriter(showFieldsList, pxExtractionDetails.getShowFields(), parquetFile);\n\n            String pageSize = String.valueOf(accessDetails.getPageSize() != 0 ? accessDetails.getPageSize() : StringUtils.defaultIfBlank(getProperties().getProperty(\"px.page.size\"), DEFAULT_PAGE_SIZE));\n            PXExtractInfo pxExtractInfo = new PXExtractInfo();\n            pxExtractInfo.setAccessDetails(accessDetails);\n            pxExtractInfo.setPxExtractionDetails(pxExtractionDetails);\n\n            boolean isFinalResult = false;\n            String nextPageToken = null;\n            LOGGER.info(\"Fetching events using POST call to endpoint: {} with body {} \", pxURL, DHUtils.convertObjectToJson(pxExtractionDetails));\n            DateTimeFormatter destDateTimeFormatter = getDestinationDateTimeFormatter(tenantId);\n            while (!isFinalResult) {\n                PXResponse pxResponse = PxUtil.fetchEvents(pxExtractInfo, jobId, apiKey, pxURL, nextPageToken, pageSize, false);\n                nextPageToken = null;\n                isFinalResult = true;\n                if (!pxResponse.isLastPage()) {\n                    nextPageToken = pxResponse.getNextPageToken();\n                    if (StringUtils.isNotBlank(nextPageToken)) {\n                        isFinalResult = false;\n                    }\n                    jobId = pxResponse.getJobId();\n                }\n                List<Map<String, Object>> rows = pxResponse.getRows();\n                for (Map<String, Object> row : rows) {\n                    boolean isParsingSuccess = true;\n                    List<String> recordValues = new ArrayList<>(pxExtractionDetails.getShowFields().size());\n                    String errorMsg = null;\n                    for (FieldInfo fieldInfo : pxExtractionDetails.getShowFields()) {\n                        String convertedValue = null;\n                        try {\n                            DataType dataType = FunctionHelper.getDerivedDataType(fieldInfo);\n                            String attributeName = StringUtils.defaultIfBlank(fieldInfo.getFieldAlias(), fieldInfo.getName());\n                            Object obj = row.get(attributeName);\n                            if (obj != null) {\n                                if (obj instanceof String) {\n                                    convertedValue = (String) row.get(attributeName);\n                                } else {\n                                    if (obj instanceof Double && isTimeStampField(dataType)) {\n                                        convertedValue = String.valueOf(((Double) obj).longValue());\n                                    } else {\n                                        convertedValue = String.valueOf(obj);\n                                    }\n                                }\n                                if (StringUtils.isNotBlank(convertedValue)) {\n                                    if (isTimeStampField(dataType)) {\n                                        convertedValue = DateTimeUtils.convertEpochToDateTime(convertedValue, EpochUnit.MILLIS, destDateTimeFormatter, ZoneId.of(tenantDetailsDTO.getTimeZoneId()));\n                                    } else if (DataType.NUMBER.equals(dataType)) {\n                                        Locale locale = fieldInfo.getFieldLocale() == null ? Locale.US : fieldInfo.getFieldLocale().getLocale();\n                                        NumberFormat nf = NumberFormat.getInstance(locale);\n                                        try {\n                                            convertedValue = DHUtils.valueOf(nf.parse(convertedValue));\n                                        } catch (ParseException e) {\n                                            LOGGER.info(\"Error while parsing number:{} with given Locale:{}\", convertedValue, locale);\n                                            throw new DPSystemException(msg(\"Error while parsing number:{} with given Locale:{}\", convertedValue, locale), e);\n                                        }\n                                    }\n                                }\n                            }\n                        } catch (Exception e) {\n                            isParsingSuccess = false;\n                            if (errorMsg == null) {\n                                errorMsg = msg(\"Error while parsing row : {}. {} \", row, e, e.getCause());\n                            }\n                        }\n                        recordValues.add(convertedValue);\n\n                    }\n                    if (isParsingSuccess) {\n                        parquetWriter.write(recordValues);\n                        parquetFile.addNumRecords(1);\n                    } else {\n                        if (Objects.nonNull(errorFile) && Objects.nonNull(errorWriter)) {\n                            recordValues.add(errorMsg);\n                            errorWriter.printRecord(recordValues);\n                            errorFile.setNumRecords(errorFile.getNumRecords() + 1);\n                        }\n                    }\n                }\n            }\n            LOGGER.info(\"Added {} records to parquetFile\", parquetFile.getNumRecords());\n            if (errorFile.getNumRecords() > 0) {\n                LOGGER.warn(\"Found {}  error records\", errorFile.getNumRecords());\n                LOGGER.info(\"Added {} records to errorFile\", errorFile.getNumRecords());\n            }\n            TaskResult taskResult = new TaskResult(pxExtractionDetails.getShowFields(), null, errorFile.getNumRecords());\n            taskResult.setResultCount(parquetFile.getNumRecords());\n            ExternalExtractionTaskResult.ExternalExtractionTaskResultBuilder externalExtractionTaskResultBuilder = new ExternalExtractionTaskResult.ExternalExtractionTaskResultBuilder()\n                    .setExtractedFiles(Collections.singletonList(parquetFile.getAbsolutePath()))\n                    .setTaskResult(taskResult);\n\n            if (Objects.nonNull(errorFile) && errorFile.getNumRecords() > 0) {\n                externalExtractionTaskResultBuilder.setWriteToErrorFile(true);\n                externalExtractionTaskResultBuilder.setErrorFilePath(errorFile.getAbsolutePath());\n            }\n            ExternalExtractionTaskResult externalTaskResult = externalExtractionTaskResultBuilder.build();\n            externalTaskResult.setEnableParquetConversion(false);\n            ExternalTaskUtil.saveExternalTaskResult(externalTaskRequestContext, externalTaskResult);\n        } catch (Exception ex) {\n            LOGGER.error(\"Exception while executing PX-Extraction task  {} - {}\", ex.getMessage(), ex);\n            throw new DPSystemException(ex.getMessage(), ex);\n        } finally {\n            if (Objects.nonNull(parquetWriter)) {\n                try {\n                    parquetWriter.close();\n                } catch (Exception ex) {\n                    LOGGER.error(\"Error in closing parquet file writer\");\n                    throw new DPSystemException(\"Failed to close parquet writer\", ex);\n                }\n            }\n\n            if (Objects.nonNull(errorWriter)) {\n                try {\n                    errorWriter.close();\n                } catch (Exception e) {\n                    LOGGER.error(\"Error in closing csv writer\");\n                    throw new DPSystemException(\"Failed to close csv writer\", e);\n                }\n            }\n        }\n\n    }\n\n    private static DateTimeFormatter getDestinationDateTimeFormatter(String tenantId) {\n        try {\n            String pxOutputDatetimeFormat = getProperties().getProperty(\"px.output.datetime.format\", \"yyyy-MM-dd'T'HH:mm:ss['.'SSS][XXXXX]\");\n            String pxCustomDatetimeFormatterEnabledTenantsString = getProperties().getProperty(\"px.custom.datetime.format.enabled.tenants\", StringUtils.EMPTY);\n            Set<String> pxCustomDatetimeFormatterEnabledTenants = StringUtils.isNotBlank(pxCustomDatetimeFormatterEnabledTenantsString) ?\n                    Sets.newHashSet(pxCustomDatetimeFormatterEnabledTenantsString.split(\"\\\\s*,\\\\s*\")) : Sets.newHashSet();\n\n            if (BooleanUtils.toBoolean(getProperties().getProperty(\"px.output.custom.datetime.format.enabled\", \"false\")) || pxCustomDatetimeFormatterEnabledTenants.contains(tenantId)) {\n                LOGGER.info(\"Using custom PX output datetime format: {} for tenant: {}\", pxOutputDatetimeFormat, tenantId);\n                return DateTimeFormatter.ofPattern(pxOutputDatetimeFormat);\n            }\n        } catch (Exception ex) {\n            LOGGER.error(\"Error in getting custom datetime format, using default ISO_OFFSET_DATE_TIME format. Reason: {}.\", ex.getMessage());\n        }\n\n        return ISO_OFFSET_DATE_TIME;\n    }\n\n    private static DPFile getErrorFile(String errorFilePath) {\n        DPFile errorFile = new DPFile(new File(errorFilePath).getAbsolutePath()) {\n        };\n        return errorFile;\n    }\n\n    private static CSVPrinter getErrorWriter(List<String> headers, DPFile errorFile) {\n        CSVPrinter csvPrinter = null;\n        try {\n            headers.add(\"Error Message\");\n            CSVFormat csvFormat = CSVFormat.DEFAULT;\n            String[] headersArr = Iterables.toArray(headers, String.class);\n            CSVFormat format = csvFormat.withHeader(headersArr).withSkipHeaderRecord(false);\n            csvPrinter = new CSVPrinter(new BufferedWriter(new FileWriter(errorFile)), format);\n        } catch (Exception e) {\n            LOGGER.error(\"Error while creating csvWriter for error file {}\", e.getMessage());\n        }\n        return csvPrinter;\n    }\n\n    private static ParquetWriter<List<String>> getParquetWriter(List<String> headers, List<FieldInfo> showFields, ParquetFile parquetFile) {\n        parquetFile.setHeaders(headers);\n        try {\n            return new TextRecordParquetWriterBuilder(new Path(parquetFile.toURI()), showFields)\n                    .withRowGroupSize(10 * 1000 * 1000)\n                    .withWriteMode(ParquetFileWriter.Mode.OVERWRITE)\n                    .withCompressionCodec(CompressionCodecName.SNAPPY).build();\n        } catch (Exception ex) {\n            LOGGER.error(\"Error in creating parquet file - probably error during writing schema.\");\n            throw new DPSystemException(\"Failed to create parquet file\", ex);\n        }\n\n    }\n\n    private static List<String> getFieldNames(List<FieldInfo> showFields) {\n        return showFields.stream()\n                .map(fieldInfo -> StringUtils.defaultIfBlank(fieldInfo.getFieldAlias(), fieldInfo.getName()))\n                .collect(Collectors.toList());\n    }\n\n    private static boolean isTimeStampField(DataType dataType) {\n        return dataType != null && dataType.equals(DataType.TIMESTAMP) || dataType.equals(DataType.DATE) || dataType.equals(DataType.DATETIME);\n    }\n}\n\n\n"}
2025-05-13 21:02:21 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:02:21 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:02:21 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:02:21 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    public static void main(String[] args) {\n        executeTask(ExternalTaskUtil.getExternalTaskRequestContext());\n    }\n"}
2025-05-13 21:02:23 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:02:23 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:02:23 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:02:23 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    private static void executeTask(ExternalTaskRequestContext externalTaskRequestContext) {\n        String jobId = externalTaskRequestContext.getJobId();\n        DPWorkflowJobDetailsDTO workflowJobDetails = externalTaskRequestContext.getWorkflowJobDetails();\n        String tenantId = externalTaskRequestContext.getTenantId();\n        String taskId = externalTaskRequestContext.getTaskId();\n        ParquetWriter<List<String>> parquetWriter = null;\n        DPFile errorFile;\n        CSVPrinter errorWriter = null;\n        ParquetFile parquetFile = null;\n        try {\n            Map<String, String> metaData = externalTaskRequestContext.getMetaData();\n            PXExtractionDetails pxExtractionDetails = DHUtils.convertJsonToObject(metaData.get(PX_EXTRACT_DETAILS_KEY), PXExtractionDetails.class);\n            PXAccessDetails accessDetails = DHUtils.convertJsonToObject(metaData.get(PX_ACCESS_DETAILS_KEY), PXAccessDetails.class);\n\n            String connectorId = accessDetails.getConnectorId();\n            Pair<String, String> aptrinsicKeyURLPair = PxUtil.getAptrinsicKey(tenantId, ExternalTaskUtil.getConfigSourceUrl(workflowJobDetails), connectorId);\n            String apiKey = aptrinsicKeyURLPair.getKey();\n            String pxURL = aptrinsicKeyURLPair.getValue();\n            PxUtil.convertDateFilterToEpochInFilterRule(pxExtractionDetails.getWhereClause(), ExternalTaskUtil.getExternalTaskRequestContext().getWorkflowSystemProperties(), getDeploymentProperties().getValue(DEFAULT_DATE_FORMAT_KEY));\n            TenantDetailsDTO tenantDetailsDTO = externalTaskRequestContext.getTenantDetailsDTO();\n            parquetFile = new ParquetFile(getTempFilePath(tenantId, jobId, externalTaskRequestContext.getTaskId(), UUID.randomUUID().toString() + \".parquet\"));\n            errorFile = getErrorFile(taskId + \"_error.csv\");\n            List<String> showFieldsList = getFieldNames(pxExtractionDetails.getShowFields());\n            errorWriter = getErrorWriter(showFieldsList, errorFile);\n            parquetWriter = getParquetWriter(showFieldsList, pxExtractionDetails.getShowFields(), parquetFile);\n\n            String pageSize = String.valueOf(accessDetails.getPageSize() != 0 ? accessDetails.getPageSize() : StringUtils.defaultIfBlank(getProperties().getProperty(\"px.page.size\"), DEFAULT_PAGE_SIZE));\n            PXExtractInfo pxExtractInfo = new PXExtractInfo();\n            pxExtractInfo.setAccessDetails(accessDetails);\n            pxExtractInfo.setPxExtractionDetails(pxExtractionDetails);\n\n            boolean isFinalResult = false;\n            String nextPageToken = null;\n            LOGGER.info(\"Fetching events using POST call to endpoint: {} with body {} \", pxURL, DHUtils.convertObjectToJson(pxExtractionDetails));\n            DateTimeFormatter destDateTimeFormatter = getDestinationDateTimeFormatter(tenantId);\n            while (!isFinalResult) {\n                PXResponse pxResponse = PxUtil.fetchEvents(pxExtractInfo, jobId, apiKey, pxURL, nextPageToken, pageSize, false);\n                nextPageToken = null;\n                isFinalResult = true;\n                if (!pxResponse.isLastPage()) {\n                    nextPageToken = pxResponse.getNextPageToken();\n                    if (StringUtils.isNotBlank(nextPageToken)) {\n                        isFinalResult = false;\n                    }\n                    jobId = pxResponse.getJobId();\n                }\n                List<Map<String, Object>> rows = pxResponse.getRows();\n                for (Map<String, Object> row : rows) {\n                    boolean isParsingSuccess = true;\n                    List<String> recordValues = new ArrayList<>(pxExtractionDetails.getShowFields().size());\n                    String errorMsg = null;\n                    for (FieldInfo fieldInfo : pxExtractionDetails.getShowFields()) {\n                        String convertedValue = null;\n                        try {\n                            DataType dataType = FunctionHelper.getDerivedDataType(fieldInfo);\n                            String attributeName = StringUtils.defaultIfBlank(fieldInfo.getFieldAlias(), fieldInfo.getName());\n                            Object obj = row.get(attributeName);\n                            if (obj != null) {\n                                if (obj instanceof String) {\n                                    convertedValue = (String) row.get(attributeName);\n                                } else {\n                                    if (obj instanceof Double && isTimeStampField(dataType)) {\n                                        convertedValue = String.valueOf(((Double) obj).longValue());\n                                    } else {\n                                        convertedValue = String.valueOf(obj);\n                                    }\n                                }\n                                if (StringUtils.isNotBlank(convertedValue)) {\n                                    if (isTimeStampField(dataType)) {\n                                        convertedValue = DateTimeUtils.convertEpochToDateTime(convertedValue, EpochUnit.MILLIS, destDateTimeFormatter, ZoneId.of(tenantDetailsDTO.getTimeZoneId()));\n                                    } else if (DataType.NUMBER.equals(dataType)) {\n                                        Locale locale = fieldInfo.getFieldLocale() == null ? Locale.US : fieldInfo.getFieldLocale().getLocale();\n                                        NumberFormat nf = NumberFormat.getInstance(locale);\n                                        try {\n                                            convertedValue = DHUtils.valueOf(nf.parse(convertedValue));\n                                        } catch (ParseException e) {\n                                            LOGGER.info(\"Error while parsing number:{} with given Locale:{}\", convertedValue, locale);\n                                            throw new DPSystemException(msg(\"Error while parsing number:{} with given Locale:{}\", convertedValue, locale), e);\n                                        }\n                                    }\n                                }\n                            }\n                        } catch (Exception e) {\n                            isParsingSuccess = false;\n                            if (errorMsg == null) {\n                                errorMsg = msg(\"Error while parsing row : {}. {} \", row, e, e.getCause());\n                            }\n                        }\n                        recordValues.add(convertedValue);\n\n                    }\n                    if (isParsingSuccess) {\n                        parquetWriter.write(recordValues);\n                        parquetFile.addNumRecords(1);\n                    } else {\n                        if (Objects.nonNull(errorFile) && Objects.nonNull(errorWriter)) {\n                            recordValues.add(errorMsg);\n                            errorWriter.printRecord(recordValues);\n                            errorFile.setNumRecords(errorFile.getNumRecords() + 1);\n                        }\n                    }\n                }\n            }\n            LOGGER.info(\"Added {} records to parquetFile\", parquetFile.getNumRecords());\n            if (errorFile.getNumRecords() > 0) {\n                LOGGER.warn(\"Found {}  error records\", errorFile.getNumRecords());\n                LOGGER.info(\"Added {} records to errorFile\", errorFile.getNumRecords());\n            }\n            TaskResult taskResult = new TaskResult(pxExtractionDetails.getShowFields(), null, errorFile.getNumRecords());\n            taskResult.setResultCount(parquetFile.getNumRecords());\n            ExternalExtractionTaskResult.ExternalExtractionTaskResultBuilder externalExtractionTaskResultBuilder = new ExternalExtractionTaskResult.ExternalExtractionTaskResultBuilder()\n                    .setExtractedFiles(Collections.singletonList(parquetFile.getAbsolutePath()))\n                    .setTaskResult(taskResult);\n\n            if (Objects.nonNull(errorFile) && errorFile.getNumRecords() > 0) {\n                externalExtractionTaskResultBuilder.setWriteToErrorFile(true);\n                externalExtractionTaskResultBuilder.setErrorFilePath(errorFile.getAbsolutePath());\n            }\n            ExternalExtractionTaskResult externalTaskResult = externalExtractionTaskResultBuilder.build();\n            externalTaskResult.setEnableParquetConversion(false);\n            ExternalTaskUtil.saveExternalTaskResult(externalTaskRequestContext, externalTaskResult);\n        } catch (Exception ex) {\n            LOGGER.error(\"Exception while executing PX-Extraction task  {} - {}\", ex.getMessage(), ex);\n            throw new DPSystemException(ex.getMessage(), ex);\n        } finally {\n            if (Objects.nonNull(parquetWriter)) {\n                try {\n                    parquetWriter.close();\n                } catch (Exception ex) {\n                    LOGGER.error(\"Error in closing parquet file writer\");\n                    throw new DPSystemException(\"Failed to close parquet writer\", ex);\n                }\n            }\n\n            if (Objects.nonNull(errorWriter)) {\n                try {\n                    errorWriter.close();\n                } catch (Exception e) {\n                    LOGGER.error(\"Error in closing csv writer\");\n                    throw new DPSystemException(\"Failed to close csv writer\", e);\n                }\n            }\n        }\n\n    }\n"}
2025-05-13 21:02:24 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:02:24 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:02:24 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:02:24 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    private static DateTimeFormatter getDestinationDateTimeFormatter(String tenantId) {\n        try {\n            String pxOutputDatetimeFormat = getProperties().getProperty(\"px.output.datetime.format\", \"yyyy-MM-dd'T'HH:mm:ss['.'SSS][XXXXX]\");\n            String pxCustomDatetimeFormatterEnabledTenantsString = getProperties().getProperty(\"px.custom.datetime.format.enabled.tenants\", StringUtils.EMPTY);\n            Set<String> pxCustomDatetimeFormatterEnabledTenants = StringUtils.isNotBlank(pxCustomDatetimeFormatterEnabledTenantsString) ?\n                    Sets.newHashSet(pxCustomDatetimeFormatterEnabledTenantsString.split(\"\\\\s*,\\\\s*\")) : Sets.newHashSet();\n\n            if (BooleanUtils.toBoolean(getProperties().getProperty(\"px.output.custom.datetime.format.enabled\", \"false\")) || pxCustomDatetimeFormatterEnabledTenants.contains(tenantId)) {\n                LOGGER.info(\"Using custom PX output datetime format: {} for tenant: {}\", pxOutputDatetimeFormat, tenantId);\n                return DateTimeFormatter.ofPattern(pxOutputDatetimeFormat);\n            }\n        } catch (Exception ex) {\n            LOGGER.error(\"Error in getting custom datetime format, using default ISO_OFFSET_DATE_TIME format. Reason: {}.\", ex.getMessage());\n        }\n\n        return ISO_OFFSET_DATE_TIME;\n    }\n"}
2025-05-13 21:02:25 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:02:25 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:02:25 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:02:25 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    private static DPFile getErrorFile(String errorFilePath) {\n        DPFile errorFile = new DPFile(new File(errorFilePath).getAbsolutePath()) {\n        };\n        return errorFile;\n    }\n"}
2025-05-13 21:02:27 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:02:27 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:02:27 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:02:27 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    private static CSVPrinter getErrorWriter(List<String> headers, DPFile errorFile) {\n        CSVPrinter csvPrinter = null;\n        try {\n            headers.add(\"Error Message\");\n            CSVFormat csvFormat = CSVFormat.DEFAULT;\n            String[] headersArr = Iterables.toArray(headers, String.class);\n            CSVFormat format = csvFormat.withHeader(headersArr).withSkipHeaderRecord(false);\n            csvPrinter = new CSVPrinter(new BufferedWriter(new FileWriter(errorFile)), format);\n        } catch (Exception e) {\n            LOGGER.error(\"Error while creating csvWriter for error file {}\", e.getMessage());\n        }\n        return csvPrinter;\n    }\n"}
2025-05-13 21:02:28 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:02:28 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:02:28 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:02:28 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    private static ParquetWriter<List<String>> getParquetWriter(List<String> headers, List<FieldInfo> showFields, ParquetFile parquetFile) {\n        parquetFile.setHeaders(headers);\n        try {\n            return new TextRecordParquetWriterBuilder(new Path(parquetFile.toURI()), showFields)\n                    .withRowGroupSize(10 * 1000 * 1000)\n                    .withWriteMode(ParquetFileWriter.Mode.OVERWRITE)\n                    .withCompressionCodec(CompressionCodecName.SNAPPY).build();\n        } catch (Exception ex) {\n            LOGGER.error(\"Error in creating parquet file - probably error during writing schema.\");\n            throw new DPSystemException(\"Failed to create parquet file\", ex);\n        }\n\n    }\n"}
2025-05-13 21:02:30 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:02:30 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:02:30 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:02:30 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    private static List<String> getFieldNames(List<FieldInfo> showFields) {\n        return showFields.stream()\n                .map(fieldInfo -> StringUtils.defaultIfBlank(fieldInfo.getFieldAlias(), fieldInfo.getName()))\n                .collect(Collectors.toList());\n    }\n"}
2025-05-13 21:02:31 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:02:31 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:02:31 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:02:31 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    private static boolean isTimeStampField(DataType dataType) {\n        return dataType != null && dataType.equals(DataType.TIMESTAMP) || dataType.equals(DataType.DATE) || dataType.equals(DataType.DATETIME);\n    }\n"}
2025-05-13 21:02:32 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:02:32 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:02:32 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:02:32 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"public class PxExtractionTask {\n    private static final Logger LOGGER = LoggerFactory.getLogger(PxExtractionTask.class);\n    private static final String DEFAULT_PAGE_SIZE = \"1000\";\n\n    public static void main(String[] args) {\n        executeTask(ExternalTaskUtil.getExternalTaskRequestContext());\n    }\n\n    private static void executeTask(ExternalTaskRequestContext externalTaskRequestContext) {\n        String jobId = externalTaskRequestContext.getJobId();\n        DPWorkflowJobDetailsDTO workflowJobDetails = externalTaskRequestContext.getWorkflowJobDetails();\n        String tenantId = externalTaskRequestContext.getTenantId();\n        String taskId = externalTaskRequestContext.getTaskId();\n        ParquetWriter<List<String>> parquetWriter = null;\n        DPFile errorFile;\n        CSVPrinter errorWriter = null;\n        ParquetFile parquetFile = null;\n        try {\n            Map<String, String> metaData = externalTaskRequestContext.getMetaData();\n            PXExtractionDetails pxExtractionDetails = DHUtils.convertJsonToObject(metaData.get(PX_EXTRACT_DETAILS_KEY), PXExtractionDetails.class);\n            PXAccessDetails accessDetails = DHUtils.convertJsonToObject(metaData.get(PX_ACCESS_DETAILS_KEY), PXAccessDetails.class);\n\n            String connectorId = accessDetails.getConnectorId();\n            Pair<String, String> aptrinsicKeyURLPair = PxUtil.getAptrinsicKey(tenantId, ExternalTaskUtil.getConfigSourceUrl(workflowJobDetails), connectorId);\n            String apiKey = aptrinsicKeyURLPair.getKey();\n            String pxURL = aptrinsicKeyURLPair.getValue();\n            PxUtil.convertDateFilterToEpochInFilterRule(pxExtractionDetails.getWhereClause(), ExternalTaskUtil.getExternalTaskRequestContext().getWorkflowSystemProperties(), getDeploymentProperties().getValue(DEFAULT_DATE_FORMAT_KEY));\n            TenantDetailsDTO tenantDetailsDTO = externalTaskRequestContext.getTenantDetailsDTO();\n            parquetFile = new ParquetFile(getTempFilePath(tenantId, jobId, externalTaskRequestContext.getTaskId(), UUID.randomUUID().toString() + \".parquet\"));\n            errorFile = getErrorFile(taskId + \"_error.csv\");\n            List<String> showFieldsList = getFieldNames(pxExtractionDetails.getShowFields());\n            errorWriter = getErrorWriter(showFieldsList, errorFile);\n            parquetWriter = getParquetWriter(showFieldsList, pxExtractionDetails.getShowFields(), parquetFile);\n\n            String pageSize = String.valueOf(accessDetails.getPageSize() != 0 ? accessDetails.getPageSize() : StringUtils.defaultIfBlank(getProperties().getProperty(\"px.page.size\"), DEFAULT_PAGE_SIZE));\n            PXExtractInfo pxExtractInfo = new PXExtractInfo();\n            pxExtractInfo.setAccessDetails(accessDetails);\n            pxExtractInfo.setPxExtractionDetails(pxExtractionDetails);\n\n            boolean isFinalResult = false;\n            String nextPageToken = null;\n            LOGGER.info(\"Fetching events using POST call to endpoint: {} with body {} \", pxURL, DHUtils.convertObjectToJson(pxExtractionDetails));\n            DateTimeFormatter destDateTimeFormatter = getDestinationDateTimeFormatter(tenantId);\n            while (!isFinalResult) {\n                PXResponse pxResponse = PxUtil.fetchEvents(pxExtractInfo, jobId, apiKey, pxURL, nextPageToken, pageSize, false);\n                nextPageToken = null;\n                isFinalResult = true;\n                if (!pxResponse.isLastPage()) {\n                    nextPageToken = pxResponse.getNextPageToken();\n                    if (StringUtils.isNotBlank(nextPageToken)) {\n                        isFinalResult = false;\n                    }\n                    jobId = pxResponse.getJobId();\n                }\n                List<Map<String, Object>> rows = pxResponse.getRows();\n                for (Map<String, Object> row : rows) {\n                    boolean isParsingSuccess = true;\n                    List<String> recordValues = new ArrayList<>(pxExtractionDetails.getShowFields().size());\n                    String errorMsg = null;\n                    for (FieldInfo fieldInfo : pxExtractionDetails.getShowFields()) {\n                        String convertedValue = null;\n                        try {\n                            DataType dataType = FunctionHelper.getDerivedDataType(fieldInfo);\n                            String attributeName = StringUtils.defaultIfBlank(fieldInfo.getFieldAlias(), fieldInfo.getName());\n                            Object obj = row.get(attributeName);\n                            if (obj != null) {\n                                if (obj instanceof String) {\n                                    convertedValue = (String) row.get(attributeName);\n                                } else {\n                                    if (obj instanceof Double && isTimeStampField(dataType)) {\n                                        convertedValue = String.valueOf(((Double) obj).longValue());\n                                    } else {\n                                        convertedValue = String.valueOf(obj);\n                                    }\n                                }\n                                if (StringUtils.isNotBlank(convertedValue)) {\n                                    if (isTimeStampField(dataType)) {\n                                        convertedValue = DateTimeUtils.convertEpochToDateTime(convertedValue, EpochUnit.MILLIS, destDateTimeFormatter, ZoneId.of(tenantDetailsDTO.getTimeZoneId()));\n                                    } else if (DataType.NUMBER.equals(dataType)) {\n                                        Locale locale = fieldInfo.getFieldLocale() == null ? Locale.US : fieldInfo.getFieldLocale().getLocale();\n                                        NumberFormat nf = NumberFormat.getInstance(locale);\n                                        try {\n                                            convertedValue = DHUtils.valueOf(nf.parse(convertedValue));\n                                        } catch (ParseException e) {\n                                            LOGGER.info(\"Error while parsing number:{} with given Locale:{}\", convertedValue, locale);\n                                            throw new DPSystemException(msg(\"Error while parsing number:{} with given Locale:{}\", convertedValue, locale), e);\n                                        }\n                                    }\n                                }\n                            }\n                        } catch (Exception e) {\n                            isParsingSuccess = false;\n                            if (errorMsg == null) {\n                                errorMsg = msg(\"Error while parsing row : {}. {} \", row, e, e.getCause());\n                            }\n                        }\n                        recordValues.add(convertedValue);\n\n                    }\n                    if (isParsingSuccess) {\n                        parquetWriter.write(recordValues);\n                        parquetFile.addNumRecords(1);\n                    } else {\n                        if (Objects.nonNull(errorFile) && Objects.nonNull(errorWriter)) {\n                            recordValues.add(errorMsg);\n                            errorWriter.printRecord(recordValues);\n                            errorFile.setNumRecords(errorFile.getNumRecords() + 1);\n                        }\n                    }\n                }\n            }\n            LOGGER.info(\"Added {} records to parquetFile\", parquetFile.getNumRecords());\n            if (errorFile.getNumRecords() > 0) {\n                LOGGER.warn(\"Found {}  error records\", errorFile.getNumRecords());\n                LOGGER.info(\"Added {} records to errorFile\", errorFile.getNumRecords());\n            }\n            TaskResult taskResult = new TaskResult(pxExtractionDetails.getShowFields(), null, errorFile.getNumRecords());\n            taskResult.setResultCount(parquetFile.getNumRecords());\n            ExternalExtractionTaskResult.ExternalExtractionTaskResultBuilder externalExtractionTaskResultBuilder = new ExternalExtractionTaskResult.ExternalExtractionTaskResultBuilder()\n                    .setExtractedFiles(Collections.singletonList(parquetFile.getAbsolutePath()))\n                    .setTaskResult(taskResult);\n\n            if (Objects.nonNull(errorFile) && errorFile.getNumRecords() > 0) {\n                externalExtractionTaskResultBuilder.setWriteToErrorFile(true);\n                externalExtractionTaskResultBuilder.setErrorFilePath(errorFile.getAbsolutePath());\n            }\n            ExternalExtractionTaskResult externalTaskResult = externalExtractionTaskResultBuilder.build();\n            externalTaskResult.setEnableParquetConversion(false);\n            ExternalTaskUtil.saveExternalTaskResult(externalTaskRequestContext, externalTaskResult);\n        } catch (Exception ex) {\n            LOGGER.error(\"Exception while executing PX-Extraction task  {} - {}\", ex.getMessage(), ex);\n            throw new DPSystemException(ex.getMessage(), ex);\n        } finally {\n            if (Objects.nonNull(parquetWriter)) {\n                try {\n                    parquetWriter.close();\n                } catch (Exception ex) {\n                    LOGGER.error(\"Error in closing parquet file writer\");\n                    throw new DPSystemException(\"Failed to close parquet writer\", ex);\n                }\n            }\n\n            if (Objects.nonNull(errorWriter)) {\n                try {\n                    errorWriter.close();\n                } catch (Exception e) {\n                    LOGGER.error(\"Error in closing csv writer\");\n                    throw new DPSystemException(\"Failed to close csv writer\", e);\n                }\n            }\n        }\n\n    }\n\n    private static DateTimeFormatter getDestinationDateTimeFormatter(String tenantId) {\n        try {\n            String pxOutputDatetimeFormat = getProperties().getProperty(\"px.output.datetime.format\", \"yyyy-MM-dd'T'HH:mm:ss['.'SSS][XXXXX]\");\n            String pxCustomDatetimeFormatterEnabledTenantsString = getProperties().getProperty(\"px.custom.datetime.format.enabled.tenants\", StringUtils.EMPTY);\n            Set<String> pxCustomDatetimeFormatterEnabledTenants = StringUtils.isNotBlank(pxCustomDatetimeFormatterEnabledTenantsString) ?\n                    Sets.newHashSet(pxCustomDatetimeFormatterEnabledTenantsString.split(\"\\\\s*,\\\\s*\")) : Sets.newHashSet();\n\n            if (BooleanUtils.toBoolean(getProperties().getProperty(\"px.output.custom.datetime.format.enabled\", \"false\")) || pxCustomDatetimeFormatterEnabledTenants.contains(tenantId)) {\n                LOGGER.info(\"Using custom PX output datetime format: {} for tenant: {}\", pxOutputDatetimeFormat, tenantId);\n                return DateTimeFormatter.ofPattern(pxOutputDatetimeFormat);\n            }\n        } catch (Exception ex) {\n            LOGGER.error(\"Error in getting custom datetime format, using default ISO_OFFSET_DATE_TIME format. Reason: {}.\", ex.getMessage());\n        }\n\n        return ISO_OFFSET_DATE_TIME;\n    }\n\n    private static DPFile getErrorFile(String errorFilePath) {\n        DPFile errorFile = new DPFile(new File(errorFilePath).getAbsolutePath()) {\n        };\n        return errorFile;\n    }\n\n    private static CSVPrinter getErrorWriter(List<String> headers, DPFile errorFile) {\n        CSVPrinter csvPrinter = null;\n        try {\n            headers.add(\"Error Message\");\n            CSVFormat csvFormat = CSVFormat.DEFAULT;\n            String[] headersArr = Iterables.toArray(headers, String.class);\n            CSVFormat format = csvFormat.withHeader(headersArr).withSkipHeaderRecord(false);\n            csvPrinter = new CSVPrinter(new BufferedWriter(new FileWriter(errorFile)), format);\n        } catch (Exception e) {\n            LOGGER.error(\"Error while creating csvWriter for error file {}\", e.getMessage());\n        }\n        return csvPrinter;\n    }\n\n    private static ParquetWriter<List<String>> getParquetWriter(List<String> headers, List<FieldInfo> showFields, ParquetFile parquetFile) {\n        parquetFile.setHeaders(headers);\n        try {\n            return new TextRecordParquetWriterBuilder(new Path(parquetFile.toURI()), showFields)\n                    .withRowGroupSize(10 * 1000 * 1000)\n                    .withWriteMode(ParquetFileWriter.Mode.OVERWRITE)\n                    .withCompressionCodec(CompressionCodecName.SNAPPY).build();\n        } catch (Exception ex) {\n            LOGGER.error(\"Error in creating parquet file - probably error during writing schema.\");\n            throw new DPSystemException(\"Failed to create parquet file\", ex);\n        }\n\n    }\n\n    private static List<String> getFieldNames(List<FieldInfo> showFields) {\n        return showFields.stream()\n                .map(fieldInfo -> StringUtils.defaultIfBlank(fieldInfo.getFieldAlias(), fieldInfo.getName()))\n                .collect(Collectors.toList());\n    }\n\n    private static boolean isTimeStampField(DataType dataType) {\n        return dataType != null && dataType.equals(DataType.TIMESTAMP) || dataType.equals(DataType.DATE) || dataType.equals(DataType.DATETIME);\n    }\n}\n"}
2025-05-13 21:02:34 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:02:34 [main] INFO  c.l.service.impl.BasicL3AgentService - Processed file: /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/code/dp_dynamic_tasks/px-extraction-task/src/main/java/com/gainsight/services/external/px/extraction/task/PxExtractionTask.java with 10 chunks
2025-05-13 21:02:34 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:02:34 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:02:34 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"package com.gainsight.services.external.out.of.disk.space.task;\n\nimport com.gainsight.services.dataprocessing.commons.pojo.DataType;\nimport com.gainsight.services.dataprocessing.commons.pojo.fields.FieldInfo;\nimport com.gainsight.services.dataprocessing.dataprocessor.dagdataprocessor.pojo.ExternalTaskResult;\nimport com.gainsight.services.dataprocessing.dataprocessor.dagdataprocessor.pojo.TaskResult;\nimport com.gainsight.services.dataprocessing.external.task.ExternalTaskRequestContext;\nimport com.gainsight.services.dataprocessing.external.task.ExternalTaskUtil;\nimport org.apache.commons.io.FileUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Collections;\n\n\n/**\n * @author sthammishetty on 09/06/20\n * <p>\n * Sample ExternalTask which tries to use more than allocated disk space. This task get's failed due to excess disk utilization\n */\npublic class ExternalTask {\n    private static final Logger LOGGER = LoggerFactory.getLogger(ExternalTask.class.getName());\n\n    public static void main(String[] args) {\n        execute(ExternalTaskUtil.getExternalTaskRequestContext());\n    }\n\n    public static void execute(ExternalTaskRequestContext externalTaskRequestContext) {\n        for (int i = 0; i < 10; i++) {\n            InputStream inputStream = ExternalTask.class.getClassLoader().getResourceAsStream(\"random.txt\");\n            File file = new File(\"random\" + i + \".txt\");\n            LOGGER.info(\"copying to file \" + file.getName());\n            try {\n                FileUtils.copyInputStreamToFile(inputStream, file);\n                LOGGER.info(\"Copied file \" + file.getName() + \", size: \" + file.length());\n            } catch (IOException e) {\n                LOGGER.error(\"Error copying to file \" + file.getName());\n            }\n        }\n\n        FieldInfo fieldInfo = new FieldInfo();\n        fieldInfo.setName(\"dummy_column\");\n        fieldInfo.setDataType(DataType.STRING);\n        fieldInfo.setFieldAlias(fieldInfo.getName());\n        TaskResult taskResult = new TaskResult(Collections.singletonList(fieldInfo), null);\n        ExternalTaskUtil.saveExternalTaskResult(externalTaskRequestContext, new ExternalTaskResult(taskResult, true));\n    }\n}\n"}
2025-05-13 21:02:35 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:02:36 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:02:36 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:02:36 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    public static void main(String[] args) {\n        execute(ExternalTaskUtil.getExternalTaskRequestContext());\n    }\n"}
2025-05-13 21:02:37 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:02:37 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:02:37 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:02:37 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    public static void execute(ExternalTaskRequestContext externalTaskRequestContext) {\n        for (int i = 0; i < 10; i++) {\n            InputStream inputStream = ExternalTask.class.getClassLoader().getResourceAsStream(\"random.txt\");\n            File file = new File(\"random\" + i + \".txt\");\n            LOGGER.info(\"copying to file \" + file.getName());\n            try {\n                FileUtils.copyInputStreamToFile(inputStream, file);\n                LOGGER.info(\"Copied file \" + file.getName() + \", size: \" + file.length());\n            } catch (IOException e) {\n                LOGGER.error(\"Error copying to file \" + file.getName());\n            }\n        }\n\n        FieldInfo fieldInfo = new FieldInfo();\n        fieldInfo.setName(\"dummy_column\");\n        fieldInfo.setDataType(DataType.STRING);\n        fieldInfo.setFieldAlias(fieldInfo.getName());\n        TaskResult taskResult = new TaskResult(Collections.singletonList(fieldInfo), null);\n        ExternalTaskUtil.saveExternalTaskResult(externalTaskRequestContext, new ExternalTaskResult(taskResult, true));\n    }\n"}
2025-05-13 21:02:42 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:02:42 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:02:42 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:02:42 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"public class ExternalTask {\n    private static final Logger LOGGER = LoggerFactory.getLogger(ExternalTask.class.getName());\n\n    public static void main(String[] args) {\n        execute(ExternalTaskUtil.getExternalTaskRequestContext());\n    }\n\n    public static void execute(ExternalTaskRequestContext externalTaskRequestContext) {\n        for (int i = 0; i < 10; i++) {\n            InputStream inputStream = ExternalTask.class.getClassLoader().getResourceAsStream(\"random.txt\");\n            File file = new File(\"random\" + i + \".txt\");\n            LOGGER.info(\"copying to file \" + file.getName());\n            try {\n                FileUtils.copyInputStreamToFile(inputStream, file);\n                LOGGER.info(\"Copied file \" + file.getName() + \", size: \" + file.length());\n            } catch (IOException e) {\n                LOGGER.error(\"Error copying to file \" + file.getName());\n            }\n        }\n\n        FieldInfo fieldInfo = new FieldInfo();\n        fieldInfo.setName(\"dummy_column\");\n        fieldInfo.setDataType(DataType.STRING);\n        fieldInfo.setFieldAlias(fieldInfo.getName());\n        TaskResult taskResult = new TaskResult(Collections.singletonList(fieldInfo), null);\n        ExternalTaskUtil.saveExternalTaskResult(externalTaskRequestContext, new ExternalTaskResult(taskResult, true));\n    }\n}\n"}
2025-05-13 21:02:43 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:02:43 [main] INFO  c.l.service.impl.BasicL3AgentService - Processed file: /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/code/dp_dynamic_tasks/out-of-disk-space-task/src/main/java/com/gainsight/services/external/out/of/disk/space/task/ExternalTask.java with 4 chunks
2025-05-13 21:02:43 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:02:43 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:02:43 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"package com.gainsight.services.external.postgres.extraction.utils;\n\nimport com.gainsight.services.datahighway.storage.db.commons.pojo.ConnectionParamPojo;\nimport com.gainsight.services.datahighway.storage.db.commons.pojo.DBResultPojo;\nimport com.gainsight.services.dataprocessing.commons.exception.DPSystemException;\nimport com.gainsight.services.dataprocessing.commons.properties.DeploymentProperties;\nimport com.gainsight.services.dataprocessing.commons.system.CsvFile;\nimport com.gainsight.services.utilities.datahighway.dhcommons.enums.datatype.DataType;\nimport com.gainsight.services.utilities.datahighway.dhquerybuilder.constructs.custom.DateTimeProperties;\nimport com.gainsight.services.utilities.datahighway.dhquerybuilder.constructs.query.SQLQueryInfo;\nimport com.gainsight.services.utilities.datahighway.storage.db.postgres.PostgresSQLService;\nimport com.gainsight.services.utilities.datahighway.storage.db.postgres.impl.TransientPostgresSQLServiceImpl;\nimport org.apache.commons.csv.CSVFormat;\nimport org.apache.commons.csv.CSVPrinter;\nimport org.apache.commons.csv.QuoteMode;\nimport org.apache.commons.io.IOUtils;\nimport org.json.JSONArray;\nimport org.json.JSONObject;\nimport org.postgresql.copy.CopyManager;\nimport org.postgresql.core.BaseConnection;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.BufferedWriter;\nimport java.io.FileOutputStream;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.SQLException;\nimport java.sql.Timestamp;\nimport java.time.ZoneId;\nimport java.time.ZonedDateTime;\nimport java.time.format.DateTimeFormatter;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Properties;\n\nimport static com.gainsight.services.dataprocessing.commons.constants.Constants.DataExtractorConstants.SQL_EXTRACTION_QUERY_LIMIT;\nimport static com.gainsight.services.dataprocessing.commons.utils.DPUtils.msg;\n\n/**\n * @author sghosh\n * Created On: 24-May-2023\n */\n\npublic class SQLExtractHelper {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(SQLExtractHelper.class);\n\n    private final ConnectionParamPojo connectionParamPojo;\n    private final String query;\n    private final SQLQueryInfo sqlQueryInfo;\n\n    public SQLExtractHelper(ConnectionParamPojo connectionParamPojo, String query, SQLQueryInfo sqlQueryInfo) {\n        this.connectionParamPojo = connectionParamPojo;\n        this.query = query;\n        this.sqlQueryInfo = sqlQueryInfo;\n    }\n\n    public void executeQuery(CsvFile csvFile) {\n        int limit = DeploymentProperties.getDeploymentProperties().getIntegerValue(SQL_EXTRACTION_QUERY_LIMIT, 10000);\n        int offset = 0;\n        int recordsRetrieved = 0;\n        CSVPrinter csvPrinter = null;\n        PostgresSQLService dataBaseClient = null;\n        try {\n            LOGGER.info(\"Going to execute postgres query with legacy code\");\n            dataBaseClient = new TransientPostgresSQLServiceImpl(connectionParamPojo);\n            csvPrinter = new CSVPrinter(new BufferedWriter(new FileWriter(csvFile)), CSVFormat.DEFAULT.withQuoteMode(QuoteMode.NON_NUMERIC));\n            createCsvHeaderAndUpdateFile(csvPrinter, csvFile);\n            boolean done = false;\n            do {\n                String queryToExecute = query.trim() + \" offset \" + offset + \" limit \" + limit;\n                LOGGER.info(\"Started executing query: {} with legacy code\", queryToExecute);\n                DBResultPojo executeResponse = dataBaseClient.execute(queryToExecute);\n                if (!executeResponse.isSucceded()) {\n                    LOGGER.error(\"Sql query execution failed with: \", executeResponse.getCause());\n                    throw new DPSystemException(msg(\"Query execution failed because of: {}\", executeResponse.getCause().getMessage()));\n                }\n                JSONArray data = (JSONArray) executeResponse.getResult();\n                List<Object> recordList = new ArrayList<>();\n                for (int i = 0; i < data.length(); i++) {\n                    JSONObject jsonObject = data.getJSONObject(i);\n                    sqlQueryInfo.getShowFields().forEach(showField -> {\n                        String key = showField.getFieldAlias().toLowerCase();\n                        if (jsonObject.isNull(key)) {\n                            recordList.add(null);\n                        } else {\n                            if (showField.getDataType().equals(DataType.NUMBER)) {\n                                recordList.add(jsonObject.getDouble(key));\n                            } else if (showField.getDataType().equals(DataType.DATETIME)) {\n                                recordList.add(convertDateTimeFormat(jsonObject.get(key), showField.getDateTimeProperties()));\n                            } else {\n                                recordList.add(jsonObject.get(key));\n                            }\n                        }\n                    });\n                    csvPrinter.printRecord(recordList);\n                    recordList.clear();\n                }\n                offset = offset + limit;\n                recordsRetrieved = recordsRetrieved + data.length();\n                LOGGER.info(\"Retrieved {} records so far.\", recordsRetrieved);\n                if (data.length() != limit) {\n                    done = true;\n                }\n            } while (!done && !Thread.currentThread().isInterrupted());\n            csvPrinter.flush();\n            csvFile.setNumRecords(recordsRetrieved);\n            LOGGER.info(\"Total {} records retrieved for this task.\", recordsRetrieved);\n        } catch (Exception ex) {\n            LOGGER.error(msg(\"Unable to process SQL extract with legacy code due to: {}, {}\", ex.getMessage(), ex));\n            throw new DPSystemException(\"Query execution failed with legacy code for postgres/redshift/snowflake\", ex);\n        } finally {\n            IOUtils.closeQuietly(csvPrinter);\n            if (dataBaseClient != null) {\n                dataBaseClient.closeConnection();\n            }\n        }\n    }\n\n    private Object convertDateTimeFormat(Object value, DateTimeProperties dateTimeProperties) {\n        if (value instanceof Timestamp) {\n            DateTimeFormatter outputDateTimeFormatter = DateTimeFormatter.ofPattern(dateTimeProperties.getFormat());\n            ZonedDateTime utcDateTime = ((Timestamp) value).toLocalDateTime().atZone(ZoneId.of(\"UTC\"));\n            ZonedDateTime zonedDateTime = utcDateTime.withZoneSameInstant(ZoneId.of(dateTimeProperties.getTimeZoneId()));\n            return zonedDateTime.format(outputDateTimeFormatter);\n        } else {\n            return value;\n        }\n    }\n\n    public void executeQueryWithPostgresCopyManager(CsvFile csvFile) throws IOException, SQLException {\n        int recordsRetrieved = 0;\n        Connection jdbcConnection = null;\n        FileOutputStream fileOutputStream = null;\n        Properties properties = new Properties();\n        try {\n            LOGGER.info(\"Going to execute postgres query with copy manager\");\n            com.gainsight.services.dataprocessing.database.commons.pojo.ConnectionParamPojo connectionParamPojoForCopyManager = new com.gainsight.services.dataprocessing.database.commons.pojo.ConnectionParamPojo(\n                    connectionParamPojo.getJdbcUrl(), connectionParamPojo.getUserName(), connectionParamPojo.getPassword(), connectionParamPojo.getConnectionPoolSize(), connectionParamPojo.getConnectionPoolName(), connectionParamPojo.isSslEnabled());\n            createCsvHeaderAndUpdateFileCopyManager(csvFile);\n            properties.setProperty(\"user\", connectionParamPojo.getUserName());\n            properties.setProperty(\"password\", connectionParamPojo.getPassword());\n            if (connectionParamPojo.isSslEnabled()) {\n                properties.setProperty(\"sslmode\", \"require\");\n                properties.setProperty(\"ssl\", \"true\");\n            }\n            jdbcConnection = DriverManager.getConnection(connectionParamPojoForCopyManager.getJdbcUrl(), properties);\n            CopyManager copyManager = new CopyManager((BaseConnection) jdbcConnection);\n            fileOutputStream = new FileOutputStream(csvFile, true);\n            String refinedQuery = query.trim();\n            String copyManagerQuery = \"COPY (\" + refinedQuery + \") TO STDOUT WITH (FORMAT CSV, HEADER true, QUOTE '\\\"', ESCAPE '\\\"', ENCODING 'UTF8')\";\n            LOGGER.info(\"Started executing query: {} with copyManager\", copyManagerQuery);\n            if (!Thread.currentThread().isInterrupted()) {\n                recordsRetrieved = Math.toIntExact(copyManager.copyOut(copyManagerQuery, fileOutputStream));\n            }\n            csvFile.setNumRecords(recordsRetrieved);\n            LOGGER.info(\"Total {} records retrieved for this task.\", recordsRetrieved);\n        } catch (Exception ex) {\n            LOGGER.error(msg(\"Error while executing postgres query with copy manager due to : {}, {}\", ex.getMessage(), ex));\n            throw new DPSystemException(\"Query execution failed with postgres copy manager\", ex);\n        } finally {\n            if (fileOutputStream != null) {\n                fileOutputStream.close();\n            }\n            if (jdbcConnection != null) {\n                jdbcConnection.close();\n            }\n        }\n    }\n\n    private void createCsvHeaderAndUpdateFileCopyManager(CsvFile csvFile) {\n        List<String> headers = new ArrayList<>();\n        sqlQueryInfo.getShowFields().forEach(showField -> headers.add(showField.getFieldAlias()));\n        LOGGER.info(\"Started writing headers {} to csv file for copy manager\", headers);\n        csvFile.setHeaders(headers);\n    }\n\n    private void createCsvHeaderAndUpdateFile(CSVPrinter csvPrinter, CsvFile csvFile) {\n        List<String> headers = new ArrayList<>();\n        sqlQueryInfo.getShowFields().forEach(showField -> headers.add(showField.getFieldAlias()));\n        try {\n            LOGGER.info(\"Started writing headers {} to csv file\", headers);\n            csvPrinter.printRecord(headers);\n            csvFile.setHeaders(headers);\n        } catch (IOException e) {\n            LOGGER.error(e.getMessage(), e);\n            throw new DPSystemException(e.getMessage(), e);\n        }\n    }\n}\n\n"}
2025-05-13 21:02:45 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:02:45 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:02:45 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:02:45 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    public SQLExtractHelper(ConnectionParamPojo connectionParamPojo, String query, SQLQueryInfo sqlQueryInfo) {\n        this.connectionParamPojo = connectionParamPojo;\n        this.query = query;\n        this.sqlQueryInfo = sqlQueryInfo;\n    }\n"}
2025-05-13 21:02:46 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:02:46 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:02:46 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:02:46 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    public void executeQuery(CsvFile csvFile) {\n        int limit = DeploymentProperties.getDeploymentProperties().getIntegerValue(SQL_EXTRACTION_QUERY_LIMIT, 10000);\n        int offset = 0;\n        int recordsRetrieved = 0;\n        CSVPrinter csvPrinter = null;\n        PostgresSQLService dataBaseClient = null;\n        try {\n            LOGGER.info(\"Going to execute postgres query with legacy code\");\n            dataBaseClient = new TransientPostgresSQLServiceImpl(connectionParamPojo);\n            csvPrinter = new CSVPrinter(new BufferedWriter(new FileWriter(csvFile)), CSVFormat.DEFAULT.withQuoteMode(QuoteMode.NON_NUMERIC));\n            createCsvHeaderAndUpdateFile(csvPrinter, csvFile);\n            boolean done = false;\n            do {\n                String queryToExecute = query.trim() + \" offset \" + offset + \" limit \" + limit;\n                LOGGER.info(\"Started executing query: {} with legacy code\", queryToExecute);\n                DBResultPojo executeResponse = dataBaseClient.execute(queryToExecute);\n                if (!executeResponse.isSucceded()) {\n                    LOGGER.error(\"Sql query execution failed with: \", executeResponse.getCause());\n                    throw new DPSystemException(msg(\"Query execution failed because of: {}\", executeResponse.getCause().getMessage()));\n                }\n                JSONArray data = (JSONArray) executeResponse.getResult();\n                List<Object> recordList = new ArrayList<>();\n                for (int i = 0; i < data.length(); i++) {\n                    JSONObject jsonObject = data.getJSONObject(i);\n                    sqlQueryInfo.getShowFields().forEach(showField -> {\n                        String key = showField.getFieldAlias().toLowerCase();\n                        if (jsonObject.isNull(key)) {\n                            recordList.add(null);\n                        } else {\n                            if (showField.getDataType().equals(DataType.NUMBER)) {\n                                recordList.add(jsonObject.getDouble(key));\n                            } else if (showField.getDataType().equals(DataType.DATETIME)) {\n                                recordList.add(convertDateTimeFormat(jsonObject.get(key), showField.getDateTimeProperties()));\n                            } else {\n                                recordList.add(jsonObject.get(key));\n                            }\n                        }\n                    });\n                    csvPrinter.printRecord(recordList);\n                    recordList.clear();\n                }\n                offset = offset + limit;\n                recordsRetrieved = recordsRetrieved + data.length();\n                LOGGER.info(\"Retrieved {} records so far.\", recordsRetrieved);\n                if (data.length() != limit) {\n                    done = true;\n                }\n            } while (!done && !Thread.currentThread().isInterrupted());\n            csvPrinter.flush();\n            csvFile.setNumRecords(recordsRetrieved);\n            LOGGER.info(\"Total {} records retrieved for this task.\", recordsRetrieved);\n        } catch (Exception ex) {\n            LOGGER.error(msg(\"Unable to process SQL extract with legacy code due to: {}, {}\", ex.getMessage(), ex));\n            throw new DPSystemException(\"Query execution failed with legacy code for postgres/redshift/snowflake\", ex);\n        } finally {\n            IOUtils.closeQuietly(csvPrinter);\n            if (dataBaseClient != null) {\n                dataBaseClient.closeConnection();\n            }\n        }\n    }\n"}
2025-05-13 21:02:48 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:02:48 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:02:48 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:02:48 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    private Object convertDateTimeFormat(Object value, DateTimeProperties dateTimeProperties) {\n        if (value instanceof Timestamp) {\n            DateTimeFormatter outputDateTimeFormatter = DateTimeFormatter.ofPattern(dateTimeProperties.getFormat());\n            ZonedDateTime utcDateTime = ((Timestamp) value).toLocalDateTime().atZone(ZoneId.of(\"UTC\"));\n            ZonedDateTime zonedDateTime = utcDateTime.withZoneSameInstant(ZoneId.of(dateTimeProperties.getTimeZoneId()));\n            return zonedDateTime.format(outputDateTimeFormatter);\n        } else {\n            return value;\n        }\n    }\n"}
2025-05-13 21:02:49 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:02:49 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:02:49 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:02:49 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    public void executeQueryWithPostgresCopyManager(CsvFile csvFile) throws IOException, SQLException {\n        int recordsRetrieved = 0;\n        Connection jdbcConnection = null;\n        FileOutputStream fileOutputStream = null;\n        Properties properties = new Properties();\n        try {\n            LOGGER.info(\"Going to execute postgres query with copy manager\");\n            com.gainsight.services.dataprocessing.database.commons.pojo.ConnectionParamPojo connectionParamPojoForCopyManager = new com.gainsight.services.dataprocessing.database.commons.pojo.ConnectionParamPojo(\n                    connectionParamPojo.getJdbcUrl(), connectionParamPojo.getUserName(), connectionParamPojo.getPassword(), connectionParamPojo.getConnectionPoolSize(), connectionParamPojo.getConnectionPoolName(), connectionParamPojo.isSslEnabled());\n            createCsvHeaderAndUpdateFileCopyManager(csvFile);\n            properties.setProperty(\"user\", connectionParamPojo.getUserName());\n            properties.setProperty(\"password\", connectionParamPojo.getPassword());\n            if (connectionParamPojo.isSslEnabled()) {\n                properties.setProperty(\"sslmode\", \"require\");\n                properties.setProperty(\"ssl\", \"true\");\n            }\n            jdbcConnection = DriverManager.getConnection(connectionParamPojoForCopyManager.getJdbcUrl(), properties);\n            CopyManager copyManager = new CopyManager((BaseConnection) jdbcConnection);\n            fileOutputStream = new FileOutputStream(csvFile, true);\n            String refinedQuery = query.trim();\n            String copyManagerQuery = \"COPY (\" + refinedQuery + \") TO STDOUT WITH (FORMAT CSV, HEADER true, QUOTE '\\\"', ESCAPE '\\\"', ENCODING 'UTF8')\";\n            LOGGER.info(\"Started executing query: {} with copyManager\", copyManagerQuery);\n            if (!Thread.currentThread().isInterrupted()) {\n                recordsRetrieved = Math.toIntExact(copyManager.copyOut(copyManagerQuery, fileOutputStream));\n            }\n            csvFile.setNumRecords(recordsRetrieved);\n            LOGGER.info(\"Total {} records retrieved for this task.\", recordsRetrieved);\n        } catch (Exception ex) {\n            LOGGER.error(msg(\"Error while executing postgres query with copy manager due to : {}, {}\", ex.getMessage(), ex));\n            throw new DPSystemException(\"Query execution failed with postgres copy manager\", ex);\n        } finally {\n            if (fileOutputStream != null) {\n                fileOutputStream.close();\n            }\n            if (jdbcConnection != null) {\n                jdbcConnection.close();\n            }\n        }\n    }\n"}
2025-05-13 21:02:50 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:02:50 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:02:50 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:02:50 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    private void createCsvHeaderAndUpdateFileCopyManager(CsvFile csvFile) {\n        List<String> headers = new ArrayList<>();\n        sqlQueryInfo.getShowFields().forEach(showField -> headers.add(showField.getFieldAlias()));\n        LOGGER.info(\"Started writing headers {} to csv file for copy manager\", headers);\n        csvFile.setHeaders(headers);\n    }\n"}
2025-05-13 21:02:52 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:02:52 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:02:52 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:02:52 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    private void createCsvHeaderAndUpdateFile(CSVPrinter csvPrinter, CsvFile csvFile) {\n        List<String> headers = new ArrayList<>();\n        sqlQueryInfo.getShowFields().forEach(showField -> headers.add(showField.getFieldAlias()));\n        try {\n            LOGGER.info(\"Started writing headers {} to csv file\", headers);\n            csvPrinter.printRecord(headers);\n            csvFile.setHeaders(headers);\n        } catch (IOException e) {\n            LOGGER.error(e.getMessage(), e);\n            throw new DPSystemException(e.getMessage(), e);\n        }\n    }\n"}
2025-05-13 21:02:53 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:02:53 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:02:53 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:02:53 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"public class SQLExtractHelper {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(SQLExtractHelper.class);\n\n    private final ConnectionParamPojo connectionParamPojo;\n    private final String query;\n    private final SQLQueryInfo sqlQueryInfo;\n\n    public SQLExtractHelper(ConnectionParamPojo connectionParamPojo, String query, SQLQueryInfo sqlQueryInfo) {\n        this.connectionParamPojo = connectionParamPojo;\n        this.query = query;\n        this.sqlQueryInfo = sqlQueryInfo;\n    }\n\n    public void executeQuery(CsvFile csvFile) {\n        int limit = DeploymentProperties.getDeploymentProperties().getIntegerValue(SQL_EXTRACTION_QUERY_LIMIT, 10000);\n        int offset = 0;\n        int recordsRetrieved = 0;\n        CSVPrinter csvPrinter = null;\n        PostgresSQLService dataBaseClient = null;\n        try {\n            LOGGER.info(\"Going to execute postgres query with legacy code\");\n            dataBaseClient = new TransientPostgresSQLServiceImpl(connectionParamPojo);\n            csvPrinter = new CSVPrinter(new BufferedWriter(new FileWriter(csvFile)), CSVFormat.DEFAULT.withQuoteMode(QuoteMode.NON_NUMERIC));\n            createCsvHeaderAndUpdateFile(csvPrinter, csvFile);\n            boolean done = false;\n            do {\n                String queryToExecute = query.trim() + \" offset \" + offset + \" limit \" + limit;\n                LOGGER.info(\"Started executing query: {} with legacy code\", queryToExecute);\n                DBResultPojo executeResponse = dataBaseClient.execute(queryToExecute);\n                if (!executeResponse.isSucceded()) {\n                    LOGGER.error(\"Sql query execution failed with: \", executeResponse.getCause());\n                    throw new DPSystemException(msg(\"Query execution failed because of: {}\", executeResponse.getCause().getMessage()));\n                }\n                JSONArray data = (JSONArray) executeResponse.getResult();\n                List<Object> recordList = new ArrayList<>();\n                for (int i = 0; i < data.length(); i++) {\n                    JSONObject jsonObject = data.getJSONObject(i);\n                    sqlQueryInfo.getShowFields().forEach(showField -> {\n                        String key = showField.getFieldAlias().toLowerCase();\n                        if (jsonObject.isNull(key)) {\n                            recordList.add(null);\n                        } else {\n                            if (showField.getDataType().equals(DataType.NUMBER)) {\n                                recordList.add(jsonObject.getDouble(key));\n                            } else if (showField.getDataType().equals(DataType.DATETIME)) {\n                                recordList.add(convertDateTimeFormat(jsonObject.get(key), showField.getDateTimeProperties()));\n                            } else {\n                                recordList.add(jsonObject.get(key));\n                            }\n                        }\n                    });\n                    csvPrinter.printRecord(recordList);\n                    recordList.clear();\n                }\n                offset = offset + limit;\n                recordsRetrieved = recordsRetrieved + data.length();\n                LOGGER.info(\"Retrieved {} records so far.\", recordsRetrieved);\n                if (data.length() != limit) {\n                    done = true;\n                }\n            } while (!done && !Thread.currentThread().isInterrupted());\n            csvPrinter.flush();\n            csvFile.setNumRecords(recordsRetrieved);\n            LOGGER.info(\"Total {} records retrieved for this task.\", recordsRetrieved);\n        } catch (Exception ex) {\n            LOGGER.error(msg(\"Unable to process SQL extract with legacy code due to: {}, {}\", ex.getMessage(), ex));\n            throw new DPSystemException(\"Query execution failed with legacy code for postgres/redshift/snowflake\", ex);\n        } finally {\n            IOUtils.closeQuietly(csvPrinter);\n            if (dataBaseClient != null) {\n                dataBaseClient.closeConnection();\n            }\n        }\n    }\n\n    private Object convertDateTimeFormat(Object value, DateTimeProperties dateTimeProperties) {\n        if (value instanceof Timestamp) {\n            DateTimeFormatter outputDateTimeFormatter = DateTimeFormatter.ofPattern(dateTimeProperties.getFormat());\n            ZonedDateTime utcDateTime = ((Timestamp) value).toLocalDateTime().atZone(ZoneId.of(\"UTC\"));\n            ZonedDateTime zonedDateTime = utcDateTime.withZoneSameInstant(ZoneId.of(dateTimeProperties.getTimeZoneId()));\n            return zonedDateTime.format(outputDateTimeFormatter);\n        } else {\n            return value;\n        }\n    }\n\n    public void executeQueryWithPostgresCopyManager(CsvFile csvFile) throws IOException, SQLException {\n        int recordsRetrieved = 0;\n        Connection jdbcConnection = null;\n        FileOutputStream fileOutputStream = null;\n        Properties properties = new Properties();\n        try {\n            LOGGER.info(\"Going to execute postgres query with copy manager\");\n            com.gainsight.services.dataprocessing.database.commons.pojo.ConnectionParamPojo connectionParamPojoForCopyManager = new com.gainsight.services.dataprocessing.database.commons.pojo.ConnectionParamPojo(\n                    connectionParamPojo.getJdbcUrl(), connectionParamPojo.getUserName(), connectionParamPojo.getPassword(), connectionParamPojo.getConnectionPoolSize(), connectionParamPojo.getConnectionPoolName(), connectionParamPojo.isSslEnabled());\n            createCsvHeaderAndUpdateFileCopyManager(csvFile);\n            properties.setProperty(\"user\", connectionParamPojo.getUserName());\n            properties.setProperty(\"password\", connectionParamPojo.getPassword());\n            if (connectionParamPojo.isSslEnabled()) {\n                properties.setProperty(\"sslmode\", \"require\");\n                properties.setProperty(\"ssl\", \"true\");\n            }\n            jdbcConnection = DriverManager.getConnection(connectionParamPojoForCopyManager.getJdbcUrl(), properties);\n            CopyManager copyManager = new CopyManager((BaseConnection) jdbcConnection);\n            fileOutputStream = new FileOutputStream(csvFile, true);\n            String refinedQuery = query.trim();\n            String copyManagerQuery = \"COPY (\" + refinedQuery + \") TO STDOUT WITH (FORMAT CSV, HEADER true, QUOTE '\\\"', ESCAPE '\\\"', ENCODING 'UTF8')\";\n            LOGGER.info(\"Started executing query: {} with copyManager\", copyManagerQuery);\n            if (!Thread.currentThread().isInterrupted()) {\n                recordsRetrieved = Math.toIntExact(copyManager.copyOut(copyManagerQuery, fileOutputStream));\n            }\n            csvFile.setNumRecords(recordsRetrieved);\n            LOGGER.info(\"Total {} records retrieved for this task.\", recordsRetrieved);\n        } catch (Exception ex) {\n            LOGGER.error(msg(\"Error while executing postgres query with copy manager due to : {}, {}\", ex.getMessage(), ex));\n            throw new DPSystemException(\"Query execution failed with postgres copy manager\", ex);\n        } finally {\n            if (fileOutputStream != null) {\n                fileOutputStream.close();\n            }\n            if (jdbcConnection != null) {\n                jdbcConnection.close();\n            }\n        }\n    }\n\n    private void createCsvHeaderAndUpdateFileCopyManager(CsvFile csvFile) {\n        List<String> headers = new ArrayList<>();\n        sqlQueryInfo.getShowFields().forEach(showField -> headers.add(showField.getFieldAlias()));\n        LOGGER.info(\"Started writing headers {} to csv file for copy manager\", headers);\n        csvFile.setHeaders(headers);\n    }\n\n    private void createCsvHeaderAndUpdateFile(CSVPrinter csvPrinter, CsvFile csvFile) {\n        List<String> headers = new ArrayList<>();\n        sqlQueryInfo.getShowFields().forEach(showField -> headers.add(showField.getFieldAlias()));\n        try {\n            LOGGER.info(\"Started writing headers {} to csv file\", headers);\n            csvPrinter.printRecord(headers);\n            csvFile.setHeaders(headers);\n        } catch (IOException e) {\n            LOGGER.error(e.getMessage(), e);\n            throw new DPSystemException(e.getMessage(), e);\n        }\n    }\n}\n"}
2025-05-13 21:02:54 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:02:54 [main] INFO  c.l.service.impl.BasicL3AgentService - Processed file: /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/code/dp_dynamic_tasks/postgres-extraction-task/src/main/java/com/gainsight/services/external/postgres/extraction/utils/SQLExtractHelper.java with 8 chunks
2025-05-13 21:02:54 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:02:54 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:02:54 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"package com.gainsight.services.external.postgres.extraction.task;\n\nimport com.fasterxml.jackson.core.type.TypeReference;\nimport com.gainsight.services.datahighway.storage.db.commons.pojo.ConnectionParamPojo;\nimport com.gainsight.services.dataprocessing.commons.audit.AuditMetadata;\nimport com.gainsight.services.dataprocessing.commons.cryptography.CryptUtil;\nimport com.gainsight.services.dataprocessing.commons.exception.DPSystemException;\nimport com.gainsight.services.dataprocessing.commons.pojo.fields.FieldInfo;\nimport com.gainsight.services.dataprocessing.commons.pojo.workflow.DPWorkflowJobDetailsDTO;\nimport com.gainsight.services.dataprocessing.commons.properties.DeploymentProperties;\nimport com.gainsight.services.dataprocessing.commons.proxy.mda.CustomerCurrencyDTO;\nimport com.gainsight.services.dataprocessing.commons.system.CsvFile;\nimport com.gainsight.services.dataprocessing.commons.utils.DPCollectionUtils;\nimport com.gainsight.services.dataprocessing.commons.utils.DPUtils;\nimport com.gainsight.services.dataprocessing.dataexternals.mda.MDACalloutsService;\nimport com.gainsight.services.dataprocessing.dataexternals.mda.MDACalloutsServiceImpl;\nimport com.gainsight.services.dataprocessing.dataprocessor.dagdataprocessor.pojo.ExternalExtractionTaskResult;\nimport com.gainsight.services.dataprocessing.dataprocessor.dagdataprocessor.pojo.TaskResult;\nimport com.gainsight.services.dataprocessing.dataprocessor.dagdataprocessor.utils.CustomerCurrencyUtil;\nimport com.gainsight.services.dataprocessing.dataprocessor.dagdataprocessor.utils.TaskExecutorWorkflowUtils;\nimport com.gainsight.services.dataprocessing.external.task.ExternalTaskRequestContext;\nimport com.gainsight.services.dataprocessing.external.task.ExternalTaskUtil;\nimport com.gainsight.services.external.postgres.extraction.utils.SQLExtractHelper;\nimport com.gainsight.services.utilities.datahighway.dhcommons.pojo.base.connection.ConnectorType;\nimport com.gainsight.services.utilities.datahighway.dhcommons.pojo.base.connection.PNPConnectionInput;\nimport com.gainsight.services.utilities.datahighway.dhcommons.pojo.base.connection.RelationalDBConnectionDetail;\nimport com.gainsight.services.utilities.datahighway.dhcommons.pojo.query.QuerySourceType;\nimport com.gainsight.services.utilities.datahighway.dhquerybuilder.builders.FreeFormQueryBuilder;\nimport com.gainsight.services.utilities.datahighway.dhquerybuilder.constructs.query.QueryBuilderResponse;\nimport com.gainsight.services.utilities.datahighway.dhquerybuilder.constructs.query.SQLQueryInfo;\nimport com.gainsight.services.utilities.datahighway.dhquerybuilder.helpers.SqlQueryBuilderHelper;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport org.apache.commons.collections.MapUtils;\nimport org.apache.commons.collections4.CollectionUtils;\nimport org.apache.commons.csv.CSVFormat;\nimport org.apache.commons.csv.CSVParser;\nimport org.apache.commons.csv.CSVRecord;\nimport org.apache.commons.csv.QuoteMode;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang3.RandomStringUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.*;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.sql.SQLException;\nimport java.util.*;\nimport java.util.stream.Collectors;\n\nimport static com.gainsight.services.dataprocessing.commons.constants.Constants.*;\nimport static com.gainsight.services.dataprocessing.commons.constants.Constants.DataExtractorConstants.SQL_EXTRACTION_DB_CONNECTION_POOL_SIZE;\nimport static com.gainsight.services.dataprocessing.commons.constants.Constants.WorkflowConstants.SQL_EXTRACTION_DETAILS_KEY;\nimport static com.gainsight.services.dataprocessing.commons.exception.ValidationCode.GENERIC_SYSTEM_ERROR;\nimport static com.gainsight.services.dataprocessing.commons.pojo.DataType.DATE;\nimport static com.gainsight.services.dataprocessing.commons.pojo.DataType.DATETIME;\nimport static com.gainsight.services.dataprocessing.commons.properties.DeploymentProperties.getDeploymentProperties;\nimport static com.gainsight.services.dataprocessing.commons.system.Precondition.isNotBlank;\nimport static com.gainsight.services.dataprocessing.commons.system.Precondition.isNotNull;\nimport static com.gainsight.services.dataprocessing.commons.utils.DPUtils.convertJsonToObject;\nimport static com.gainsight.services.dataprocessing.commons.utils.DPUtils.msg;\n\npublic class PostgresExtractionTask {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(PostgresExtractionTask.class);\n    private static final String connectionPoolName = \"DynamicSQLExtractPool_\" + RandomStringUtils.randomAlphanumeric(8);\n    private static final String EPOCH_DATETIME_FORMAT = \"epoch\";\n    private static final String POSTGRES_COPY_MANAGER_EXCLUDED_TENANTS = \"postgres.copy.manager.excluded.tenants\";\n    private static final String DISABLE_POSTGRES_COPY_MANAGER = \"disable.postgres.copy.manager\";\n    private static final String ENABLE_POSTGRES_EXTRACT_SAMPLE_LOGGING = \"enable.postgres.extract.sample.logging\";\n    private static final String POSTGRES_EXTRACT_SAMPLE_LOG_RECORD_SIZE = \"postgres.extract.sample.log.record.size\";\n    private static final String POSTGRES_EXTRACT_SAMPLE_LOG_INCLUDE_ALL_COLUMNS = \"postgres.extract.sample.log.include.all.columns\";\n    private static final String POSTGRES_EXTRACT_DEFAULT_DATETIME_FORMAT = \"postgres.extract.default.datetime.format\";\n\n    public static void main(String[] args) {\n        executeTask(ExternalTaskUtil.getExternalTaskRequestContext());\n    }\n\n    private static void executeTask(ExternalTaskRequestContext externalTaskRequestContext) {\n        try {\n            String jobId = externalTaskRequestContext.getJobId();\n            String tenantId = externalTaskRequestContext.getTenantId();\n            Map<String, String> metaData = externalTaskRequestContext.getMetaData();\n            SQLQueryInfo sqlQueryInfo = convertJsonToObject(metaData.get(SQL_EXTRACTION_DETAILS_KEY), SQLQueryInfo.class);\n            isNotNull(sqlQueryInfo, GENERIC_SYSTEM_ERROR, msg(\"Could not get valid sqlExtractionDetails from task metadata for jobId:{} and tenantId:{}\", jobId, tenantId));\n            LOGGER.info(\"SQL Query info for job:{} of tenant:{} is::{}\", jobId, tenantId, DPUtils.convertObjectToJson(sqlQueryInfo));\n\n            DPWorkflowJobDetailsDTO dpWorkflowJobDetailsDTO = externalTaskRequestContext.getWorkflowJobDetails();\n            AuditMetadata auditMetadata = AuditMetadata.newInstance(tenantId, jobId, dpWorkflowJobDetailsDTO.getExternalId(), externalTaskRequestContext.getTaskId(), externalTaskRequestContext.getTaskName());\n            String configSourceUrl = TaskExecutorWorkflowUtils.getConfigSourceUrl(dpWorkflowJobDetailsDTO);\n            String gsB2BSecret = getDeploymentProperties().getValue(MDA_GAINSIGHT_B2B_SECRET);\n\n            ConnectorType connectorType;\n            RelationalDBConnectionDetail relationalDBConnectionDetail;\n            if (null != sqlQueryInfo.getConnectionInfo()) {\n                isNotBlank(sqlQueryInfo.getConnectionInfo().getConnectionId(), GENERIC_SYSTEM_ERROR, msg(\"No connectionId provided against jobId:{} and tenant:{}\", jobId, tenantId));\n                MDACalloutsService mdaCalloutsService = new MDACalloutsServiceImpl(gsB2BSecret, configSourceUrl);\n                PNPConnectionInput pnpConnectionInfo = mdaCalloutsService.getConnectionDetails(sqlQueryInfo.getConnectionInfo().getConnectionId(), tenantId);\n                LOGGER.info(\"PNPConnectionInput fetched successfully for connectionId: {} tenantId: {}\", sqlQueryInfo.getConnectionInfo().getConnectionId(), tenantId);\n                sqlQueryInfo.getConnectionInfo().setConnectorType(ConnectorType.HAPOSTGRES);\n\n                if (pnpConnectionInfo.getPnpConnectionsInfo().getConnectionDetail() instanceof RelationalDBConnectionDetail) {\n                    relationalDBConnectionDetail = (RelationalDBConnectionDetail) pnpConnectionInfo.getPnpConnectionsInfo().getConnectionDetail();\n                    connectorType = ConnectorType.valueOf(relationalDBConnectionDetail.getType());\n                } else {\n                    throw new DPSystemException(msg(\"Provided connectionDetail: {} is not registered with us. Please contact tech support!!\", DPUtils.convertObjectToJson(pnpConnectionInfo.getPnpConnectionsInfo().getConnectionDetail())));\n                }\n            } else if (sqlQueryInfo.getConnectionDetail() instanceof RelationalDBConnectionDetail) {\n                LOGGER.info(\"ConnectionInfo is null. Fetching connection details from sqlExtractionDetails connectionDetails for jobId:{}\", jobId);\n                relationalDBConnectionDetail = (RelationalDBConnectionDetail) sqlQueryInfo.getConnectionDetail();\n                connectorType = ConnectorType.valueOf(relationalDBConnectionDetail.getType());\n            } else {\n                throw new DPSystemException(\"Please provide either valid connectionInfo or connectionDetail\");\n            }\n            CsvFile csvFile;\n            List<String> copyManagerExcludedTenants = Lists.newArrayList();\n            String excludedTenants = DeploymentProperties.getDeploymentProperties().getValue(POSTGRES_COPY_MANAGER_EXCLUDED_TENANTS);\n            if (StringUtils.isNotBlank(excludedTenants)) {\n                copyManagerExcludedTenants.addAll(Arrays.asList(excludedTenants.split(COMMA)));\n            }\n            boolean disableCopyManager = DeploymentProperties.getDeploymentProperties().getBooleanValue(DISABLE_POSTGRES_COPY_MANAGER, false);\n            if (disableCopyManager || copyManagerExcludedTenants.contains(tenantId)) {\n                LOGGER.warn(\"Skipping postgres copyManager execution for job:{} of tenant:{} since either it is restricted for this tenant or copy manager is disabled. Will proceed with legacy code though!!\", jobId, tenantId);\n                csvFile = executeQueryForPostgresOrRedshift(externalTaskRequestContext, externalTaskRequestContext.getWorkflowSystemProperties(), sqlQueryInfo, relationalDBConnectionDetail);\n            } else {\n                try {\n                    csvFile = executeQueryForPostgresCopyManager(externalTaskRequestContext, externalTaskRequestContext.getWorkflowSystemProperties(), sqlQueryInfo, relationalDBConnectionDetail);\n                } catch (Exception ex) {\n                    LOGGER.warn(msg(\"SQL Extraction for {} failed with copy manager functionality due to: {} \", connectorType, ex.getMessage()));\n                    LOGGER.warn(\"More details about the exception are: \", ex);\n                    if (!Thread.currentThread().isInterrupted()) {\n                        LOGGER.warn(\"Falling back to legacy code since copy manager did not give us what we wanted!!\");\n                        csvFile = executeQueryForPostgresOrRedshift(externalTaskRequestContext, externalTaskRequestContext.getWorkflowSystemProperties(), sqlQueryInfo, relationalDBConnectionDetail);\n                    } else {\n                        LOGGER.info(\"Query execution failed without falling back to legacy code.\");\n                        throw ex;\n                    }\n                }\n            }\n            List<FieldInfo> headers = DPUtils.convertJsonToObject(DPUtils.convertObjectToJson(sqlQueryInfo.getShowFields()), new TypeReference<List<FieldInfo>>() {\n            });\n            TaskResult taskResult = new TaskResult(headers, null);\n            char delimiter = csvFile.getDelimiter() != null ? csvFile.getDelimiter().charAt(0) : COMMA.charAt(0);\n\n            Map<String, CustomerCurrencyDTO> currencyConversionMap = null;\n            if (DPUtils.isCurrencyConversionMapRequired(headers)) {\n                currencyConversionMap = CustomerCurrencyUtil.getCustomerCurrencyConversionMap(configSourceUrl, auditMetadata, true);\n            }\n\n            /*\n                Printing specified number of records for columns having dataType as date/dateTime only to find out format and other\n                discrepancies(if any). Since date/dateTime data is always a glitch in the matrix.\n                Based on config server property.\n             */\n            if (DeploymentProperties.getDeploymentProperties().getBooleanValue(ENABLE_POSTGRES_EXTRACT_SAMPLE_LOGGING, false)) {\n                logDateOrDateTimeData(tenantId, jobId, headers, csvFile);\n            }\n\n            ExternalExtractionTaskResult externalExtractionTaskResult = new ExternalExtractionTaskResult.ExternalExtractionTaskResultBuilder()\n                    .setWithHeader(true)\n                    .setDelimiter(delimiter)\n                    .setTaskResult(taskResult)\n                    .setCurrencyConversionMap(currencyConversionMap)\n                    .setExtractedFiles(Collections.singletonList(csvFile.getAbsolutePath()))\n                    .build();\n\n            //Saving externalTask Result.\n            saveExtractionTaskResult(tenantId, jobId, externalTaskRequestContext.getTaskId(), externalExtractionTaskResult);\n            LOGGER.info(\"Successfully saved externalTask result for jobId:{}, tenantId:{}\", jobId, tenantId);\n        } catch (DPSystemException dpSysEx) {\n            LOGGER.error(\"Error while performing jdbc extraction - taskId: {}, jobId: {}, tenantId: {}\", externalTaskRequestContext.getTaskId(), externalTaskRequestContext.getJobId(), externalTaskRequestContext.getTenantId(), dpSysEx);\n            throw dpSysEx;\n        } catch (Exception ex) {\n            LOGGER.error(\"Error while performing jdbc extraction - taskId: {}, jobId: {}, tenantId: {}\", externalTaskRequestContext.getTaskId(), externalTaskRequestContext.getJobId(), externalTaskRequestContext.getTenantId(), ex);\n            throw new DPSystemException(msg(\"Error while performing jdbc extraction: {}\", ex.getMessage()), ex);\n        }\n    }\n\n    private static CsvFile executeQueryForPostgresCopyManager(ExternalTaskRequestContext externalTaskRequestContext, Map<String, Object> workflowSystemProperties, SQLQueryInfo sqlQueryInfo, RelationalDBConnectionDetail dbConnectionDetail) throws SQLException, IOException {\n        try {\n            QueryBuilderResponse postgresExtract = new FreeFormQueryBuilder().with(sqlQueryInfo)\n                    .withQueryBuilderHelper(new SqlQueryBuilderHelper(ConnectorType.POSTGRES))\n                    .withQuerySourceType(QuerySourceType.SQL)\n                    .withSystemProperties(workflowSystemProperties)\n                    .build();\n            String postgresExtractQuery = postgresExtract.getQuery();\n            String connectionUrl = \"jdbc:postgresql://\" + CryptUtil.decrypt(dbConnectionDetail.getHost()) + \":\" + CryptUtil.decrypt(dbConnectionDetail.getPort()) + \"/\" + CryptUtil.decrypt(dbConnectionDetail.getDataBaseName()) + \"?ssl=\" + dbConnectionDetail.isSslEnabled();\n            ConnectionParamPojo connectionParamPojo = new ConnectionParamPojo(connectionUrl, CryptUtil.decrypt(dbConnectionDetail.getUser()), CryptUtil.decrypt(dbConnectionDetail.getPwd()), getDeploymentProperties().getIntegerValue(SQL_EXTRACTION_DB_CONNECTION_POOL_SIZE, 1), connectionPoolName, dbConnectionDetail.isSslEnabled());\n            String tableSchema = \"public\";\n            if (MapUtils.isNotEmpty(dbConnectionDetail.getProperties()) && StringUtils.isNotBlank(DPUtils.valueOf(dbConnectionDetail.getProperties().get(\"tablesSchema\")))) {\n                tableSchema = CryptUtil.decrypt(DPUtils.valueOf(dbConnectionDetail.getProperties().get(\"tablesSchema\")));\n                LOGGER.info(msg(\"Using tablesSchema: {} from properties for connectionId {}.\", tableSchema, sqlQueryInfo.getConnectionInfo().getConnectionId()));\n            } else {\n                LOGGER.warn(msg(\"Did not find tablesSchema in properties, proceeding with public schema for connectionId {}.\", sqlQueryInfo.getConnectionInfo().getConnectionId()));\n            }\n            postgresExtractQuery = modifyFromClauseForRedshiftAndPostgres(postgresExtractQuery, tableSchema);\n            LOGGER.info(\"Postgres Extract Query: {}\", postgresExtractQuery);\n            SQLExtractHelper sqlExtractHelper = new SQLExtractHelper(connectionParamPojo, postgresExtractQuery, sqlQueryInfo);\n            CsvFile csvFile = getCsvFileForSQLExtract(externalTaskRequestContext.getTenantId(), externalTaskRequestContext.getJobId(), externalTaskRequestContext.getTaskId());\n            sqlExtractHelper.executeQueryWithPostgresCopyManager(csvFile);\n            LOGGER.info(\"Postgres SQL Query Executed Successfully with copy manager!!\");\n            return csvFile;\n        } catch (Exception ex) {\n            LOGGER.error(\"SQL query execution failed: {}. {}.\", ex.getMessage(), ex);\n            throw new DPSystemException(\"SQL query execution failed.\", ex);\n        }\n    }\n\n    private static CsvFile getCsvFileForSQLExtract(String tenantId, String jobId, String taskId) throws IOException {\n        String tempFilePath = DPUtils.getTempFilePath(tenantId, jobId, taskId, UUID.randomUUID().toString() + \".csv\");\n        File file = new File(tempFilePath);\n        Files.createDirectories(Paths.get(file.getParent()));\n        Files.createFile(Paths.get(file.getAbsolutePath()));\n\n        CsvFile csvFile = new CsvFile(tempFilePath);\n        csvFile.setFirstRecordHeader(true);\n        csvFile.setQuoteMode(QuoteMode.NON_NUMERIC);\n        return csvFile;\n    }\n\n    private static String modifyFromClauseForRedshiftAndPostgres(String postgresExtractQuery, String schema) {\n        return postgresExtractQuery.replace(\"from \", \"from \" + schema + \".\");\n    }\n\n    private static CsvFile executeQueryForPostgresOrRedshift(ExternalTaskRequestContext externalTaskRequestContext, Map<String, Object> workflowSystemProperties, SQLQueryInfo sqlQueryInfo, RelationalDBConnectionDetail dbConnectionDetail) {\n        try {\n            QueryBuilderResponse postgresExtract = new FreeFormQueryBuilder().with(sqlQueryInfo)\n                    .withQueryBuilderHelper(new SqlQueryBuilderHelper(sqlQueryInfo.getConnectionInfo().getConnectorType()))\n                    .withQuerySourceType(QuerySourceType.SQL)\n                    .withSystemProperties(workflowSystemProperties)\n                    .build();\n            String postgresExtractQuery = postgresExtract.getQuery();\n            LOGGER.info(\"Redshift/Postgres Extract Query: {}\", postgresExtractQuery);\n            String connectionUrl = \"jdbc:postgresql://\" + CryptUtil.decrypt(dbConnectionDetail.getHost()) + \":\" + CryptUtil.decrypt(dbConnectionDetail.getPort()) + \"/\" + CryptUtil.decrypt(dbConnectionDetail.getDataBaseName());\n            ConnectionParamPojo connectionParamPojo = new ConnectionParamPojo(connectionUrl, CryptUtil.decrypt(dbConnectionDetail.getUser()), CryptUtil.decrypt(dbConnectionDetail.getPwd()), getDeploymentProperties().getIntegerValue(SQL_EXTRACTION_DB_CONNECTION_POOL_SIZE, 1), connectionPoolName, dbConnectionDetail.isSslEnabled());\n            String tableSchema = \"public\";\n            if (MapUtils.isNotEmpty(dbConnectionDetail.getProperties()) && StringUtils.isNotBlank(DPUtils.valueOf(dbConnectionDetail.getProperties().get(\"tablesSchema\")))) {\n                tableSchema = CryptUtil.decrypt(DPUtils.valueOf(dbConnectionDetail.getProperties().get(\"tablesSchema\")));\n                LOGGER.info(msg(\"Using tablesSchema: {} from properties for connectionId {}.\", tableSchema, sqlQueryInfo.getConnectionInfo().getConnectionId()));\n            } else {\n                LOGGER.warn(msg(\"Did not find tablesSchema in properties, proceeding with public schema for connectionid {}.\", sqlQueryInfo.getConnectionInfo().getConnectionId()));\n            }\n            postgresExtractQuery = modifyFromClauseForRedshiftAndPostgres(postgresExtractQuery, tableSchema);\n            LOGGER.info(\"Postgres Extract Query after modification: {}\", postgresExtractQuery);\n            SQLExtractHelper sqlExtractHelper = new SQLExtractHelper(connectionParamPojo, postgresExtractQuery, sqlQueryInfo);\n            CsvFile csvFile = getCsvFileForSQLExtract(externalTaskRequestContext.getTenantId(), externalTaskRequestContext.getJobId(), externalTaskRequestContext.getTaskId());\n            sqlExtractHelper.executeQuery(csvFile);\n            LOGGER.info(\"Postgres SQL Query Executed Successfully\");\n            return csvFile;\n        } catch (Exception ex) {\n            LOGGER.error(\"SQL query execution failed: {}. {}.\", ex.getMessage(), ex);\n            throw new DPSystemException(\"SQL query execution failed.\", ex);\n        }\n    }\n\n    private static void saveExtractionTaskResult(String tenantId, String jobId, String taskId, ExternalExtractionTaskResult taskResult) {\n        ExternalTaskUtil.saveExternalTaskResult(tenantId, jobId, taskId, taskResult);\n    }\n\n    private static void logDateOrDateTimeData(String tenantId, String jobId, List<FieldInfo> headers, CsvFile csvFile) {\n        InputStream csvInputStream = null;\n        int sampleRecordSize = DeploymentProperties.getDeploymentProperties().getIntegerValue(POSTGRES_EXTRACT_SAMPLE_LOG_RECORD_SIZE, 10);\n        boolean includeAllDateDateTimeColumns = DeploymentProperties.getDeploymentProperties().getBooleanValue(POSTGRES_EXTRACT_SAMPLE_LOG_INCLUDE_ALL_COLUMNS, false);\n        List<FieldInfo> sampleDataFieldList = Lists.newArrayList();\n        Map<String, List<String>> dateOrDateTimeColumnValueMap = Maps.newHashMap();\n        try {\n            if (!includeAllDateDateTimeColumns) {\n                FieldInfo dateField = headers.stream().filter(header -> header.getDataType().equals(DATE)).findFirst().orElse(null);\n                if (Objects.nonNull(dateField)) {\n                    sampleDataFieldList.add(dateField);\n                }\n                FieldInfo dateTimeField = headers.stream().filter(header -> header.getDataType().equals(DATETIME)).findFirst().orElse(null);\n                if (Objects.nonNull(dateTimeField)) {\n                    sampleDataFieldList.add(dateTimeField);\n                }\n            } else {\n                sampleDataFieldList = headers;\n            }\n            if (CollectionUtils.isEmpty(sampleDataFieldList)) {\n                LOGGER.info(\"Did not find any date/dateTime column for job:{} of tenant:{}. Hence skipping logging of sample values\", jobId, tenantId);\n            } else {\n                LOGGER.info(\"Field list for which sample is required: {} for job:{} and tenant:{}\", sampleDataFieldList.stream().map(FieldInfo::getFieldAlias).collect(Collectors.toList()), jobId, tenantId);\n                CSVFormat csvFormatter = DPUtils.getCSVFormatter(DOUBLE_QUOTE_CHAR, DOUBLE_QUOTE_CHAR, true);\n                csvInputStream = Files.newInputStream(csvFile.getAbsoluteFile().toPath());\n                try (CSVParser csvParser = new CSVParser(new BufferedReader(new InputStreamReader(csvInputStream)), csvFormatter)) {\n                    for (CSVRecord record : csvParser) {\n                        Map<String, String> recordMap = DPCollectionUtils.nullSafeMap(record.toMap());\n                        for (FieldInfo fieldInfo : sampleDataFieldList) {\n                            String fieldAlias = fieldInfo.getFieldAlias();\n                            String recordVal = recordMap.get(fieldInfo.getFieldAlias());\n                            if (StringUtils.isNotBlank(recordVal)) {\n                                if (dateOrDateTimeColumnValueMap.containsKey(fieldAlias)) {\n                                    List<String> dateValues = dateOrDateTimeColumnValueMap.get(fieldAlias);\n                                    if (dateValues.size() < sampleRecordSize) {\n                                        dateValues.add(recordVal);\n                                        dateOrDateTimeColumnValueMap.put(fieldAlias, dateValues);\n                                    }\n                                } else {\n                                    dateOrDateTimeColumnValueMap.put(fieldAlias, Lists.newArrayList(recordVal));\n                                }\n                            }\n                        }\n                        int size = sampleRecordSize;\n                        Iterator<Map.Entry<String, List<String>>> iterator = dateOrDateTimeColumnValueMap.entrySet().stream().iterator();\n                        while (iterator.hasNext()) {\n                            List<String> value = iterator.next().getValue();\n                            if (value.size() < size) {\n                                size = value.size();\n                            }\n                        }\n                        if (size == sampleRecordSize) {\n                            break;\n                        }\n                    }\n                }\n                LOGGER.info(\"Sample data set for required columns for job:{} of tenant:{} are ::: {}\", jobId, tenantId, DPUtils.convertObjectToJson(dateOrDateTimeColumnValueMap));\n            }\n        } catch (Exception ex) {\n            LOGGER.warn(\"Unable to log date/dateTime sample records for job:{} of tenant:{} due to:\", jobId, tenantId, ex);\n        } finally {\n            IOUtils.closeQuietly(csvInputStream);\n        }\n    }\n\n}"}
2025-05-13 21:02:56 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:02:56 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:02:56 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:02:56 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    public static void main(String[] args) {\n        executeTask(ExternalTaskUtil.getExternalTaskRequestContext());\n    }\n"}
2025-05-13 21:02:58 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:02:58 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:02:58 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:02:58 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    private static void executeTask(ExternalTaskRequestContext externalTaskRequestContext) {\n        try {\n            String jobId = externalTaskRequestContext.getJobId();\n            String tenantId = externalTaskRequestContext.getTenantId();\n            Map<String, String> metaData = externalTaskRequestContext.getMetaData();\n            SQLQueryInfo sqlQueryInfo = convertJsonToObject(metaData.get(SQL_EXTRACTION_DETAILS_KEY), SQLQueryInfo.class);\n            isNotNull(sqlQueryInfo, GENERIC_SYSTEM_ERROR, msg(\"Could not get valid sqlExtractionDetails from task metadata for jobId:{} and tenantId:{}\", jobId, tenantId));\n            LOGGER.info(\"SQL Query info for job:{} of tenant:{} is::{}\", jobId, tenantId, DPUtils.convertObjectToJson(sqlQueryInfo));\n\n            DPWorkflowJobDetailsDTO dpWorkflowJobDetailsDTO = externalTaskRequestContext.getWorkflowJobDetails();\n            AuditMetadata auditMetadata = AuditMetadata.newInstance(tenantId, jobId, dpWorkflowJobDetailsDTO.getExternalId(), externalTaskRequestContext.getTaskId(), externalTaskRequestContext.getTaskName());\n            String configSourceUrl = TaskExecutorWorkflowUtils.getConfigSourceUrl(dpWorkflowJobDetailsDTO);\n            String gsB2BSecret = getDeploymentProperties().getValue(MDA_GAINSIGHT_B2B_SECRET);\n\n            ConnectorType connectorType;\n            RelationalDBConnectionDetail relationalDBConnectionDetail;\n            if (null != sqlQueryInfo.getConnectionInfo()) {\n                isNotBlank(sqlQueryInfo.getConnectionInfo().getConnectionId(), GENERIC_SYSTEM_ERROR, msg(\"No connectionId provided against jobId:{} and tenant:{}\", jobId, tenantId));\n                MDACalloutsService mdaCalloutsService = new MDACalloutsServiceImpl(gsB2BSecret, configSourceUrl);\n                PNPConnectionInput pnpConnectionInfo = mdaCalloutsService.getConnectionDetails(sqlQueryInfo.getConnectionInfo().getConnectionId(), tenantId);\n                LOGGER.info(\"PNPConnectionInput fetched successfully for connectionId: {} tenantId: {}\", sqlQueryInfo.getConnectionInfo().getConnectionId(), tenantId);\n                sqlQueryInfo.getConnectionInfo().setConnectorType(ConnectorType.HAPOSTGRES);\n\n                if (pnpConnectionInfo.getPnpConnectionsInfo().getConnectionDetail() instanceof RelationalDBConnectionDetail) {\n                    relationalDBConnectionDetail = (RelationalDBConnectionDetail) pnpConnectionInfo.getPnpConnectionsInfo().getConnectionDetail();\n                    connectorType = ConnectorType.valueOf(relationalDBConnectionDetail.getType());\n                } else {\n                    throw new DPSystemException(msg(\"Provided connectionDetail: {} is not registered with us. Please contact tech support!!\", DPUtils.convertObjectToJson(pnpConnectionInfo.getPnpConnectionsInfo().getConnectionDetail())));\n                }\n            } else if (sqlQueryInfo.getConnectionDetail() instanceof RelationalDBConnectionDetail) {\n                LOGGER.info(\"ConnectionInfo is null. Fetching connection details from sqlExtractionDetails connectionDetails for jobId:{}\", jobId);\n                relationalDBConnectionDetail = (RelationalDBConnectionDetail) sqlQueryInfo.getConnectionDetail();\n                connectorType = ConnectorType.valueOf(relationalDBConnectionDetail.getType());\n            } else {\n                throw new DPSystemException(\"Please provide either valid connectionInfo or connectionDetail\");\n            }\n            CsvFile csvFile;\n            List<String> copyManagerExcludedTenants = Lists.newArrayList();\n            String excludedTenants = DeploymentProperties.getDeploymentProperties().getValue(POSTGRES_COPY_MANAGER_EXCLUDED_TENANTS);\n            if (StringUtils.isNotBlank(excludedTenants)) {\n                copyManagerExcludedTenants.addAll(Arrays.asList(excludedTenants.split(COMMA)));\n            }\n            boolean disableCopyManager = DeploymentProperties.getDeploymentProperties().getBooleanValue(DISABLE_POSTGRES_COPY_MANAGER, false);\n            if (disableCopyManager || copyManagerExcludedTenants.contains(tenantId)) {\n                LOGGER.warn(\"Skipping postgres copyManager execution for job:{} of tenant:{} since either it is restricted for this tenant or copy manager is disabled. Will proceed with legacy code though!!\", jobId, tenantId);\n                csvFile = executeQueryForPostgresOrRedshift(externalTaskRequestContext, externalTaskRequestContext.getWorkflowSystemProperties(), sqlQueryInfo, relationalDBConnectionDetail);\n            } else {\n                try {\n                    csvFile = executeQueryForPostgresCopyManager(externalTaskRequestContext, externalTaskRequestContext.getWorkflowSystemProperties(), sqlQueryInfo, relationalDBConnectionDetail);\n                } catch (Exception ex) {\n                    LOGGER.warn(msg(\"SQL Extraction for {} failed with copy manager functionality due to: {} \", connectorType, ex.getMessage()));\n                    LOGGER.warn(\"More details about the exception are: \", ex);\n                    if (!Thread.currentThread().isInterrupted()) {\n                        LOGGER.warn(\"Falling back to legacy code since copy manager did not give us what we wanted!!\");\n                        csvFile = executeQueryForPostgresOrRedshift(externalTaskRequestContext, externalTaskRequestContext.getWorkflowSystemProperties(), sqlQueryInfo, relationalDBConnectionDetail);\n                    } else {\n                        LOGGER.info(\"Query execution failed without falling back to legacy code.\");\n                        throw ex;\n                    }\n                }\n            }\n            List<FieldInfo> headers = DPUtils.convertJsonToObject(DPUtils.convertObjectToJson(sqlQueryInfo.getShowFields()), new TypeReference<List<FieldInfo>>() {\n            });\n            TaskResult taskResult = new TaskResult(headers, null);\n            char delimiter = csvFile.getDelimiter() != null ? csvFile.getDelimiter().charAt(0) : COMMA.charAt(0);\n\n            Map<String, CustomerCurrencyDTO> currencyConversionMap = null;\n            if (DPUtils.isCurrencyConversionMapRequired(headers)) {\n                currencyConversionMap = CustomerCurrencyUtil.getCustomerCurrencyConversionMap(configSourceUrl, auditMetadata, true);\n            }\n\n            /*\n                Printing specified number of records for columns having dataType as date/dateTime only to find out format and other\n                discrepancies(if any). Since date/dateTime data is always a glitch in the matrix.\n                Based on config server property.\n             */\n            if (DeploymentProperties.getDeploymentProperties().getBooleanValue(ENABLE_POSTGRES_EXTRACT_SAMPLE_LOGGING, false)) {\n                logDateOrDateTimeData(tenantId, jobId, headers, csvFile);\n            }\n\n            ExternalExtractionTaskResult externalExtractionTaskResult = new ExternalExtractionTaskResult.ExternalExtractionTaskResultBuilder()\n                    .setWithHeader(true)\n                    .setDelimiter(delimiter)\n                    .setTaskResult(taskResult)\n                    .setCurrencyConversionMap(currencyConversionMap)\n                    .setExtractedFiles(Collections.singletonList(csvFile.getAbsolutePath()))\n                    .build();\n\n            //Saving externalTask Result.\n            saveExtractionTaskResult(tenantId, jobId, externalTaskRequestContext.getTaskId(), externalExtractionTaskResult);\n            LOGGER.info(\"Successfully saved externalTask result for jobId:{}, tenantId:{}\", jobId, tenantId);\n        } catch (DPSystemException dpSysEx) {\n            LOGGER.error(\"Error while performing jdbc extraction - taskId: {}, jobId: {}, tenantId: {}\", externalTaskRequestContext.getTaskId(), externalTaskRequestContext.getJobId(), externalTaskRequestContext.getTenantId(), dpSysEx);\n            throw dpSysEx;\n        } catch (Exception ex) {\n            LOGGER.error(\"Error while performing jdbc extraction - taskId: {}, jobId: {}, tenantId: {}\", externalTaskRequestContext.getTaskId(), externalTaskRequestContext.getJobId(), externalTaskRequestContext.getTenantId(), ex);\n            throw new DPSystemException(msg(\"Error while performing jdbc extraction: {}\", ex.getMessage()), ex);\n        }\n    }\n"}
2025-05-13 21:02:59 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:02:59 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:02:59 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:02:59 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    private static CsvFile executeQueryForPostgresCopyManager(ExternalTaskRequestContext externalTaskRequestContext, Map<String, Object> workflowSystemProperties, SQLQueryInfo sqlQueryInfo, RelationalDBConnectionDetail dbConnectionDetail) throws SQLException, IOException {\n        try {\n            QueryBuilderResponse postgresExtract = new FreeFormQueryBuilder().with(sqlQueryInfo)\n                    .withQueryBuilderHelper(new SqlQueryBuilderHelper(ConnectorType.POSTGRES))\n                    .withQuerySourceType(QuerySourceType.SQL)\n                    .withSystemProperties(workflowSystemProperties)\n                    .build();\n            String postgresExtractQuery = postgresExtract.getQuery();\n            String connectionUrl = \"jdbc:postgresql://\" + CryptUtil.decrypt(dbConnectionDetail.getHost()) + \":\" + CryptUtil.decrypt(dbConnectionDetail.getPort()) + \"/\" + CryptUtil.decrypt(dbConnectionDetail.getDataBaseName()) + \"?ssl=\" + dbConnectionDetail.isSslEnabled();\n            ConnectionParamPojo connectionParamPojo = new ConnectionParamPojo(connectionUrl, CryptUtil.decrypt(dbConnectionDetail.getUser()), CryptUtil.decrypt(dbConnectionDetail.getPwd()), getDeploymentProperties().getIntegerValue(SQL_EXTRACTION_DB_CONNECTION_POOL_SIZE, 1), connectionPoolName, dbConnectionDetail.isSslEnabled());\n            String tableSchema = \"public\";\n            if (MapUtils.isNotEmpty(dbConnectionDetail.getProperties()) && StringUtils.isNotBlank(DPUtils.valueOf(dbConnectionDetail.getProperties().get(\"tablesSchema\")))) {\n                tableSchema = CryptUtil.decrypt(DPUtils.valueOf(dbConnectionDetail.getProperties().get(\"tablesSchema\")));\n                LOGGER.info(msg(\"Using tablesSchema: {} from properties for connectionId {}.\", tableSchema, sqlQueryInfo.getConnectionInfo().getConnectionId()));\n            } else {\n                LOGGER.warn(msg(\"Did not find tablesSchema in properties, proceeding with public schema for connectionId {}.\", sqlQueryInfo.getConnectionInfo().getConnectionId()));\n            }\n            postgresExtractQuery = modifyFromClauseForRedshiftAndPostgres(postgresExtractQuery, tableSchema);\n            LOGGER.info(\"Postgres Extract Query: {}\", postgresExtractQuery);\n            SQLExtractHelper sqlExtractHelper = new SQLExtractHelper(connectionParamPojo, postgresExtractQuery, sqlQueryInfo);\n            CsvFile csvFile = getCsvFileForSQLExtract(externalTaskRequestContext.getTenantId(), externalTaskRequestContext.getJobId(), externalTaskRequestContext.getTaskId());\n            sqlExtractHelper.executeQueryWithPostgresCopyManager(csvFile);\n            LOGGER.info(\"Postgres SQL Query Executed Successfully with copy manager!!\");\n            return csvFile;\n        } catch (Exception ex) {\n            LOGGER.error(\"SQL query execution failed: {}. {}.\", ex.getMessage(), ex);\n            throw new DPSystemException(\"SQL query execution failed.\", ex);\n        }\n    }\n"}
2025-05-13 21:03:01 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:03:01 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:03:01 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:03:01 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    private static CsvFile getCsvFileForSQLExtract(String tenantId, String jobId, String taskId) throws IOException {\n        String tempFilePath = DPUtils.getTempFilePath(tenantId, jobId, taskId, UUID.randomUUID().toString() + \".csv\");\n        File file = new File(tempFilePath);\n        Files.createDirectories(Paths.get(file.getParent()));\n        Files.createFile(Paths.get(file.getAbsolutePath()));\n\n        CsvFile csvFile = new CsvFile(tempFilePath);\n        csvFile.setFirstRecordHeader(true);\n        csvFile.setQuoteMode(QuoteMode.NON_NUMERIC);\n        return csvFile;\n    }\n"}
2025-05-13 21:03:02 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:03:02 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:03:02 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:03:02 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    private static String modifyFromClauseForRedshiftAndPostgres(String postgresExtractQuery, String schema) {\n        return postgresExtractQuery.replace(\"from \", \"from \" + schema + \".\");\n    }\n"}
2025-05-13 21:03:03 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:03:03 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:03:03 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:03:03 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    private static CsvFile executeQueryForPostgresOrRedshift(ExternalTaskRequestContext externalTaskRequestContext, Map<String, Object> workflowSystemProperties, SQLQueryInfo sqlQueryInfo, RelationalDBConnectionDetail dbConnectionDetail) {\n        try {\n            QueryBuilderResponse postgresExtract = new FreeFormQueryBuilder().with(sqlQueryInfo)\n                    .withQueryBuilderHelper(new SqlQueryBuilderHelper(sqlQueryInfo.getConnectionInfo().getConnectorType()))\n                    .withQuerySourceType(QuerySourceType.SQL)\n                    .withSystemProperties(workflowSystemProperties)\n                    .build();\n            String postgresExtractQuery = postgresExtract.getQuery();\n            LOGGER.info(\"Redshift/Postgres Extract Query: {}\", postgresExtractQuery);\n            String connectionUrl = \"jdbc:postgresql://\" + CryptUtil.decrypt(dbConnectionDetail.getHost()) + \":\" + CryptUtil.decrypt(dbConnectionDetail.getPort()) + \"/\" + CryptUtil.decrypt(dbConnectionDetail.getDataBaseName());\n            ConnectionParamPojo connectionParamPojo = new ConnectionParamPojo(connectionUrl, CryptUtil.decrypt(dbConnectionDetail.getUser()), CryptUtil.decrypt(dbConnectionDetail.getPwd()), getDeploymentProperties().getIntegerValue(SQL_EXTRACTION_DB_CONNECTION_POOL_SIZE, 1), connectionPoolName, dbConnectionDetail.isSslEnabled());\n            String tableSchema = \"public\";\n            if (MapUtils.isNotEmpty(dbConnectionDetail.getProperties()) && StringUtils.isNotBlank(DPUtils.valueOf(dbConnectionDetail.getProperties().get(\"tablesSchema\")))) {\n                tableSchema = CryptUtil.decrypt(DPUtils.valueOf(dbConnectionDetail.getProperties().get(\"tablesSchema\")));\n                LOGGER.info(msg(\"Using tablesSchema: {} from properties for connectionId {}.\", tableSchema, sqlQueryInfo.getConnectionInfo().getConnectionId()));\n            } else {\n                LOGGER.warn(msg(\"Did not find tablesSchema in properties, proceeding with public schema for connectionid {}.\", sqlQueryInfo.getConnectionInfo().getConnectionId()));\n            }\n            postgresExtractQuery = modifyFromClauseForRedshiftAndPostgres(postgresExtractQuery, tableSchema);\n            LOGGER.info(\"Postgres Extract Query after modification: {}\", postgresExtractQuery);\n            SQLExtractHelper sqlExtractHelper = new SQLExtractHelper(connectionParamPojo, postgresExtractQuery, sqlQueryInfo);\n            CsvFile csvFile = getCsvFileForSQLExtract(externalTaskRequestContext.getTenantId(), externalTaskRequestContext.getJobId(), externalTaskRequestContext.getTaskId());\n            sqlExtractHelper.executeQuery(csvFile);\n            LOGGER.info(\"Postgres SQL Query Executed Successfully\");\n            return csvFile;\n        } catch (Exception ex) {\n            LOGGER.error(\"SQL query execution failed: {}. {}.\", ex.getMessage(), ex);\n            throw new DPSystemException(\"SQL query execution failed.\", ex);\n        }\n    }\n"}
2025-05-13 21:03:05 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:03:05 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:03:05 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:03:05 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    private static void saveExtractionTaskResult(String tenantId, String jobId, String taskId, ExternalExtractionTaskResult taskResult) {\n        ExternalTaskUtil.saveExternalTaskResult(tenantId, jobId, taskId, taskResult);\n    }\n"}
2025-05-13 21:03:06 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:03:06 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:03:06 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:03:06 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    private static void logDateOrDateTimeData(String tenantId, String jobId, List<FieldInfo> headers, CsvFile csvFile) {\n        InputStream csvInputStream = null;\n        int sampleRecordSize = DeploymentProperties.getDeploymentProperties().getIntegerValue(POSTGRES_EXTRACT_SAMPLE_LOG_RECORD_SIZE, 10);\n        boolean includeAllDateDateTimeColumns = DeploymentProperties.getDeploymentProperties().getBooleanValue(POSTGRES_EXTRACT_SAMPLE_LOG_INCLUDE_ALL_COLUMNS, false);\n        List<FieldInfo> sampleDataFieldList = Lists.newArrayList();\n        Map<String, List<String>> dateOrDateTimeColumnValueMap = Maps.newHashMap();\n        try {\n            if (!includeAllDateDateTimeColumns) {\n                FieldInfo dateField = headers.stream().filter(header -> header.getDataType().equals(DATE)).findFirst().orElse(null);\n                if (Objects.nonNull(dateField)) {\n                    sampleDataFieldList.add(dateField);\n                }\n                FieldInfo dateTimeField = headers.stream().filter(header -> header.getDataType().equals(DATETIME)).findFirst().orElse(null);\n                if (Objects.nonNull(dateTimeField)) {\n                    sampleDataFieldList.add(dateTimeField);\n                }\n            } else {\n                sampleDataFieldList = headers;\n            }\n            if (CollectionUtils.isEmpty(sampleDataFieldList)) {\n                LOGGER.info(\"Did not find any date/dateTime column for job:{} of tenant:{}. Hence skipping logging of sample values\", jobId, tenantId);\n            } else {\n                LOGGER.info(\"Field list for which sample is required: {} for job:{} and tenant:{}\", sampleDataFieldList.stream().map(FieldInfo::getFieldAlias).collect(Collectors.toList()), jobId, tenantId);\n                CSVFormat csvFormatter = DPUtils.getCSVFormatter(DOUBLE_QUOTE_CHAR, DOUBLE_QUOTE_CHAR, true);\n                csvInputStream = Files.newInputStream(csvFile.getAbsoluteFile().toPath());\n                try (CSVParser csvParser = new CSVParser(new BufferedReader(new InputStreamReader(csvInputStream)), csvFormatter)) {\n                    for (CSVRecord record : csvParser) {\n                        Map<String, String> recordMap = DPCollectionUtils.nullSafeMap(record.toMap());\n                        for (FieldInfo fieldInfo : sampleDataFieldList) {\n                            String fieldAlias = fieldInfo.getFieldAlias();\n                            String recordVal = recordMap.get(fieldInfo.getFieldAlias());\n                            if (StringUtils.isNotBlank(recordVal)) {\n                                if (dateOrDateTimeColumnValueMap.containsKey(fieldAlias)) {\n                                    List<String> dateValues = dateOrDateTimeColumnValueMap.get(fieldAlias);\n                                    if (dateValues.size() < sampleRecordSize) {\n                                        dateValues.add(recordVal);\n                                        dateOrDateTimeColumnValueMap.put(fieldAlias, dateValues);\n                                    }\n                                } else {\n                                    dateOrDateTimeColumnValueMap.put(fieldAlias, Lists.newArrayList(recordVal));\n                                }\n                            }\n                        }\n                        int size = sampleRecordSize;\n                        Iterator<Map.Entry<String, List<String>>> iterator = dateOrDateTimeColumnValueMap.entrySet().stream().iterator();\n                        while (iterator.hasNext()) {\n                            List<String> value = iterator.next().getValue();\n                            if (value.size() < size) {\n                                size = value.size();\n                            }\n                        }\n                        if (size == sampleRecordSize) {\n                            break;\n                        }\n                    }\n                }\n                LOGGER.info(\"Sample data set for required columns for job:{} of tenant:{} are ::: {}\", jobId, tenantId, DPUtils.convertObjectToJson(dateOrDateTimeColumnValueMap));\n            }\n        } catch (Exception ex) {\n            LOGGER.warn(\"Unable to log date/dateTime sample records for job:{} of tenant:{} due to:\", jobId, tenantId, ex);\n        } finally {\n            IOUtils.closeQuietly(csvInputStream);\n        }\n    }\n"}
2025-05-13 21:03:07 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:03:07 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:03:07 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:03:07 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"public class PostgresExtractionTask {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(PostgresExtractionTask.class);\n    private static final String connectionPoolName = \"DynamicSQLExtractPool_\" + RandomStringUtils.randomAlphanumeric(8);\n    private static final String EPOCH_DATETIME_FORMAT = \"epoch\";\n    private static final String POSTGRES_COPY_MANAGER_EXCLUDED_TENANTS = \"postgres.copy.manager.excluded.tenants\";\n    private static final String DISABLE_POSTGRES_COPY_MANAGER = \"disable.postgres.copy.manager\";\n    private static final String ENABLE_POSTGRES_EXTRACT_SAMPLE_LOGGING = \"enable.postgres.extract.sample.logging\";\n    private static final String POSTGRES_EXTRACT_SAMPLE_LOG_RECORD_SIZE = \"postgres.extract.sample.log.record.size\";\n    private static final String POSTGRES_EXTRACT_SAMPLE_LOG_INCLUDE_ALL_COLUMNS = \"postgres.extract.sample.log.include.all.columns\";\n    private static final String POSTGRES_EXTRACT_DEFAULT_DATETIME_FORMAT = \"postgres.extract.default.datetime.format\";\n\n    public static void main(String[] args) {\n        executeTask(ExternalTaskUtil.getExternalTaskRequestContext());\n    }\n\n    private static void executeTask(ExternalTaskRequestContext externalTaskRequestContext) {\n        try {\n            String jobId = externalTaskRequestContext.getJobId();\n            String tenantId = externalTaskRequestContext.getTenantId();\n            Map<String, String> metaData = externalTaskRequestContext.getMetaData();\n            SQLQueryInfo sqlQueryInfo = convertJsonToObject(metaData.get(SQL_EXTRACTION_DETAILS_KEY), SQLQueryInfo.class);\n            isNotNull(sqlQueryInfo, GENERIC_SYSTEM_ERROR, msg(\"Could not get valid sqlExtractionDetails from task metadata for jobId:{} and tenantId:{}\", jobId, tenantId));\n            LOGGER.info(\"SQL Query info for job:{} of tenant:{} is::{}\", jobId, tenantId, DPUtils.convertObjectToJson(sqlQueryInfo));\n\n            DPWorkflowJobDetailsDTO dpWorkflowJobDetailsDTO = externalTaskRequestContext.getWorkflowJobDetails();\n            AuditMetadata auditMetadata = AuditMetadata.newInstance(tenantId, jobId, dpWorkflowJobDetailsDTO.getExternalId(), externalTaskRequestContext.getTaskId(), externalTaskRequestContext.getTaskName());\n            String configSourceUrl = TaskExecutorWorkflowUtils.getConfigSourceUrl(dpWorkflowJobDetailsDTO);\n            String gsB2BSecret = getDeploymentProperties().getValue(MDA_GAINSIGHT_B2B_SECRET);\n\n            ConnectorType connectorType;\n            RelationalDBConnectionDetail relationalDBConnectionDetail;\n            if (null != sqlQueryInfo.getConnectionInfo()) {\n                isNotBlank(sqlQueryInfo.getConnectionInfo().getConnectionId(), GENERIC_SYSTEM_ERROR, msg(\"No connectionId provided against jobId:{} and tenant:{}\", jobId, tenantId));\n                MDACalloutsService mdaCalloutsService = new MDACalloutsServiceImpl(gsB2BSecret, configSourceUrl);\n                PNPConnectionInput pnpConnectionInfo = mdaCalloutsService.getConnectionDetails(sqlQueryInfo.getConnectionInfo().getConnectionId(), tenantId);\n                LOGGER.info(\"PNPConnectionInput fetched successfully for connectionId: {} tenantId: {}\", sqlQueryInfo.getConnectionInfo().getConnectionId(), tenantId);\n                sqlQueryInfo.getConnectionInfo().setConnectorType(ConnectorType.HAPOSTGRES);\n\n                if (pnpConnectionInfo.getPnpConnectionsInfo().getConnectionDetail() instanceof RelationalDBConnectionDetail) {\n                    relationalDBConnectionDetail = (RelationalDBConnectionDetail) pnpConnectionInfo.getPnpConnectionsInfo().getConnectionDetail();\n                    connectorType = ConnectorType.valueOf(relationalDBConnectionDetail.getType());\n                } else {\n                    throw new DPSystemException(msg(\"Provided connectionDetail: {} is not registered with us. Please contact tech support!!\", DPUtils.convertObjectToJson(pnpConnectionInfo.getPnpConnectionsInfo().getConnectionDetail())));\n                }\n            } else if (sqlQueryInfo.getConnectionDetail() instanceof RelationalDBConnectionDetail) {\n                LOGGER.info(\"ConnectionInfo is null. Fetching connection details from sqlExtractionDetails connectionDetails for jobId:{}\", jobId);\n                relationalDBConnectionDetail = (RelationalDBConnectionDetail) sqlQueryInfo.getConnectionDetail();\n                connectorType = ConnectorType.valueOf(relationalDBConnectionDetail.getType());\n            } else {\n                throw new DPSystemException(\"Please provide either valid connectionInfo or connectionDetail\");\n            }\n            CsvFile csvFile;\n            List<String> copyManagerExcludedTenants = Lists.newArrayList();\n            String excludedTenants = DeploymentProperties.getDeploymentProperties().getValue(POSTGRES_COPY_MANAGER_EXCLUDED_TENANTS);\n            if (StringUtils.isNotBlank(excludedTenants)) {\n                copyManagerExcludedTenants.addAll(Arrays.asList(excludedTenants.split(COMMA)));\n            }\n            boolean disableCopyManager = DeploymentProperties.getDeploymentProperties().getBooleanValue(DISABLE_POSTGRES_COPY_MANAGER, false);\n            if (disableCopyManager || copyManagerExcludedTenants.contains(tenantId)) {\n                LOGGER.warn(\"Skipping postgres copyManager execution for job:{} of tenant:{} since either it is restricted for this tenant or copy manager is disabled. Will proceed with legacy code though!!\", jobId, tenantId);\n                csvFile = executeQueryForPostgresOrRedshift(externalTaskRequestContext, externalTaskRequestContext.getWorkflowSystemProperties(), sqlQueryInfo, relationalDBConnectionDetail);\n            } else {\n                try {\n                    csvFile = executeQueryForPostgresCopyManager(externalTaskRequestContext, externalTaskRequestContext.getWorkflowSystemProperties(), sqlQueryInfo, relationalDBConnectionDetail);\n                } catch (Exception ex) {\n                    LOGGER.warn(msg(\"SQL Extraction for {} failed with copy manager functionality due to: {} \", connectorType, ex.getMessage()));\n                    LOGGER.warn(\"More details about the exception are: \", ex);\n                    if (!Thread.currentThread().isInterrupted()) {\n                        LOGGER.warn(\"Falling back to legacy code since copy manager did not give us what we wanted!!\");\n                        csvFile = executeQueryForPostgresOrRedshift(externalTaskRequestContext, externalTaskRequestContext.getWorkflowSystemProperties(), sqlQueryInfo, relationalDBConnectionDetail);\n                    } else {\n                        LOGGER.info(\"Query execution failed without falling back to legacy code.\");\n                        throw ex;\n                    }\n                }\n            }\n            List<FieldInfo> headers = DPUtils.convertJsonToObject(DPUtils.convertObjectToJson(sqlQueryInfo.getShowFields()), new TypeReference<List<FieldInfo>>() {\n            });\n            TaskResult taskResult = new TaskResult(headers, null);\n            char delimiter = csvFile.getDelimiter() != null ? csvFile.getDelimiter().charAt(0) : COMMA.charAt(0);\n\n            Map<String, CustomerCurrencyDTO> currencyConversionMap = null;\n            if (DPUtils.isCurrencyConversionMapRequired(headers)) {\n                currencyConversionMap = CustomerCurrencyUtil.getCustomerCurrencyConversionMap(configSourceUrl, auditMetadata, true);\n            }\n\n            /*\n                Printing specified number of records for columns having dataType as date/dateTime only to find out format and other\n                discrepancies(if any). Since date/dateTime data is always a glitch in the matrix.\n                Based on config server property.\n             */\n            if (DeploymentProperties.getDeploymentProperties().getBooleanValue(ENABLE_POSTGRES_EXTRACT_SAMPLE_LOGGING, false)) {\n                logDateOrDateTimeData(tenantId, jobId, headers, csvFile);\n            }\n\n            ExternalExtractionTaskResult externalExtractionTaskResult = new ExternalExtractionTaskResult.ExternalExtractionTaskResultBuilder()\n                    .setWithHeader(true)\n                    .setDelimiter(delimiter)\n                    .setTaskResult(taskResult)\n                    .setCurrencyConversionMap(currencyConversionMap)\n                    .setExtractedFiles(Collections.singletonList(csvFile.getAbsolutePath()))\n                    .build();\n\n            //Saving externalTask Result.\n            saveExtractionTaskResult(tenantId, jobId, externalTaskRequestContext.getTaskId(), externalExtractionTaskResult);\n            LOGGER.info(\"Successfully saved externalTask result for jobId:{}, tenantId:{}\", jobId, tenantId);\n        } catch (DPSystemException dpSysEx) {\n            LOGGER.error(\"Error while performing jdbc extraction - taskId: {}, jobId: {}, tenantId: {}\", externalTaskRequestContext.getTaskId(), externalTaskRequestContext.getJobId(), externalTaskRequestContext.getTenantId(), dpSysEx);\n            throw dpSysEx;\n        } catch (Exception ex) {\n            LOGGER.error(\"Error while performing jdbc extraction - taskId: {}, jobId: {}, tenantId: {}\", externalTaskRequestContext.getTaskId(), externalTaskRequestContext.getJobId(), externalTaskRequestContext.getTenantId(), ex);\n            throw new DPSystemException(msg(\"Error while performing jdbc extraction: {}\", ex.getMessage()), ex);\n        }\n    }\n\n    private static CsvFile executeQueryForPostgresCopyManager(ExternalTaskRequestContext externalTaskRequestContext, Map<String, Object> workflowSystemProperties, SQLQueryInfo sqlQueryInfo, RelationalDBConnectionDetail dbConnectionDetail) throws SQLException, IOException {\n        try {\n            QueryBuilderResponse postgresExtract = new FreeFormQueryBuilder().with(sqlQueryInfo)\n                    .withQueryBuilderHelper(new SqlQueryBuilderHelper(ConnectorType.POSTGRES))\n                    .withQuerySourceType(QuerySourceType.SQL)\n                    .withSystemProperties(workflowSystemProperties)\n                    .build();\n            String postgresExtractQuery = postgresExtract.getQuery();\n            String connectionUrl = \"jdbc:postgresql://\" + CryptUtil.decrypt(dbConnectionDetail.getHost()) + \":\" + CryptUtil.decrypt(dbConnectionDetail.getPort()) + \"/\" + CryptUtil.decrypt(dbConnectionDetail.getDataBaseName()) + \"?ssl=\" + dbConnectionDetail.isSslEnabled();\n            ConnectionParamPojo connectionParamPojo = new ConnectionParamPojo(connectionUrl, CryptUtil.decrypt(dbConnectionDetail.getUser()), CryptUtil.decrypt(dbConnectionDetail.getPwd()), getDeploymentProperties().getIntegerValue(SQL_EXTRACTION_DB_CONNECTION_POOL_SIZE, 1), connectionPoolName, dbConnectionDetail.isSslEnabled());\n            String tableSchema = \"public\";\n            if (MapUtils.isNotEmpty(dbConnectionDetail.getProperties()) && StringUtils.isNotBlank(DPUtils.valueOf(dbConnectionDetail.getProperties().get(\"tablesSchema\")))) {\n                tableSchema = CryptUtil.decrypt(DPUtils.valueOf(dbConnectionDetail.getProperties().get(\"tablesSchema\")));\n                LOGGER.info(msg(\"Using tablesSchema: {} from properties for connectionId {}.\", tableSchema, sqlQueryInfo.getConnectionInfo().getConnectionId()));\n            } else {\n                LOGGER.warn(msg(\"Did not find tablesSchema in properties, proceeding with public schema for connectionId {}.\", sqlQueryInfo.getConnectionInfo().getConnectionId()));\n            }\n            postgresExtractQuery = modifyFromClauseForRedshiftAndPostgres(postgresExtractQuery, tableSchema);\n            LOGGER.info(\"Postgres Extract Query: {}\", postgresExtractQuery);\n            SQLExtractHelper sqlExtractHelper = new SQLExtractHelper(connectionParamPojo, postgresExtractQuery, sqlQueryInfo);\n            CsvFile csvFile = getCsvFileForSQLExtract(externalTaskRequestContext.getTenantId(), externalTaskRequestContext.getJobId(), externalTaskRequestContext.getTaskId());\n            sqlExtractHelper.executeQueryWithPostgresCopyManager(csvFile);\n            LOGGER.info(\"Postgres SQL Query Executed Successfully with copy manager!!\");\n            return csvFile;\n        } catch (Exception ex) {\n            LOGGER.error(\"SQL query execution failed: {}. {}.\", ex.getMessage(), ex);\n            throw new DPSystemException(\"SQL query execution failed.\", ex);\n        }\n    }\n\n    private static CsvFile getCsvFileForSQLExtract(String tenantId, String jobId, String taskId) throws IOException {\n        String tempFilePath = DPUtils.getTempFilePath(tenantId, jobId, taskId, UUID.randomUUID().toString() + \".csv\");\n        File file = new File(tempFilePath);\n        Files.createDirectories(Paths.get(file.getParent()));\n        Files.createFile(Paths.get(file.getAbsolutePath()));\n\n        CsvFile csvFile = new CsvFile(tempFilePath);\n        csvFile.setFirstRecordHeader(true);\n        csvFile.setQuoteMode(QuoteMode.NON_NUMERIC);\n        return csvFile;\n    }\n\n    private static String modifyFromClauseForRedshiftAndPostgres(String postgresExtractQuery, String schema) {\n        return postgresExtractQuery.replace(\"from \", \"from \" + schema + \".\");\n    }\n\n    private static CsvFile executeQueryForPostgresOrRedshift(ExternalTaskRequestContext externalTaskRequestContext, Map<String, Object> workflowSystemProperties, SQLQueryInfo sqlQueryInfo, RelationalDBConnectionDetail dbConnectionDetail) {\n        try {\n            QueryBuilderResponse postgresExtract = new FreeFormQueryBuilder().with(sqlQueryInfo)\n                    .withQueryBuilderHelper(new SqlQueryBuilderHelper(sqlQueryInfo.getConnectionInfo().getConnectorType()))\n                    .withQuerySourceType(QuerySourceType.SQL)\n                    .withSystemProperties(workflowSystemProperties)\n                    .build();\n            String postgresExtractQuery = postgresExtract.getQuery();\n            LOGGER.info(\"Redshift/Postgres Extract Query: {}\", postgresExtractQuery);\n            String connectionUrl = \"jdbc:postgresql://\" + CryptUtil.decrypt(dbConnectionDetail.getHost()) + \":\" + CryptUtil.decrypt(dbConnectionDetail.getPort()) + \"/\" + CryptUtil.decrypt(dbConnectionDetail.getDataBaseName());\n            ConnectionParamPojo connectionParamPojo = new ConnectionParamPojo(connectionUrl, CryptUtil.decrypt(dbConnectionDetail.getUser()), CryptUtil.decrypt(dbConnectionDetail.getPwd()), getDeploymentProperties().getIntegerValue(SQL_EXTRACTION_DB_CONNECTION_POOL_SIZE, 1), connectionPoolName, dbConnectionDetail.isSslEnabled());\n            String tableSchema = \"public\";\n            if (MapUtils.isNotEmpty(dbConnectionDetail.getProperties()) && StringUtils.isNotBlank(DPUtils.valueOf(dbConnectionDetail.getProperties().get(\"tablesSchema\")))) {\n                tableSchema = CryptUtil.decrypt(DPUtils.valueOf(dbConnectionDetail.getProperties().get(\"tablesSchema\")));\n                LOGGER.info(msg(\"Using tablesSchema: {} from properties for connectionId {}.\", tableSchema, sqlQueryInfo.getConnectionInfo().getConnectionId()));\n            } else {\n                LOGGER.warn(msg(\"Did not find tablesSchema in properties, proceeding with public schema for connectionid {}.\", sqlQueryInfo.getConnectionInfo().getConnectionId()));\n            }\n            postgresExtractQuery = modifyFromClauseForRedshiftAndPostgres(postgresExtractQuery, tableSchema);\n            LOGGER.info(\"Postgres Extract Query after modification: {}\", postgresExtractQuery);\n            SQLExtractHelper sqlExtractHelper = new SQLExtractHelper(connectionParamPojo, postgresExtractQuery, sqlQueryInfo);\n            CsvFile csvFile = getCsvFileForSQLExtract(externalTaskRequestContext.getTenantId(), externalTaskRequestContext.getJobId(), externalTaskRequestContext.getTaskId());\n            sqlExtractHelper.executeQuery(csvFile);\n            LOGGER.info(\"Postgres SQL Query Executed Successfully\");\n            return csvFile;\n        } catch (Exception ex) {\n            LOGGER.error(\"SQL query execution failed: {}. {}.\", ex.getMessage(), ex);\n            throw new DPSystemException(\"SQL query execution failed.\", ex);\n        }\n    }\n\n    private static void saveExtractionTaskResult(String tenantId, String jobId, String taskId, ExternalExtractionTaskResult taskResult) {\n        ExternalTaskUtil.saveExternalTaskResult(tenantId, jobId, taskId, taskResult);\n    }\n\n    private static void logDateOrDateTimeData(String tenantId, String jobId, List<FieldInfo> headers, CsvFile csvFile) {\n        InputStream csvInputStream = null;\n        int sampleRecordSize = DeploymentProperties.getDeploymentProperties().getIntegerValue(POSTGRES_EXTRACT_SAMPLE_LOG_RECORD_SIZE, 10);\n        boolean includeAllDateDateTimeColumns = DeploymentProperties.getDeploymentProperties().getBooleanValue(POSTGRES_EXTRACT_SAMPLE_LOG_INCLUDE_ALL_COLUMNS, false);\n        List<FieldInfo> sampleDataFieldList = Lists.newArrayList();\n        Map<String, List<String>> dateOrDateTimeColumnValueMap = Maps.newHashMap();\n        try {\n            if (!includeAllDateDateTimeColumns) {\n                FieldInfo dateField = headers.stream().filter(header -> header.getDataType().equals(DATE)).findFirst().orElse(null);\n                if (Objects.nonNull(dateField)) {\n                    sampleDataFieldList.add(dateField);\n                }\n                FieldInfo dateTimeField = headers.stream().filter(header -> header.getDataType().equals(DATETIME)).findFirst().orElse(null);\n                if (Objects.nonNull(dateTimeField)) {\n                    sampleDataFieldList.add(dateTimeField);\n                }\n            } else {\n                sampleDataFieldList = headers;\n            }\n            if (CollectionUtils.isEmpty(sampleDataFieldList)) {\n                LOGGER.info(\"Did not find any date/dateTime column for job:{} of tenant:{}. Hence skipping logging of sample values\", jobId, tenantId);\n            } else {\n                LOGGER.info(\"Field list for which sample is required: {} for job:{} and tenant:{}\", sampleDataFieldList.stream().map(FieldInfo::getFieldAlias).collect(Collectors.toList()), jobId, tenantId);\n                CSVFormat csvFormatter = DPUtils.getCSVFormatter(DOUBLE_QUOTE_CHAR, DOUBLE_QUOTE_CHAR, true);\n                csvInputStream = Files.newInputStream(csvFile.getAbsoluteFile().toPath());\n                try (CSVParser csvParser = new CSVParser(new BufferedReader(new InputStreamReader(csvInputStream)), csvFormatter)) {\n                    for (CSVRecord record : csvParser) {\n                        Map<String, String> recordMap = DPCollectionUtils.nullSafeMap(record.toMap());\n                        for (FieldInfo fieldInfo : sampleDataFieldList) {\n                            String fieldAlias = fieldInfo.getFieldAlias();\n                            String recordVal = recordMap.get(fieldInfo.getFieldAlias());\n                            if (StringUtils.isNotBlank(recordVal)) {\n                                if (dateOrDateTimeColumnValueMap.containsKey(fieldAlias)) {\n                                    List<String> dateValues = dateOrDateTimeColumnValueMap.get(fieldAlias);\n                                    if (dateValues.size() < sampleRecordSize) {\n                                        dateValues.add(recordVal);\n                                        dateOrDateTimeColumnValueMap.put(fieldAlias, dateValues);\n                                    }\n                                } else {\n                                    dateOrDateTimeColumnValueMap.put(fieldAlias, Lists.newArrayList(recordVal));\n                                }\n                            }\n                        }\n                        int size = sampleRecordSize;\n                        Iterator<Map.Entry<String, List<String>>> iterator = dateOrDateTimeColumnValueMap.entrySet().stream().iterator();\n                        while (iterator.hasNext()) {\n                            List<String> value = iterator.next().getValue();\n                            if (value.size() < size) {\n                                size = value.size();\n                            }\n                        }\n                        if (size == sampleRecordSize) {\n                            break;\n                        }\n                    }\n                }\n                LOGGER.info(\"Sample data set for required columns for job:{} of tenant:{} are ::: {}\", jobId, tenantId, DPUtils.convertObjectToJson(dateOrDateTimeColumnValueMap));\n            }\n        } catch (Exception ex) {\n            LOGGER.warn(\"Unable to log date/dateTime sample records for job:{} of tenant:{} due to:\", jobId, tenantId, ex);\n        } finally {\n            IOUtils.closeQuietly(csvInputStream);\n        }\n    }\n\n}\n"}
2025-05-13 21:03:09 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:03:09 [main] INFO  c.l.service.impl.BasicL3AgentService - Processed file: /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/code/dp_dynamic_tasks/postgres-extraction-task/src/main/java/com/gainsight/services/external/postgres/extraction/task/PostgresExtractionTask.java with 10 chunks
2025-05-13 21:03:09 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:03:09 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:03:09 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"package com.gainsight.services.external.ga4.extraction.task;\n\nimport com.gainsight.services.dataprocessing.commons.exception.DPSystemException;\nimport com.gainsight.services.dataprocessing.commons.pojo.fields.FieldInfo;\nimport com.gainsight.services.dataprocessing.commons.pojo.workflow.DPWorkflowJobDetailsDTO;\nimport com.gainsight.services.dataprocessing.commons.system.ParquetFile;\nimport com.gainsight.services.dataprocessing.dataprocessor.dagdataprocessor.pojo.ExternalExtractionTaskResult;\nimport com.gainsight.services.dataprocessing.dataprocessor.dagdataprocessor.pojo.TaskResult;\nimport com.gainsight.services.dataprocessing.external.task.ExternalTaskRequestContext;\nimport com.gainsight.services.dataprocessing.external.task.ExternalTaskUtil;\nimport com.gainsight.services.external.ga4.extraction.task.utils.GA4ExtractUtil;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\n\n\n/**\n * @author Tarika on 12/12/2021\n */\npublic class GA4ExtractionTask {\n    private static final Logger LOGGER = LoggerFactory.getLogger(GA4ExtractionTask.class);\n\n    public static void main(String[] args) {\n        executeTask(ExternalTaskUtil.getExternalTaskRequestContext());\n    }\n\n    private static void executeTask(ExternalTaskRequestContext externalTaskRequestContext) {\n        String jobId = externalTaskRequestContext.getJobId();\n        String tenantId = externalTaskRequestContext.getTenantId();\n        DPWorkflowJobDetailsDTO workflowJobDetails = externalTaskRequestContext.getWorkflowJobDetails();\n        String taskId = externalTaskRequestContext.getTaskId();\n        ParquetFile parquetFile;\n\n        try {\n            Map<String, String> metaData = externalTaskRequestContext.getMetaData();\n            Map<String, Object> workFlowSystemProperties = externalTaskRequestContext.getWorkflowSystemProperties();\n            Map<String, Object> extractFile = GA4ExtractUtil.getGA4Report(jobId, taskId, metaData, workFlowSystemProperties, workflowJobDetails);\n            parquetFile = (ParquetFile) extractFile.get(\"parquetFile\");\n            TaskResult taskResult = new TaskResult((List<FieldInfo>) extractFile.get(\"headers\"), null);\n            taskResult.setResultCount(parquetFile.getNumRecords());\n            ExternalExtractionTaskResult.ExternalExtractionTaskResultBuilder externalExtractionTaskResultBuilder = new ExternalExtractionTaskResult.ExternalExtractionTaskResultBuilder()\n                    .setExtractedFiles(Collections.singletonList(parquetFile.getAbsolutePath()))\n                    .setTaskResult(taskResult);\n\n            ExternalExtractionTaskResult externalTaskResult = externalExtractionTaskResultBuilder.build();\n            externalTaskResult.setEnableParquetConversion(false);\n            ExternalTaskUtil.saveExternalTaskResult(externalTaskRequestContext, externalTaskResult);\n\n        } catch (Exception ex) {\n            LOGGER.error(\"Exception while executing GA4 Task.  tId- {}, jobId- {}, taskId- {}  with error - {}\",\n                    tenantId, jobId, taskId, ex.getMessage(), ex);\n            throw new DPSystemException(ex.getMessage(), ex);\n        }\n    }\n}\n\n"}
2025-05-13 21:03:10 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:03:10 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:03:10 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:03:10 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    public static void main(String[] args) {\n        executeTask(ExternalTaskUtil.getExternalTaskRequestContext());\n    }\n"}
2025-05-13 21:03:12 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:03:12 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:03:12 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:03:12 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    private static void executeTask(ExternalTaskRequestContext externalTaskRequestContext) {\n        String jobId = externalTaskRequestContext.getJobId();\n        String tenantId = externalTaskRequestContext.getTenantId();\n        DPWorkflowJobDetailsDTO workflowJobDetails = externalTaskRequestContext.getWorkflowJobDetails();\n        String taskId = externalTaskRequestContext.getTaskId();\n        ParquetFile parquetFile;\n\n        try {\n            Map<String, String> metaData = externalTaskRequestContext.getMetaData();\n            Map<String, Object> workFlowSystemProperties = externalTaskRequestContext.getWorkflowSystemProperties();\n            Map<String, Object> extractFile = GA4ExtractUtil.getGA4Report(jobId, taskId, metaData, workFlowSystemProperties, workflowJobDetails);\n            parquetFile = (ParquetFile) extractFile.get(\"parquetFile\");\n            TaskResult taskResult = new TaskResult((List<FieldInfo>) extractFile.get(\"headers\"), null);\n            taskResult.setResultCount(parquetFile.getNumRecords());\n            ExternalExtractionTaskResult.ExternalExtractionTaskResultBuilder externalExtractionTaskResultBuilder = new ExternalExtractionTaskResult.ExternalExtractionTaskResultBuilder()\n                    .setExtractedFiles(Collections.singletonList(parquetFile.getAbsolutePath()))\n                    .setTaskResult(taskResult);\n\n            ExternalExtractionTaskResult externalTaskResult = externalExtractionTaskResultBuilder.build();\n            externalTaskResult.setEnableParquetConversion(false);\n            ExternalTaskUtil.saveExternalTaskResult(externalTaskRequestContext, externalTaskResult);\n\n        } catch (Exception ex) {\n            LOGGER.error(\"Exception while executing GA4 Task.  tId- {}, jobId- {}, taskId- {}  with error - {}\",\n                    tenantId, jobId, taskId, ex.getMessage(), ex);\n            throw new DPSystemException(ex.getMessage(), ex);\n        }\n    }\n"}
2025-05-13 21:03:13 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:03:13 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:03:13 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:03:13 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"public class GA4ExtractionTask {\n    private static final Logger LOGGER = LoggerFactory.getLogger(GA4ExtractionTask.class);\n\n    public static void main(String[] args) {\n        executeTask(ExternalTaskUtil.getExternalTaskRequestContext());\n    }\n\n    private static void executeTask(ExternalTaskRequestContext externalTaskRequestContext) {\n        String jobId = externalTaskRequestContext.getJobId();\n        String tenantId = externalTaskRequestContext.getTenantId();\n        DPWorkflowJobDetailsDTO workflowJobDetails = externalTaskRequestContext.getWorkflowJobDetails();\n        String taskId = externalTaskRequestContext.getTaskId();\n        ParquetFile parquetFile;\n\n        try {\n            Map<String, String> metaData = externalTaskRequestContext.getMetaData();\n            Map<String, Object> workFlowSystemProperties = externalTaskRequestContext.getWorkflowSystemProperties();\n            Map<String, Object> extractFile = GA4ExtractUtil.getGA4Report(jobId, taskId, metaData, workFlowSystemProperties, workflowJobDetails);\n            parquetFile = (ParquetFile) extractFile.get(\"parquetFile\");\n            TaskResult taskResult = new TaskResult((List<FieldInfo>) extractFile.get(\"headers\"), null);\n            taskResult.setResultCount(parquetFile.getNumRecords());\n            ExternalExtractionTaskResult.ExternalExtractionTaskResultBuilder externalExtractionTaskResultBuilder = new ExternalExtractionTaskResult.ExternalExtractionTaskResultBuilder()\n                    .setExtractedFiles(Collections.singletonList(parquetFile.getAbsolutePath()))\n                    .setTaskResult(taskResult);\n\n            ExternalExtractionTaskResult externalTaskResult = externalExtractionTaskResultBuilder.build();\n            externalTaskResult.setEnableParquetConversion(false);\n            ExternalTaskUtil.saveExternalTaskResult(externalTaskRequestContext, externalTaskResult);\n\n        } catch (Exception ex) {\n            LOGGER.error(\"Exception while executing GA4 Task.  tId- {}, jobId- {}, taskId- {}  with error - {}\",\n                    tenantId, jobId, taskId, ex.getMessage(), ex);\n            throw new DPSystemException(ex.getMessage(), ex);\n        }\n    }\n}\n"}
2025-05-13 21:03:15 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:03:15 [main] INFO  c.l.service.impl.BasicL3AgentService - Processed file: /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/code/dp_dynamic_tasks/ga4-extraction-task/src/main/java/com/gainsight/services/external/ga4/extraction/task/GA4ExtractionTask.java with 4 chunks
2025-05-13 21:03:15 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:03:15 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:03:15 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"package com.gainsight.services.external.ga4.extraction.task.utils;\n\nimport com.gainsight.services.dataprocessing.commons.audit.AuditMetadata;\nimport com.gainsight.services.dataprocessing.commons.cryptography.CryptUtil;\nimport com.gainsight.services.dataprocessing.commons.exception.DPSystemException;\nimport com.gainsight.services.dataprocessing.commons.parquet.writer.CsvParquetWriter;\nimport com.gainsight.services.dataprocessing.commons.pojo.fields.DateTimeProperties;\nimport com.gainsight.services.dataprocessing.commons.pojo.fields.FieldInfo;\nimport com.gainsight.services.dataprocessing.commons.pojo.gaextract.GAAccessDetails;\nimport com.gainsight.services.dataprocessing.commons.pojo.gaextract.GAExtractDetails;\nimport com.gainsight.services.dataprocessing.commons.pojo.gaextract.GAReportGroup;\nimport com.gainsight.services.dataprocessing.commons.pojo.workflow.DPWorkflowJobDetailsDTO;\nimport com.gainsight.services.dataprocessing.commons.proxy.mda.CustomerCurrencyDTO;\nimport com.gainsight.services.dataprocessing.commons.system.ParquetFile;\nimport com.gainsight.services.dataprocessing.commons.system.Precondition;\nimport com.gainsight.services.dataprocessing.commons.utils.DPUtils;\nimport com.gainsight.services.dataprocessing.dataprocessor.dagdataprocessor.utils.CustomerCurrencyUtil;\nimport com.gainsight.services.dataprocessing.external.task.ExternalTaskUtil;\nimport com.gainsight.services.external.ga4.extraction.task.pojo.GA4ConnectionInfo;\nimport com.gainsight.services.external.ga4.extraction.task.service.GA4Service;\nimport com.gainsight.services.utilities.datahighway.dhcommons.externals.MDACalloutService;\nimport com.gainsight.services.utilities.datahighway.dhcommons.pojo.account.UDMAccountType;\nimport com.gainsight.services.utilities.datahighway.dhcommons.utils.DHUtils;\nimport com.google.api.client.googleapis.json.GoogleJsonError;\nimport com.google.api.client.googleapis.json.GoogleJsonResponseException;\nimport com.google.api.services.analyticsdata.v1beta.model.*;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport org.apache.commons.collections4.CollectionUtils;\nimport org.apache.commons.collections4.MapUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.IOException;\nimport java.time.format.DateTimeFormatter;\nimport java.util.*;\nimport java.util.stream.Collectors;\n\nimport static com.gainsight.services.dataprocessing.commons.constants.Constants.WebConstants.DH_B2B_SECRET;\nimport static com.gainsight.services.dataprocessing.commons.constants.Constants.WorkflowConstants.GA_EXTRACT_DETAILS_KEY;\nimport static com.gainsight.services.dataprocessing.commons.exception.ValidationCode.*;\nimport static com.gainsight.services.dataprocessing.commons.properties.DeploymentProperties.getDeploymentProperties;\nimport static com.gainsight.services.dataprocessing.commons.system.Precondition.assertState;\nimport static com.gainsight.services.dataprocessing.commons.system.Precondition.isNotNull;\nimport static com.gainsight.services.dataprocessing.commons.utils.DPCollectionUtils.nullSafeList;\nimport static com.gainsight.services.dataprocessing.commons.utils.DPUtils.msg;\nimport static com.gainsight.services.dataprocessing.commons.utils.DPUtils.valueOf;\n\n/**\n * Created by ptarika on 16/12/12.\n */\npublic class GA4ExtractHelper {\n\n    private final Logger LOGGER = LoggerFactory.getLogger(com.gainsight.services.external.ga4.extraction.task.utils.GA4ExtractHelper.class);\n    private static final long GA_REPORT_PAGE_SIZE = 10000;\n\n    private final Map<String, Object> systemProperties;\n    private final RecordFormatter recordFormatter;\n    private final Map<String, String> metaData;\n    private GAExtractDetails extractDetails;\n    private final String jobId;\n    private final String taskId;\n    private DPWorkflowJobDetailsDTO workflowJobDetails;\n\n    public GA4ExtractHelper(String jobId, String taskId, Map<String, String> metaData, Map<String, Object> systemProperties, DPWorkflowJobDetailsDTO workflowJobDetails) {\n        this.systemProperties = systemProperties;\n        this.metaData = metaData;\n        this.taskId = taskId;\n        this.jobId = jobId;\n        this.workflowJobDetails = workflowJobDetails;\n        init();\n        this.recordFormatter = new RecordFormatter();\n    }\n\n    private void init() {\n        String gaExtractDetailsJson = metaData.get(GA_EXTRACT_DETAILS_KEY);\n        this.extractDetails = DPUtils.convertJsonToObject(gaExtractDetailsJson, GAExtractDetails.class);\n\n        for (GAReportGroup gaReportGroup : extractDetails.getGaReportGroups()) {\n            gaReportGroup.setDimensions(nullSafeList(gaReportGroup.getDimensions()));\n        }\n\n        if (extractDetails.getStaticFields() == null) {\n            extractDetails.setStaticFields(Collections.emptyList());\n        }\n    }\n\n    public Map<String, Object> getGA4Report() {\n        logInfo(jobId, \"Starting GA4 extraction task\");\n\n        String tenantId = workflowJobDetails.getTenantId();\n        ParquetFile tmpParquetFile;\n        AuditMetadata auditMetadata = AuditMetadata.newInstance(tenantId, jobId, workflowJobDetails.getExternalId(), taskId);\n\n        try {\n            tmpParquetFile = new ParquetFile(DPUtils.getTempFilePath(tenantId, jobId, taskId, UUID.randomUUID().toString() + \".parquet\"));\n            Map<String, CustomerCurrencyDTO> currencyConversionMap = null;\n            if (DPUtils.isCurrencyConversionMapRequired(extractDetails.getStaticFields())) {\n                currencyConversionMap = CustomerCurrencyUtil.getCustomerCurrencyConversionMap(ExternalTaskUtil.getConfigSourceUrl(workflowJobDetails), auditMetadata, true);\n            }\n            writeToParaquetG4(tmpParquetFile, currencyConversionMap);\n            logInfo(taskId, DHUtils.msg(\"Parquet file creation successful. Records written = {}.\", tmpParquetFile.getNumRecords()));\n            Map<String, Object> result = Maps.newHashMap();\n            result.put(\"parquetFile\", tmpParquetFile);\n            result.put(\"headers\", recordFormatter.getHeaders());\n            return result;\n        } catch (GoogleJsonResponseException e) {\n            GoogleJsonError details = e.getDetails();\n            DPSystemException dpSystemException = new DPSystemException(e);\n            if (details != null) {\n                String message = \"Message=\" + details.getMessage() + \"Status=\" + details.get(\"status\");\n                dpSystemException.setMessage(message);\n            } else {\n                dpSystemException.setMessage(e.getMessage());\n            }\n            dpSystemException.setHttpStatus(e.getStatusCode());\n            throw dpSystemException;\n        } catch (IOException e) {\n            throw new DPSystemException(e.getMessage(), e, IO_ERROR);\n        } finally {\n            logInfo(taskId, \"Cleaning up....bye bye...\");\n        }\n    }\n\n\n    private void writeToParaquetG4(ParquetFile tmpParquetFile, Map<String, CustomerCurrencyDTO> currencyConversionMap) throws IOException {\n\n        CsvParquetWriter writer = new CsvParquetWriter(tmpParquetFile, recordFormatter.getHeaders(), this.systemProperties, currencyConversionMap, true);\n\n        GA4ConnectionInfo connectionInfo = buildGAConnectionInfo(extractDetails.getGaAccessDetails());\n        GA4Service service = GA4Service.initialize(connectionInfo);\n\n        for (GAReportGroup gaReportGroup : extractDetails.getGaReportGroups()) {\n            RunReportRequest reportRequest = buildReportRequestGA4(gaReportGroup);\n            long offset = 0;\n            int rowCount;\n            do {\n                reportRequest.setLimit(GA_REPORT_PAGE_SIZE);\n                reportRequest.setOffset(offset);\n                BatchRunReportsResponse response = service.getReportForGA4(extractDetails.getViewId(), Lists.newArrayList(reportRequest));\n                RunReportResponse report = validateGA4Response(response);\n                writeGA4ReportToParaquetFile(report, gaReportGroup, writer);\n                rowCount = report.getRows() != null ? report.getRows().size() : 0;\n                offset = offset + GA_REPORT_PAGE_SIZE;\n            } while (rowCount == GA_REPORT_PAGE_SIZE && !Thread.currentThread().isInterrupted());\n        }\n        writer.close();\n    }\n\n    private GA4ConnectionInfo buildGAConnectionInfo(GAAccessDetails gaAccessDetailsFromJob) {\n        GA4ConnectionInfo connectionInfo = new GA4ConnectionInfo();\n        GAAccessDetails gaAccessDetailsWithCredentials = fetchAccountDetailsFromMDA(gaAccessDetailsFromJob);\n        connectionInfo.setClientId(CryptUtil.decrypt(gaAccessDetailsWithCredentials.getClientId()));\n        connectionInfo.setClientSecret(CryptUtil.decrypt(gaAccessDetailsWithCredentials.getClientSecret()));\n        connectionInfo.setRefreshToken(CryptUtil.decrypt(gaAccessDetailsWithCredentials.getRefreshToken()));\n        return connectionInfo;\n    }\n\n    /**\n     * Get account details from MDA for Google Analytics.\n     * Assumption: AccountId and profileId are already set in extractDetails from UDM.\n     *\n     * @param gaAccessDetails {@link GAAccessDetails} from UDM which contains only accountId.\n     * @return {@link GAAccessDetails} encrypted GA credentials from MDA account details API.\n     */\n    private GAAccessDetails fetchAccountDetailsFromMDA(GAAccessDetails gaAccessDetails) {\n\n        GAAccessDetails gaAccessDetailsWithCredentials = new GAAccessDetails();\n\n        MDACalloutService mdaCalloutService = new MDACalloutService().withMdaBaseUrl(ExternalTaskUtil.getConfigSourceUrl(workflowJobDetails)).\n                withAuthToken(CryptUtil.encrypt(getDeploymentProperties().getValue(DH_B2B_SECRET))).withSharedSecretHeaderKey(\"secret\").withTenantId(workflowJobDetails.getTenantId());\n\n        logInfo(jobId, DHUtils.msg(\" Calling MDA Rest Api to fetch accountDetails for mdaConnectionId:{}, GA accountId:{} and tenant:{}\", gaAccessDetails.getConnectionId(), gaAccessDetails.getAccountId(), workflowJobDetails.getTenantId()));\n        Map<String, Object> connectionDetails = mdaCalloutService.getConnectionDetails(UDMAccountType.GOOGLE_ANALYTICS, gaAccessDetails.getConnectionId());\n\n        Precondition.assertState(MapUtils.isNotEmpty(connectionDetails), INVALID_GA_CREDENTIALS_VIA_MDA, msg(\" Empty response received from MDA for GA account id:{} and tenant:{}\", gaAccessDetails.getAccountId(), workflowJobDetails.getTenantId()));\n        Precondition.isNotBlank(valueOf(connectionDetails.get(\"clientId\")), INVALID_GA_CREDENTIALS_VIA_MDA, msg(\" Empty clientId received from MDA for GA account id:{} and tenant:{}\", gaAccessDetails.getAccountId(), workflowJobDetails.getTenantId()));\n        Precondition.isNotBlank(valueOf(connectionDetails.get(\"clientSecret\")), INVALID_GA_CREDENTIALS_VIA_MDA, msg(\" Empty clientSecret received from MDA for GA account id:{} and tenant:{}\", gaAccessDetails.getAccountId(), workflowJobDetails.getTenantId()));\n        Precondition.isNotBlank(valueOf(connectionDetails.get(\"refreshToken\")), INVALID_GA_CREDENTIALS_VIA_MDA, msg(\" Empty refreshToken received from MDA for GA account id:{} and tenant:{}\", gaAccessDetails.getAccountId(), workflowJobDetails.getTenantId()));\n        // Setting encrypted GA access details from MDA\n        gaAccessDetailsWithCredentials.setClientId(valueOf(connectionDetails.get(\"clientId\")));\n        gaAccessDetailsWithCredentials.setClientSecret(valueOf(connectionDetails.get(\"clientSecret\")));\n        gaAccessDetailsWithCredentials.setRefreshToken(valueOf(connectionDetails.get(\"refreshToken\")));\n        gaAccessDetailsWithCredentials.setAccountId(gaAccessDetails.getAccountId());\n        return gaAccessDetailsWithCredentials;\n    }\n\n    private RunReportResponse validateGA4Response(BatchRunReportsResponse response) {\n        isNotNull(response, GENERIC_SYSTEM_ERROR, \"Unexpected error, found report empty while GA Extraction.\");\n        List<RunReportResponse> reports = response.getReports();\n        assertState(CollectionUtils.isNotEmpty(reports) && reports.size() == 1, GENERIC_SYSTEM_ERROR, \"Unexpected error, found report empty while GA Extraction.\");\n        return reports.get(0);\n    }\n\n    private RunReportRequest buildReportRequestGA4(GAReportGroup gaReportGroup) {\n        RunReportRequest reportRequest = new RunReportRequest();\n        com.google.api.services.analyticsdata.v1beta.model.DateRange dateRange = new com.google.api.services.analyticsdata.v1beta.model.DateRange()\n                .setStartDate(extractDetails.getStartDate())\n                .setEndDate(extractDetails.getEndDate());\n        reportRequest.setProperty(\"properties/\" + extractDetails.getViewId());\n        reportRequest.setDateRanges(Lists.newArrayList(dateRange));\n        reportRequest.setDimensions(gaReportGroup.getDimensions().stream().map(this::getDimensionV4).collect(Collectors.toList()));\n        reportRequest.setMetrics(gaReportGroup.getMetrics().stream().map(this::getMetricV4).collect(Collectors.toList()));\n//        if (CollectionUtils.isNotEmpty(gaReportGroup.getDimensionFilterRules())) {\n//            //reportRequest.setDimensionFilter(gaReportGroup.getDimensionFilterRules().stream().map(this::getDimensionFilterClause).collect(Collectors.toList()));\n//        }\n//        if (CollectionUtils.isNotEmpty(gaReportGroup.getMetricFilterRules())) {\n//            //reportRequest.setMetricFilterClauses(gaReportGroup.getMetricFilterRules().stream().map(this::getMetricFilterClause).collect(Collectors.toList()));\n//        }\n//        OrderByInfo orderByInfo = gaReportGroup.getOrderByInfo();\n//        if (orderByInfo != null && CollectionUtils.isNotEmpty(orderByInfo.getOrderByFields())) {\n//            reportRequest.setOrderBys(Lists.newArrayList());\n//            for (FieldInfo fieldInfo : orderByInfo.getOrderByFields()) {\n//                //reportRequest.getOrderBys().add(getOrderBy(fieldInfo, orderByInfo.isAscending()));\n//            }\n//        }\n        return reportRequest;\n    }\n\n    private void writeGA4ReportToParaquetFile(RunReportResponse report, GAReportGroup gaReportGroup, CsvParquetWriter writer) throws IOException {\n        boolean recordsPresent = false;\n        if (report != null) {\n            List<Row> rows = report.getRows();\n            if (CollectionUtils.isNotEmpty(rows)) {\n                recordsPresent = true;\n                for (Row row : rows) {\n                    assertState(CollectionUtils.isNotEmpty(row.getMetricValues()), GENERIC_SYSTEM_ERROR, \"Unexpected error, found metrics empty while reading GA4 report.\");\n                    writer.writeForGA(recordFormatter.formatRecordGA4(row.getDimensionValues(), row.getMetricValues(), gaReportGroup));\n                }\n            }\n        }\n        if (!recordsPresent) {\n            LOGGER.warn(msg(\"No records returned from GA for group: {}. Skipping writing into parquet file.\", gaReportGroup));\n        }\n    }\n\n    private Metric getMetricV4(FieldInfo fieldInfo) {\n        return new Metric().setExpression(fieldInfo.getName()).setName(fieldInfo.getFieldAlias());\n    }\n\n    private Dimension getDimensionV4(FieldInfo fieldInfo) {\n        return new Dimension().setName(fieldInfo.getName());\n    }\n\n    private void logInfo(String taskId, String message) {\n        LOGGER.info(\"GA Task[{}] - {}\", taskId, message);\n    }\n\n    private class RecordFormatter {\n\n        private LinkedList<FieldInfo> headers = new LinkedList<>();\n        private Map<String, RecordMeta> recordIndexMapping = new HashMap<>();\n\n        private RecordFormatter() {\n            Map<String, Integer> aliasIndexMapping = new HashMap<>();\n            headers.addAll(extractDetails.getStaticFields());\n            int recordIndex = headers.size();\n            int aliasIndex = headers.size();\n            for (GAReportGroup gaReportGroup : extractDetails.getGaReportGroups()) {\n                int fieldInfoIndex = 0;\n                for (FieldInfo dim : gaReportGroup.getDimensions()) {\n                    if (aliasIndexMapping.containsKey(dim.getFieldAlias())) {\n                        recordIndexMapping.put(gaReportGroup.getName() + fieldInfoIndex, new RecordMeta(dim, aliasIndexMapping.get(dim.getFieldAlias())));\n                    } else {\n                        recordIndexMapping.put(gaReportGroup.getName() + fieldInfoIndex, new RecordMeta(dim, recordIndex++));\n                        aliasIndexMapping.put(dim.getFieldAlias(), aliasIndex++);\n                        headers.add(dim);\n                    }\n                    fieldInfoIndex++;\n                }\n                for (FieldInfo met : gaReportGroup.getMetrics()) {\n                    if (aliasIndexMapping.containsKey(met.getFieldAlias())) {\n                        recordIndexMapping.put(gaReportGroup.getName() + fieldInfoIndex, new RecordMeta(met, aliasIndexMapping.get(met.getFieldAlias())));\n                    } else {\n                        recordIndexMapping.put(gaReportGroup.getName() + fieldInfoIndex, new RecordMeta(met, recordIndex++));\n                        aliasIndexMapping.put(met.getFieldAlias(), aliasIndex++);\n                        headers.add(met);\n                    }\n                    fieldInfoIndex++;\n                }\n            }\n        }\n\n        public List<FieldInfo> getHeaders() {\n            return headers;\n        }\n\n        private List<String> formatRecordGA4(List<DimensionValue> dimensions, List<MetricValue> metrics, GAReportGroup gaReportGroup) {\n            List<String> values = Lists.newArrayList();\n            //prepend all static values in record\n            for (FieldInfo fieldInfo : extractDetails.getStaticFields()) {\n                values.add(DHUtils.valueOf(fieldInfo.getValue()));\n            }\n\n            //padman...\n            for (int i = 0; i < headers.size(); i++) {\n                values.add(null);\n            }\n\n            String name = gaReportGroup.getName();\n            int fieldIndex = 0;\n            for (DimensionValue dimension : dimensions) {\n                RecordMeta recordMeta = recordIndexMapping.get(name + fieldIndex);\n                values.set(recordMeta.getRecordPosition(), dimension.getValue());\n                fieldIndex++;\n            }\n\n            for (MetricValue metric : metrics) {\n                RecordMeta recordMeta = recordIndexMapping.get(name + fieldIndex);\n                values.set(recordMeta.getRecordPosition(), metric.getValue());\n                fieldIndex++;\n            }\n            return values;\n        }\n    }\n\n    private static class RecordMeta {\n        private FieldInfo fieldInfo;\n        private int recordPosition = -1;\n        private DateTimeFormatter dateTimeFormatter;\n\n        public RecordMeta(FieldInfo fieldInfo, int recordPosition) {\n            this.fieldInfo = fieldInfo;\n            this.recordPosition = recordPosition;\n            init();\n        }\n\n        private void init() {\n            DateTimeProperties dateTimeProperties = fieldInfo.getDateTimeProperties();\n            String format;\n            if (dateTimeProperties != null && (format = dateTimeProperties.getFormat()) != null) {\n                this.dateTimeFormatter = DateTimeFormatter.ofPattern(format);\n            }\n        }\n\n\n        public int getRecordPosition() {\n            return recordPosition;\n        }\n    }\n\n}\n"}
2025-05-13 21:03:16 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:03:16 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:03:16 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:03:16 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    public GA4ExtractHelper(String jobId, String taskId, Map<String, String> metaData, Map<String, Object> systemProperties, DPWorkflowJobDetailsDTO workflowJobDetails) {\n        this.systemProperties = systemProperties;\n        this.metaData = metaData;\n        this.taskId = taskId;\n        this.jobId = jobId;\n        this.workflowJobDetails = workflowJobDetails;\n        init();\n        this.recordFormatter = new RecordFormatter();\n    }\n"}
2025-05-13 21:03:18 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:03:18 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:03:18 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:03:18 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    private void init() {\n        String gaExtractDetailsJson = metaData.get(GA_EXTRACT_DETAILS_KEY);\n        this.extractDetails = DPUtils.convertJsonToObject(gaExtractDetailsJson, GAExtractDetails.class);\n\n        for (GAReportGroup gaReportGroup : extractDetails.getGaReportGroups()) {\n            gaReportGroup.setDimensions(nullSafeList(gaReportGroup.getDimensions()));\n        }\n\n        if (extractDetails.getStaticFields() == null) {\n            extractDetails.setStaticFields(Collections.emptyList());\n        }\n    }\n"}
2025-05-13 21:03:19 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:03:19 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:03:19 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:03:19 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    public Map<String, Object> getGA4Report() {\n        logInfo(jobId, \"Starting GA4 extraction task\");\n\n        String tenantId = workflowJobDetails.getTenantId();\n        ParquetFile tmpParquetFile;\n        AuditMetadata auditMetadata = AuditMetadata.newInstance(tenantId, jobId, workflowJobDetails.getExternalId(), taskId);\n\n        try {\n            tmpParquetFile = new ParquetFile(DPUtils.getTempFilePath(tenantId, jobId, taskId, UUID.randomUUID().toString() + \".parquet\"));\n            Map<String, CustomerCurrencyDTO> currencyConversionMap = null;\n            if (DPUtils.isCurrencyConversionMapRequired(extractDetails.getStaticFields())) {\n                currencyConversionMap = CustomerCurrencyUtil.getCustomerCurrencyConversionMap(ExternalTaskUtil.getConfigSourceUrl(workflowJobDetails), auditMetadata, true);\n            }\n            writeToParaquetG4(tmpParquetFile, currencyConversionMap);\n            logInfo(taskId, DHUtils.msg(\"Parquet file creation successful. Records written = {}.\", tmpParquetFile.getNumRecords()));\n            Map<String, Object> result = Maps.newHashMap();\n            result.put(\"parquetFile\", tmpParquetFile);\n            result.put(\"headers\", recordFormatter.getHeaders());\n            return result;\n        } catch (GoogleJsonResponseException e) {\n            GoogleJsonError details = e.getDetails();\n            DPSystemException dpSystemException = new DPSystemException(e);\n            if (details != null) {\n                String message = \"Message=\" + details.getMessage() + \"Status=\" + details.get(\"status\");\n                dpSystemException.setMessage(message);\n            } else {\n                dpSystemException.setMessage(e.getMessage());\n            }\n            dpSystemException.setHttpStatus(e.getStatusCode());\n            throw dpSystemException;\n        } catch (IOException e) {\n            throw new DPSystemException(e.getMessage(), e, IO_ERROR);\n        } finally {\n            logInfo(taskId, \"Cleaning up....bye bye...\");\n        }\n    }\n"}
2025-05-13 21:03:20 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:03:20 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:03:20 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:03:20 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    private void writeToParaquetG4(ParquetFile tmpParquetFile, Map<String, CustomerCurrencyDTO> currencyConversionMap) throws IOException {\n\n        CsvParquetWriter writer = new CsvParquetWriter(tmpParquetFile, recordFormatter.getHeaders(), this.systemProperties, currencyConversionMap, true);\n\n        GA4ConnectionInfo connectionInfo = buildGAConnectionInfo(extractDetails.getGaAccessDetails());\n        GA4Service service = GA4Service.initialize(connectionInfo);\n\n        for (GAReportGroup gaReportGroup : extractDetails.getGaReportGroups()) {\n            RunReportRequest reportRequest = buildReportRequestGA4(gaReportGroup);\n            long offset = 0;\n            int rowCount;\n            do {\n                reportRequest.setLimit(GA_REPORT_PAGE_SIZE);\n                reportRequest.setOffset(offset);\n                BatchRunReportsResponse response = service.getReportForGA4(extractDetails.getViewId(), Lists.newArrayList(reportRequest));\n                RunReportResponse report = validateGA4Response(response);\n                writeGA4ReportToParaquetFile(report, gaReportGroup, writer);\n                rowCount = report.getRows() != null ? report.getRows().size() : 0;\n                offset = offset + GA_REPORT_PAGE_SIZE;\n            } while (rowCount == GA_REPORT_PAGE_SIZE && !Thread.currentThread().isInterrupted());\n        }\n        writer.close();\n    }\n"}
2025-05-13 21:03:22 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:03:22 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:03:22 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:03:22 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    private GA4ConnectionInfo buildGAConnectionInfo(GAAccessDetails gaAccessDetailsFromJob) {\n        GA4ConnectionInfo connectionInfo = new GA4ConnectionInfo();\n        GAAccessDetails gaAccessDetailsWithCredentials = fetchAccountDetailsFromMDA(gaAccessDetailsFromJob);\n        connectionInfo.setClientId(CryptUtil.decrypt(gaAccessDetailsWithCredentials.getClientId()));\n        connectionInfo.setClientSecret(CryptUtil.decrypt(gaAccessDetailsWithCredentials.getClientSecret()));\n        connectionInfo.setRefreshToken(CryptUtil.decrypt(gaAccessDetailsWithCredentials.getRefreshToken()));\n        return connectionInfo;\n    }\n"}
2025-05-13 21:03:23 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:03:23 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:03:23 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:03:23 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    private GAAccessDetails fetchAccountDetailsFromMDA(GAAccessDetails gaAccessDetails) {\n\n        GAAccessDetails gaAccessDetailsWithCredentials = new GAAccessDetails();\n\n        MDACalloutService mdaCalloutService = new MDACalloutService().withMdaBaseUrl(ExternalTaskUtil.getConfigSourceUrl(workflowJobDetails)).\n                withAuthToken(CryptUtil.encrypt(getDeploymentProperties().getValue(DH_B2B_SECRET))).withSharedSecretHeaderKey(\"secret\").withTenantId(workflowJobDetails.getTenantId());\n\n        logInfo(jobId, DHUtils.msg(\" Calling MDA Rest Api to fetch accountDetails for mdaConnectionId:{}, GA accountId:{} and tenant:{}\", gaAccessDetails.getConnectionId(), gaAccessDetails.getAccountId(), workflowJobDetails.getTenantId()));\n        Map<String, Object> connectionDetails = mdaCalloutService.getConnectionDetails(UDMAccountType.GOOGLE_ANALYTICS, gaAccessDetails.getConnectionId());\n\n        Precondition.assertState(MapUtils.isNotEmpty(connectionDetails), INVALID_GA_CREDENTIALS_VIA_MDA, msg(\" Empty response received from MDA for GA account id:{} and tenant:{}\", gaAccessDetails.getAccountId(), workflowJobDetails.getTenantId()));\n        Precondition.isNotBlank(valueOf(connectionDetails.get(\"clientId\")), INVALID_GA_CREDENTIALS_VIA_MDA, msg(\" Empty clientId received from MDA for GA account id:{} and tenant:{}\", gaAccessDetails.getAccountId(), workflowJobDetails.getTenantId()));\n        Precondition.isNotBlank(valueOf(connectionDetails.get(\"clientSecret\")), INVALID_GA_CREDENTIALS_VIA_MDA, msg(\" Empty clientSecret received from MDA for GA account id:{} and tenant:{}\", gaAccessDetails.getAccountId(), workflowJobDetails.getTenantId()));\n        Precondition.isNotBlank(valueOf(connectionDetails.get(\"refreshToken\")), INVALID_GA_CREDENTIALS_VIA_MDA, msg(\" Empty refreshToken received from MDA for GA account id:{} and tenant:{}\", gaAccessDetails.getAccountId(), workflowJobDetails.getTenantId()));\n        // Setting encrypted GA access details from MDA\n        gaAccessDetailsWithCredentials.setClientId(valueOf(connectionDetails.get(\"clientId\")));\n        gaAccessDetailsWithCredentials.setClientSecret(valueOf(connectionDetails.get(\"clientSecret\")));\n        gaAccessDetailsWithCredentials.setRefreshToken(valueOf(connectionDetails.get(\"refreshToken\")));\n        gaAccessDetailsWithCredentials.setAccountId(gaAccessDetails.getAccountId());\n        return gaAccessDetailsWithCredentials;\n    }\n"}
2025-05-13 21:03:24 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:03:25 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:03:25 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:03:25 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    private RunReportResponse validateGA4Response(BatchRunReportsResponse response) {\n        isNotNull(response, GENERIC_SYSTEM_ERROR, \"Unexpected error, found report empty while GA Extraction.\");\n        List<RunReportResponse> reports = response.getReports();\n        assertState(CollectionUtils.isNotEmpty(reports) && reports.size() == 1, GENERIC_SYSTEM_ERROR, \"Unexpected error, found report empty while GA Extraction.\");\n        return reports.get(0);\n    }\n"}
2025-05-13 21:03:26 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:03:26 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:03:26 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:03:26 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    private RunReportRequest buildReportRequestGA4(GAReportGroup gaReportGroup) {\n        RunReportRequest reportRequest = new RunReportRequest();\n        com.google.api.services.analyticsdata.v1beta.model.DateRange dateRange = new com.google.api.services.analyticsdata.v1beta.model.DateRange()\n                .setStartDate(extractDetails.getStartDate())\n                .setEndDate(extractDetails.getEndDate());\n        reportRequest.setProperty(\"properties/\" + extractDetails.getViewId());\n        reportRequest.setDateRanges(Lists.newArrayList(dateRange));\n        reportRequest.setDimensions(gaReportGroup.getDimensions().stream().map(this::getDimensionV4).collect(Collectors.toList()));\n        reportRequest.setMetrics(gaReportGroup.getMetrics().stream().map(this::getMetricV4).collect(Collectors.toList()));\n//        if (CollectionUtils.isNotEmpty(gaReportGroup.getDimensionFilterRules())) {\n//            //reportRequest.setDimensionFilter(gaReportGroup.getDimensionFilterRules().stream().map(this::getDimensionFilterClause).collect(Collectors.toList()));\n//        }\n//        if (CollectionUtils.isNotEmpty(gaReportGroup.getMetricFilterRules())) {\n//            //reportRequest.setMetricFilterClauses(gaReportGroup.getMetricFilterRules().stream().map(this::getMetricFilterClause).collect(Collectors.toList()));\n//        }\n//        OrderByInfo orderByInfo = gaReportGroup.getOrderByInfo();\n//        if (orderByInfo != null && CollectionUtils.isNotEmpty(orderByInfo.getOrderByFields())) {\n//            reportRequest.setOrderBys(Lists.newArrayList());\n//            for (FieldInfo fieldInfo : orderByInfo.getOrderByFields()) {\n//                //reportRequest.getOrderBys().add(getOrderBy(fieldInfo, orderByInfo.isAscending()));\n//            }\n//        }\n        return reportRequest;\n    }\n"}
2025-05-13 21:03:27 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:03:27 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:03:27 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:03:27 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    private void writeGA4ReportToParaquetFile(RunReportResponse report, GAReportGroup gaReportGroup, CsvParquetWriter writer) throws IOException {\n        boolean recordsPresent = false;\n        if (report != null) {\n            List<Row> rows = report.getRows();\n            if (CollectionUtils.isNotEmpty(rows)) {\n                recordsPresent = true;\n                for (Row row : rows) {\n                    assertState(CollectionUtils.isNotEmpty(row.getMetricValues()), GENERIC_SYSTEM_ERROR, \"Unexpected error, found metrics empty while reading GA4 report.\");\n                    writer.writeForGA(recordFormatter.formatRecordGA4(row.getDimensionValues(), row.getMetricValues(), gaReportGroup));\n                }\n            }\n        }\n        if (!recordsPresent) {\n            LOGGER.warn(msg(\"No records returned from GA for group: {}. Skipping writing into parquet file.\", gaReportGroup));\n        }\n    }\n"}
2025-05-13 21:03:28 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:03:29 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:03:29 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:03:29 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    private Metric getMetricV4(FieldInfo fieldInfo) {\n        return new Metric().setExpression(fieldInfo.getName()).setName(fieldInfo.getFieldAlias());\n    }\n"}
2025-05-13 21:03:30 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:03:30 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:03:30 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:03:30 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    private Dimension getDimensionV4(FieldInfo fieldInfo) {\n        return new Dimension().setName(fieldInfo.getName());\n    }\n"}
2025-05-13 21:03:31 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:03:31 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:03:31 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:03:31 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    private void logInfo(String taskId, String message) {\n        LOGGER.info(\"GA Task[{}] - {}\", taskId, message);\n    }\n"}
2025-05-13 21:03:32 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:03:33 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:03:33 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:03:33 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"        private RecordFormatter() {\n            Map<String, Integer> aliasIndexMapping = new HashMap<>();\n            headers.addAll(extractDetails.getStaticFields());\n            int recordIndex = headers.size();\n            int aliasIndex = headers.size();\n            for (GAReportGroup gaReportGroup : extractDetails.getGaReportGroups()) {\n                int fieldInfoIndex = 0;\n                for (FieldInfo dim : gaReportGroup.getDimensions()) {\n                    if (aliasIndexMapping.containsKey(dim.getFieldAlias())) {\n                        recordIndexMapping.put(gaReportGroup.getName() + fieldInfoIndex, new RecordMeta(dim, aliasIndexMapping.get(dim.getFieldAlias())));\n                    } else {\n                        recordIndexMapping.put(gaReportGroup.getName() + fieldInfoIndex, new RecordMeta(dim, recordIndex++));\n                        aliasIndexMapping.put(dim.getFieldAlias(), aliasIndex++);\n                        headers.add(dim);\n                    }\n                    fieldInfoIndex++;\n                }\n                for (FieldInfo met : gaReportGroup.getMetrics()) {\n                    if (aliasIndexMapping.containsKey(met.getFieldAlias())) {\n                        recordIndexMapping.put(gaReportGroup.getName() + fieldInfoIndex, new RecordMeta(met, aliasIndexMapping.get(met.getFieldAlias())));\n                    } else {\n                        recordIndexMapping.put(gaReportGroup.getName() + fieldInfoIndex, new RecordMeta(met, recordIndex++));\n                        aliasIndexMapping.put(met.getFieldAlias(), aliasIndex++);\n                        headers.add(met);\n                    }\n                    fieldInfoIndex++;\n                }\n            }\n        }\n\n        public List<FieldInfo> getHeaders() {\n            return headers;\n        }\n\n        private List<String> formatRecordGA4(List<DimensionValue> dimensions, List<MetricValue> metrics, GAReportGroup gaReportGroup) {\n            List<String> values = Lists.newArrayList();\n            //prepend all static values in record\n            for (FieldInfo fieldInfo : extractDetails.getStaticFields()) {\n                values.add(DHUtils.valueOf(fieldInfo.getValue()));\n            }\n\n            //padman...\n            for (int i = 0; i < headers.size(); i++) {\n                values.add(null);\n            }\n\n            String name = gaReportGroup.getName();\n            int fieldIndex = 0;\n            for (DimensionValue dimension : dimensions) {\n                RecordMeta recordMeta = recordIndexMapping.get(name + fieldIndex);\n                values.set(recordMeta.getRecordPosition(), dimension.getValue());\n                fieldIndex++;\n            }\n\n            for (MetricValue metric : metrics) {\n                RecordMeta recordMeta = recordIndexMapping.get(name + fieldIndex);\n                values.set(recordMeta.getRecordPosition(), metric.getValue());\n                fieldIndex++;\n            }\n            return values;\n        }\n    }\n"}
2025-05-13 21:03:34 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:03:34 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:03:34 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:03:34 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"        public RecordMeta(FieldInfo fieldInfo, int recordPosition) {\n            this.fieldInfo = fieldInfo;\n            this.recordPosition = recordPosition;\n            init();\n        }\n\n        private void init() {\n            DateTimeProperties dateTimeProperties = fieldInfo.getDateTimeProperties();\n            String format;\n            if (dateTimeProperties != null && (format = dateTimeProperties.getFormat()) != null) {\n                this.dateTimeFormatter = DateTimeFormatter.ofPattern(format);\n            }\n        }\n\n\n        public int getRecordPosition() {\n            return recordPosition;\n        }\n    }\n"}
2025-05-13 21:03:35 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:03:35 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:03:35 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:03:35 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    private static class RecordMeta {\n        private FieldInfo fieldInfo;\n        private int recordPosition = -1;\n        private DateTimeFormatter dateTimeFormatter;\n\n        public RecordMeta(FieldInfo fieldInfo, int recordPosition) {\n            this.fieldInfo = fieldInfo;\n            this.recordPosition = recordPosition;\n            init();\n        }\n\n        private void init() {\n            DateTimeProperties dateTimeProperties = fieldInfo.getDateTimeProperties();\n            String format;\n            if (dateTimeProperties != null && (format = dateTimeProperties.getFormat()) != null) {\n                this.dateTimeFormatter = DateTimeFormatter.ofPattern(format);\n            }\n        }\n\n\n        public int getRecordPosition() {\n            return recordPosition;\n        }\n    }\n\n}\n"}
2025-05-13 21:03:36 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:03:36 [main] INFO  c.l.service.impl.BasicL3AgentService - Processed file: /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/code/dp_dynamic_tasks/ga4-extraction-task/src/main/java/com/gainsight/services/external/ga4/extraction/task/utils/GA4ExtractHelper.java with 16 chunks
2025-05-13 21:03:36 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:03:36 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:03:36 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"package com.gainsight.services.external.ga4.extraction.task.utils;\n\nimport com.gainsight.services.dataprocessing.commons.pojo.workflow.DPWorkflowJobDetailsDTO;\n\nimport java.util.Map;\n\n/**\n * Created by Tarika on 12/12/2021.\n */\npublic final class GA4ExtractUtil {\n\n    public static Map<String, Object> getGA4Report(String jobId, String taskId, Map<String, String> metaData, Map<String, Object> systemProperties, DPWorkflowJobDetailsDTO workflowJobDetails) {\n        return new GA4ExtractHelper(jobId, taskId, metaData, systemProperties, workflowJobDetails).getGA4Report();\n    }\n\n}\n"}
2025-05-13 21:03:38 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:03:38 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:03:38 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:03:38 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    public static Map<String, Object> getGA4Report(String jobId, String taskId, Map<String, String> metaData, Map<String, Object> systemProperties, DPWorkflowJobDetailsDTO workflowJobDetails) {\n        return new GA4ExtractHelper(jobId, taskId, metaData, systemProperties, workflowJobDetails).getGA4Report();\n    }\n"}
2025-05-13 21:03:39 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:03:39 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:03:39 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:03:39 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"public final class GA4ExtractUtil {\n\n    public static Map<String, Object> getGA4Report(String jobId, String taskId, Map<String, String> metaData, Map<String, Object> systemProperties, DPWorkflowJobDetailsDTO workflowJobDetails) {\n        return new GA4ExtractHelper(jobId, taskId, metaData, systemProperties, workflowJobDetails).getGA4Report();\n    }\n\n}\n"}
2025-05-13 21:03:40 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:03:40 [main] INFO  c.l.service.impl.BasicL3AgentService - Processed file: /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/code/dp_dynamic_tasks/ga4-extraction-task/src/main/java/com/gainsight/services/external/ga4/extraction/task/utils/GA4ExtractUtil.java with 3 chunks
2025-05-13 21:03:40 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:03:40 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:03:40 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"package com.gainsight.services.external.ga4.extraction.task.service;\n\nimport com.gainsight.services.external.ga4.extraction.task.pojo.GA4ConnectionInfo;\nimport com.google.api.services.analyticsdata.v1beta.model.BatchRunReportsResponse;\nimport com.google.api.services.analyticsdata.v1beta.model.RunReportRequest;\n\nimport java.io.IOException;\nimport java.util.List;\n\n/**\n * Created by ptarika on 16/12/21.\n */\npublic interface GA4Service {\n\n    static GA4Service initialize(GA4ConnectionInfo connectionInfo) {\n        return new GA4ServiceImpl(connectionInfo);\n    }\n\n    BatchRunReportsResponse getReportForGA4(String propertyId, List<RunReportRequest> requests) throws IOException;\n\n}\n"}
2025-05-13 21:03:42 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:03:42 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:03:42 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:03:42 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    static GA4Service initialize(GA4ConnectionInfo connectionInfo) {\n        return new GA4ServiceImpl(connectionInfo);\n    }\n"}
2025-05-13 21:03:43 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:03:43 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:03:43 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:03:43 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"public interface GA4Service {\n\n    static GA4Service initialize(GA4ConnectionInfo connectionInfo) {\n        return new GA4ServiceImpl(connectionInfo);\n    }\n\n    BatchRunReportsResponse getReportForGA4(String propertyId, List<RunReportRequest> requests) throws IOException;\n\n}\n"}
2025-05-13 21:03:44 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:03:44 [main] INFO  c.l.service.impl.BasicL3AgentService - Processed file: /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/code/dp_dynamic_tasks/ga4-extraction-task/src/main/java/com/gainsight/services/external/ga4/extraction/task/service/GA4Service.java with 3 chunks
2025-05-13 21:03:44 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:03:44 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:03:44 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"package com.gainsight.services.external.ga4.extraction.task.service;\n\nimport com.gainsight.services.dataprocessing.commons.exception.DPSystemException;\nimport com.gainsight.services.external.ga4.extraction.task.pojo.GA4ConnectionInfo;\nimport com.google.api.client.googleapis.auth.oauth2.GoogleCredential;\nimport com.google.api.client.googleapis.auth.oauth2.GoogleRefreshTokenRequest;\nimport com.google.api.client.googleapis.auth.oauth2.GoogleTokenResponse;\nimport com.google.api.client.googleapis.javanet.GoogleNetHttpTransport;\nimport com.google.api.client.http.HttpRequest;\nimport com.google.api.client.http.HttpRequestInitializer;\nimport com.google.api.client.http.HttpTransport;\nimport com.google.api.client.json.JsonFactory;\nimport com.google.api.client.json.jackson2.JacksonFactory;\nimport com.google.api.services.analyticsdata.v1beta.AnalyticsData;\nimport com.google.api.services.analyticsdata.v1beta.model.BatchRunReportsRequest;\nimport com.google.api.services.analyticsdata.v1beta.model.BatchRunReportsResponse;\nimport com.google.api.services.analyticsdata.v1beta.model.RunReportRequest;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.IOException;\nimport java.util.List;\n\nimport static com.gainsight.services.dataprocessing.commons.constants.Constants.WorkflowConstants.*;\nimport static com.gainsight.services.dataprocessing.commons.properties.DeploymentProperties.getDeploymentProperties;\n\n/**\n * Created by ptarika on 12/12/2021.\n */\npublic class GA4ServiceImpl implements GA4Service {\n\n    private final Logger LOGGER = LoggerFactory.getLogger(GA4ServiceImpl.class);\n\n    private final GA4ConnectionInfo connectionInfo;\n    private AnalyticsData analyticsData;\n\n\n    GA4ServiceImpl(GA4ConnectionInfo connectionInfo) {\n        this.connectionInfo = connectionInfo;\n        initialize();\n    }\n\n    private void initialize() {\n        try {\n            JsonFactory jsonFactory = new JacksonFactory();\n            HttpTransport httpTransport = GoogleNetHttpTransport.newTrustedTransport();\n\n            String refreshToken = connectionInfo.getRefreshToken();\n            String clientId = connectionInfo.getClientId();\n            String clientSecret = connectionInfo.getClientSecret();\n\n            GoogleRefreshTokenRequest googleRefreshTokenRequest =\n                    new GoogleRefreshTokenRequest(httpTransport, jsonFactory, refreshToken, clientId, clientSecret);\n            GoogleTokenResponse tokenResponse = googleRefreshTokenRequest.execute();\n\n            GoogleCredential credential = new GoogleCredential\n                    .Builder()\n                    .setClientSecrets(clientId, clientSecret)\n                    .setJsonFactory(jsonFactory)\n                    .setTransport(httpTransport)\n                    .build()\n                    .setAccessToken(tokenResponse.getAccessToken())\n                    .setRefreshToken(refreshToken);\n\n          analyticsData = new AnalyticsData.Builder(httpTransport, jsonFactory, configureTimeouts(credential))\n                 .build();\n        } catch (Exception e) {\n            LOGGER.error(\"Not able to initialize the GA4 client :{}\",e.getMessage(),e);\n            throw new DPSystemException(\"Unable to initialize GA4 client.\", e);\n        }\n    }\n\n    private HttpRequestInitializer configureTimeouts(final HttpRequestInitializer requestInitializer) {\n        return new HttpRequestInitializer() {\n            @Override\n            public void initialize(HttpRequest httpRequest) throws IOException {\n                requestInitializer.initialize(httpRequest);\n                httpRequest.setConnectTimeout(getDeploymentProperties().getIntegerValue(GA_EXTRACT_CONNECT_TIMEOUT_MILLIS, 120000));\n                httpRequest.setReadTimeout(getDeploymentProperties().getIntegerValue(GA_EXTRACT_READ_TIMEOUT_MILLIS, 120000));\n                httpRequest.setNumberOfRetries(getDeploymentProperties().getIntegerValue(GA_EXTRACT_NUM_RETRIES, 5));\n\n                httpRequest.setIOExceptionHandler((request, supportsRetry) -> {\n                    LOGGER.error(\"IOException while calling: \" + request.getUrl() + \". Will issue retry if configured.\");\n                    //to make retries exponential multiply connectTimeout/socketTimeout\n                    return supportsRetry;\n                });\n            }\n        };\n    }\n\n    @Override\n    public BatchRunReportsResponse getReportForGA4(String propertyId, List<RunReportRequest> requests) throws IOException {\n        BatchRunReportsRequest getReportsRequest = new BatchRunReportsRequest()\n                .setRequests(requests);\n\n\n        return analyticsData.properties()\n                .batchRunReports(\"properties/\"+ propertyId, getReportsRequest)\n                .execute();\n    }\n\n}\n"}
2025-05-13 21:03:46 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:03:46 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:03:46 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:03:46 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    private void initialize() {\n        try {\n            JsonFactory jsonFactory = new JacksonFactory();\n            HttpTransport httpTransport = GoogleNetHttpTransport.newTrustedTransport();\n\n            String refreshToken = connectionInfo.getRefreshToken();\n            String clientId = connectionInfo.getClientId();\n            String clientSecret = connectionInfo.getClientSecret();\n\n            GoogleRefreshTokenRequest googleRefreshTokenRequest =\n                    new GoogleRefreshTokenRequest(httpTransport, jsonFactory, refreshToken, clientId, clientSecret);\n            GoogleTokenResponse tokenResponse = googleRefreshTokenRequest.execute();\n\n            GoogleCredential credential = new GoogleCredential\n                    .Builder()\n                    .setClientSecrets(clientId, clientSecret)\n                    .setJsonFactory(jsonFactory)\n                    .setTransport(httpTransport)\n                    .build()\n                    .setAccessToken(tokenResponse.getAccessToken())\n                    .setRefreshToken(refreshToken);\n\n          analyticsData = new AnalyticsData.Builder(httpTransport, jsonFactory, configureTimeouts(credential))\n                 .build();\n        } catch (Exception e) {\n            LOGGER.error(\"Not able to initialize the GA4 client :{}\",e.getMessage(),e);\n            throw new DPSystemException(\"Unable to initialize GA4 client.\", e);\n        }\n    }\n"}
2025-05-13 21:03:47 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:03:47 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:03:47 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:03:47 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    private HttpRequestInitializer configureTimeouts(final HttpRequestInitializer requestInitializer) {\n        return new HttpRequestInitializer() {\n            @Override\n            public void initialize(HttpRequest httpRequest) throws IOException {\n                requestInitializer.initialize(httpRequest);\n                httpRequest.setConnectTimeout(getDeploymentProperties().getIntegerValue(GA_EXTRACT_CONNECT_TIMEOUT_MILLIS, 120000));\n                httpRequest.setReadTimeout(getDeploymentProperties().getIntegerValue(GA_EXTRACT_READ_TIMEOUT_MILLIS, 120000));\n                httpRequest.setNumberOfRetries(getDeploymentProperties().getIntegerValue(GA_EXTRACT_NUM_RETRIES, 5));\n\n                httpRequest.setIOExceptionHandler((request, supportsRetry) -> {\n                    LOGGER.error(\"IOException while calling: \" + request.getUrl() + \". Will issue retry if configured.\");\n                    //to make retries exponential multiply connectTimeout/socketTimeout\n                    return supportsRetry;\n                });\n            }\n        };\n    }\n"}
2025-05-13 21:03:48 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:03:49 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:03:49 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:03:49 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    public BatchRunReportsResponse getReportForGA4(String propertyId, List<RunReportRequest> requests) throws IOException {\n        BatchRunReportsRequest getReportsRequest = new BatchRunReportsRequest()\n                .setRequests(requests);\n\n\n        return analyticsData.properties()\n                .batchRunReports(\"properties/\"+ propertyId, getReportsRequest)\n                .execute();\n    }\n"}
2025-05-13 21:03:50 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:03:50 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:03:50 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:03:50 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"public class GA4ServiceImpl implements GA4Service {\n\n    private final Logger LOGGER = LoggerFactory.getLogger(GA4ServiceImpl.class);\n\n    private final GA4ConnectionInfo connectionInfo;\n    private AnalyticsData analyticsData;\n\n\n    GA4ServiceImpl(GA4ConnectionInfo connectionInfo) {\n        this.connectionInfo = connectionInfo;\n        initialize();\n    }\n\n    private void initialize() {\n        try {\n            JsonFactory jsonFactory = new JacksonFactory();\n            HttpTransport httpTransport = GoogleNetHttpTransport.newTrustedTransport();\n\n            String refreshToken = connectionInfo.getRefreshToken();\n            String clientId = connectionInfo.getClientId();\n            String clientSecret = connectionInfo.getClientSecret();\n\n            GoogleRefreshTokenRequest googleRefreshTokenRequest =\n                    new GoogleRefreshTokenRequest(httpTransport, jsonFactory, refreshToken, clientId, clientSecret);\n            GoogleTokenResponse tokenResponse = googleRefreshTokenRequest.execute();\n\n            GoogleCredential credential = new GoogleCredential\n                    .Builder()\n                    .setClientSecrets(clientId, clientSecret)\n                    .setJsonFactory(jsonFactory)\n                    .setTransport(httpTransport)\n                    .build()\n                    .setAccessToken(tokenResponse.getAccessToken())\n                    .setRefreshToken(refreshToken);\n\n          analyticsData = new AnalyticsData.Builder(httpTransport, jsonFactory, configureTimeouts(credential))\n                 .build();\n        } catch (Exception e) {\n            LOGGER.error(\"Not able to initialize the GA4 client :{}\",e.getMessage(),e);\n            throw new DPSystemException(\"Unable to initialize GA4 client.\", e);\n        }\n    }\n\n    private HttpRequestInitializer configureTimeouts(final HttpRequestInitializer requestInitializer) {\n        return new HttpRequestInitializer() {\n            @Override\n            public void initialize(HttpRequest httpRequest) throws IOException {\n                requestInitializer.initialize(httpRequest);\n                httpRequest.setConnectTimeout(getDeploymentProperties().getIntegerValue(GA_EXTRACT_CONNECT_TIMEOUT_MILLIS, 120000));\n                httpRequest.setReadTimeout(getDeploymentProperties().getIntegerValue(GA_EXTRACT_READ_TIMEOUT_MILLIS, 120000));\n                httpRequest.setNumberOfRetries(getDeploymentProperties().getIntegerValue(GA_EXTRACT_NUM_RETRIES, 5));\n\n                httpRequest.setIOExceptionHandler((request, supportsRetry) -> {\n                    LOGGER.error(\"IOException while calling: \" + request.getUrl() + \". Will issue retry if configured.\");\n                    //to make retries exponential multiply connectTimeout/socketTimeout\n                    return supportsRetry;\n                });\n            }\n        };\n    }\n\n    @Override\n    public BatchRunReportsResponse getReportForGA4(String propertyId, List<RunReportRequest> requests) throws IOException {\n        BatchRunReportsRequest getReportsRequest = new BatchRunReportsRequest()\n                .setRequests(requests);\n\n\n        return analyticsData.properties()\n                .batchRunReports(\"properties/\"+ propertyId, getReportsRequest)\n                .execute();\n    }\n\n}\n"}
2025-05-13 21:03:51 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:03:51 [main] INFO  c.l.service.impl.BasicL3AgentService - Processed file: /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/code/dp_dynamic_tasks/ga4-extraction-task/src/main/java/com/gainsight/services/external/ga4/extraction/task/service/GA4ServiceImpl.java with 5 chunks
2025-05-13 21:03:51 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:03:51 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:03:51 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"package com.gainsight.services.external.ga4.extraction.task.pojo;\n\nimport com.fasterxml.jackson.annotation.JsonIgnoreProperties;\nimport com.fasterxml.jackson.annotation.JsonInclude;\n\nimport java.io.Serializable;\n\n/**\n * Created by ptarika on 16/12/21.\n */\n@JsonIgnoreProperties(ignoreUnknown = true)\n@JsonInclude(JsonInclude.Include.NON_NULL)\npublic class GA4ConnectionInfo implements Serializable {\n\n    private static final long serialVersionUID = -7057129865819056316L;\n\n    private String refreshToken;\n    private String clientId;\n    private String clientSecret;\n\n    public String getRefreshToken() {\n        return refreshToken;\n    }\n\n    public void setRefreshToken(String refreshToken) {\n        this.refreshToken = refreshToken;\n    }\n\n    public String getClientId() {\n        return clientId;\n    }\n\n    public void setClientId(String clientId) {\n        this.clientId = clientId;\n    }\n\n    public String getClientSecret() {\n        return clientSecret;\n    }\n\n    public void setClientSecret(String clientSecret) {\n        this.clientSecret = clientSecret;\n    }\n}\n"}
2025-05-13 21:03:53 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:03:53 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:03:53 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:03:53 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    public String getRefreshToken() {\n        return refreshToken;\n    }\n"}
2025-05-13 21:03:54 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:03:54 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:03:54 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:03:54 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    public void setRefreshToken(String refreshToken) {\n        this.refreshToken = refreshToken;\n    }\n"}
2025-05-13 21:03:55 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:03:55 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:03:55 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:03:55 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    public String getClientId() {\n        return clientId;\n    }\n"}
2025-05-13 21:03:57 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:03:57 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:03:57 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:03:57 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    public void setClientId(String clientId) {\n        this.clientId = clientId;\n    }\n"}
2025-05-13 21:03:58 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:03:58 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:03:58 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:03:58 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    public String getClientSecret() {\n        return clientSecret;\n    }\n"}
2025-05-13 21:04:00 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:04:00 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:04:00 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:04:00 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    public void setClientSecret(String clientSecret) {\n        this.clientSecret = clientSecret;\n    }\n"}
2025-05-13 21:04:01 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:04:01 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:04:01 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:04:01 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"public class GA4ConnectionInfo implements Serializable {\n\n    private static final long serialVersionUID = -7057129865819056316L;\n\n    private String refreshToken;\n    private String clientId;\n    private String clientSecret;\n\n    public String getRefreshToken() {\n        return refreshToken;\n    }\n\n    public void setRefreshToken(String refreshToken) {\n        this.refreshToken = refreshToken;\n    }\n\n    public String getClientId() {\n        return clientId;\n    }\n\n    public void setClientId(String clientId) {\n        this.clientId = clientId;\n    }\n\n    public String getClientSecret() {\n        return clientSecret;\n    }\n\n    public void setClientSecret(String clientSecret) {\n        this.clientSecret = clientSecret;\n    }\n}\n"}
2025-05-13 21:04:03 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:04:03 [main] INFO  c.l.service.impl.BasicL3AgentService - Processed file: /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/code/dp_dynamic_tasks/ga4-extraction-task/src/main/java/com/gainsight/services/external/ga4/extraction/task/pojo/GA4ConnectionInfo.java with 8 chunks
2025-05-13 21:04:03 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:04:03 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:04:03 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"package com.gainsight.services.external.outofmemory.task;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * @author sthammishetty on 16/03/20\n */\n\n/**\n *  Test class for testing OutOfMemoryIssue.\n *\n *  Register this task with below memory options.\n *  \"memoryOptions\": {\n *       \"max_heap\": {\n *         \"value\": 1,\n *         \"memoryUnit\": \"mb\"\n *       },\n *       \"min_heap\": {\n *         \"value\": 1,\n *         \"memoryUnit\": \"mb\"\n *       }\n *     }\n * */\npublic class OutOfMemoryExternalTask {\n    public static void main(String[] args) {\n        List<Employee> employees = new ArrayList<>();\n        for (int i = 0; i < 100000000; i++) {\n            employees.add(new Employee(\"a\", 1));\n        }\n\n    }\n\n    private static class Employee {\n        private String name;\n        private int age;\n\n        public Employee(String name, int age) {\n            this.name = name;\n            this.age = age;\n        }\n    }\n}\n"}
2025-05-13 21:04:04 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:04:04 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:04:04 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:04:04 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":" *  Test class for testing OutOfMemoryIssue.\n *\n *  Register this task with below memory options.\n *  \"memoryOptions\": {\n *       \"max_heap\": {\n *         \"value\": 1,\n *         \"memoryUnit\": \"mb\"\n *       },\n *       \"min_heap\": {\n *         \"value\": 1,\n *         \"memoryUnit\": \"mb\"\n *       }\n *     }\n"}
2025-05-13 21:04:05 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:04:05 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:04:05 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:04:05 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    public static void main(String[] args) {\n        List<Employee> employees = new ArrayList<>();\n        for (int i = 0; i < 100000000; i++) {\n            employees.add(new Employee(\"a\", 1));\n        }\n\n    }\n"}
2025-05-13 21:04:07 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:04:07 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:04:07 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:04:07 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"        public Employee(String name, int age) {\n            this.name = name;\n            this.age = age;\n        }\n    }\n"}
2025-05-13 21:04:08 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:04:08 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:04:08 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:04:08 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    private static class Employee {\n        private String name;\n        private int age;\n\n        public Employee(String name, int age) {\n            this.name = name;\n            this.age = age;\n        }\n    }\n}\n"}
2025-05-13 21:04:10 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:04:10 [main] INFO  c.l.service.impl.BasicL3AgentService - Processed file: /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/code/dp_dynamic_tasks/out-of-memory-task/src/main/java/com/gainsight/services/external/outofmemory/task/OutOfMemoryExternalTask.java with 5 chunks
2025-05-13 21:04:10 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:04:10 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:04:10 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"package com.gainsight.services.external.hubspot.extraction.task;\n\nimport com.gainsight.integration.connector.hubspot.bean.GSHubSpotEntityEnum;\nimport com.gainsight.integration.connector.hubspot.service.GainsightHubspotChannelFactory;\nimport com.gainsight.integration.connector.hubspot.service.GainsightHubspotFetchService;\nimport com.gainsight.integration.connector.hubspot.service.GainsightHubspotFetchServiceImpl;\nimport com.gainsight.services.dataprocessing.commons.audit.AuditMetadata;\nimport com.gainsight.services.dataprocessing.commons.cryptography.CryptUtil;\nimport com.gainsight.services.dataprocessing.commons.exception.DPSystemException;\nimport com.gainsight.services.dataprocessing.commons.pojo.JsonFileContentType;\nimport com.gainsight.services.dataprocessing.commons.pojo.fields.FieldInfo;\nimport com.gainsight.services.dataprocessing.commons.pojo.hubspotextract.HubspotAccessDetails;\nimport com.gainsight.services.dataprocessing.commons.pojo.hubspotextract.HubspotExtractDetails;\nimport com.gainsight.services.dataprocessing.commons.pojo.workflow.DPWorkflowJobDetailsDTO;\nimport com.gainsight.services.dataprocessing.commons.pojo.workflow.DPWorkflowTaskDetailsDTO;\nimport com.gainsight.services.dataprocessing.commons.utils.DPUtils;\nimport com.gainsight.services.dataprocessing.dataexternals.mda.MDACalloutsService;\nimport com.gainsight.services.dataprocessing.dataprocessor.dagdataprocessor.pojo.ExternalExtractionTaskResult;\nimport com.gainsight.services.dataprocessing.dataprocessor.dagdataprocessor.pojo.TaskResult;\nimport com.gainsight.services.dataprocessing.dataprocessor.dagdataprocessor.utils.TaskExecutorWorkflowUtils;\nimport com.gainsight.services.dataprocessing.external.task.ExternalTaskRequestContext;\nimport com.gainsight.services.dataprocessing.external.task.ExternalTaskUtil;\nimport com.google.common.base.Stopwatch;\nimport com.google.common.collect.Lists;\nimport com.google.gson.JsonArray;\nimport com.google.gson.JsonElement;\nimport com.google.gson.JsonObject;\nimport com.google.gson.JsonParser;\nimport org.apache.commons.io.FileUtils;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.codehaus.jackson.JsonParseException;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.util.ObjectUtils;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.nio.charset.Charset;\nimport java.nio.charset.StandardCharsets;\nimport java.util.*;\nimport java.util.concurrent.TimeUnit;\nimport java.util.stream.Collectors;\n\nimport static com.gainsight.services.dataprocessing.commons.audit.AuditMetadata.newInstance;\nimport static com.gainsight.services.dataprocessing.commons.constants.Constants.WorkflowConstants.HUBSPOT_EXTRACT_DETAILS_KEY;\nimport static com.gainsight.services.dataprocessing.commons.exception.ValidationCode.GENERIC_SYSTEM_ERROR;\nimport static com.gainsight.services.dataprocessing.commons.system.Precondition.isNotNull;\nimport static com.gainsight.services.dataprocessing.commons.utils.DPUtils.convertJsonToObject;\nimport static com.gainsight.services.dataprocessing.commons.utils.DPUtils.msg;\n\n/**\n * user : Aditya Agrawal\n * date : 03/28/22\n **/\npublic class HubspotExtractTask {\n    private static final Logger LOGGER = LoggerFactory.getLogger(HubspotExtractTask.class);\n\n    private static final String PROPERTIES = \"properties\";\n    private static final String CLIENT_ID = \"clientId\";\n    private static final String CLIENT_SECRET = \"clientSecret\";\n    private static final String REFRESH_TOKEN = \"refreshToken\";\n    private static final String JSON_EXTENSION = \".json\";\n    private static final String HUBSPOT_API_VERSION = \"hubspotApiVersion\";\n    private static final String HUBSPOT_API_VERSION_LEGACY = \"legacy\";\n    private static final String HUBSPOT_API_EXTRACT = \"hubspotExtract\";\n\n\n    private static final int FILE_SIZE_THRESHOLD_IN_BYTES = 209715200;\n    private static final String CONNECTOR_TYPE = \"hubspot\";\n    private static final String DATA = \"data\";\n    private static final String VALUE = \"value\";\n    private static final String CARRIAGE_RETURN = \"\\n\";\n\n\n    private HubspotExtractTask() {\n    }\n\n    /**\n     * External task for extracting data from Hubspot.\n     */\n\n    public static void main(String[] args) {\n        executeTask(ExternalTaskUtil.getExternalTaskRequestContext());\n    }\n\n    public static void executeTask(ExternalTaskRequestContext externalTaskRequestContext) {\n        Stopwatch stopwatch = Stopwatch.createStarted();\n        LOGGER.debug(\"Request to hubspot fetch started !!\");\n        String jobId = externalTaskRequestContext.getJobId();\n        String taskId = externalTaskRequestContext.getTaskId();\n        List<File> uncompressedInputFiles = Lists.newArrayList();\n        try {\n            Map<String, String> metaData = externalTaskRequestContext.getMetaData();\n            DPWorkflowJobDetailsDTO workflowJobDetails = externalTaskRequestContext.getWorkflowJobDetails();\n            AuditMetadata auditMetadata = newInstance(workflowJobDetails.getTenantId(), workflowJobDetails.getJobId(), workflowJobDetails.getExternalId(), taskId, externalTaskRequestContext.getTaskName());\n            HubspotExtractDetails fetchTaskDetails = convertJsonToObject(metaData.get(HUBSPOT_EXTRACT_DETAILS_KEY), HubspotExtractDetails.class);\n            extractDataFromHubspot(externalTaskRequestContext, workflowJobDetails, fetchTaskDetails,\n                    auditMetadata, uncompressedInputFiles);\n\n            TaskResult taskResult = new TaskResult(fetchTaskDetails.getProjectionClause(), null);\n\n            ExternalExtractionTaskResult externalExtractionTaskResult = new ExternalExtractionTaskResult.ExternalExtractionTaskResultBuilder()\n                    .setTaskResult(taskResult)\n                    .setExtractedFiles(uncompressedInputFiles.stream().map(File::getAbsolutePath).collect(Collectors.toList()))\n                    .setJsonData(true)\n                    .setJsonFileContentType(JsonFileContentType.LINE_SEPARATED_OBJECTS)\n                    .setPushExtractedDataToS3(true)\n                    .setExcludedStrings(StringUtils.EMPTY)\n                    .build();\n            ExternalTaskUtil.saveExternalTaskResult(workflowJobDetails.getTenantId(), jobId, taskId, externalExtractionTaskResult);\n        } catch (Exception e) {\n            LOGGER.error(e.getMessage(), e);\n            throw new DPSystemException(msg(\"Error while fetching data from Hubspot\"), e);\n        } finally {\n            LOGGER.debug(\"Request to hubspot fetch completed in {} secs\", stopwatch.elapsed(TimeUnit.SECONDS));\n        }\n    }\n\n    private static void extractDataFromHubspot(ExternalTaskRequestContext externalTaskRequestContext, DPWorkflowJobDetailsDTO workflowJobDetails,\n                                               HubspotExtractDetails fetchTaskDetails, AuditMetadata auditMetadata,\n                                               List<File> uncompressedInputFiles) throws Exception {\n        MDACalloutsService mdaCalloutsService = MDACalloutsService.createOrGetInstance(workflowJobDetails.getSystemToken(), TaskExecutorWorkflowUtils.getConfigSourceUrl(workflowJobDetails), auditMetadata);\n        JsonObject jsonObject = mdaCalloutsService.getConnectionDetailsFromConnectors(fetchTaskDetails.getConnectorId(), CONNECTOR_TYPE);\n        isNotNull(jsonObject, GENERIC_SYSTEM_ERROR, \"No connection details found for this connection\");\n        HubspotAccessDetails accessDetailsFromDB = extractAccessDetails(jsonObject);\n        uncompressedInputFiles.addAll(readData(workflowJobDetails, externalTaskRequestContext, accessDetailsFromDB, fetchTaskDetails));\n    }\n\n    private static HubspotAccessDetails extractAccessDetails(JsonObject jsonObject) {\n        JsonObject decryptedObject = new JsonParser().parse(CryptUtil.decrypt(jsonObject.get(DATA).getAsJsonObject().get(VALUE).getAsString())).getAsJsonObject();\n        HubspotAccessDetails accessDetails = null;\n        if (!decryptedObject.isJsonNull()) {\n            accessDetails = new HubspotAccessDetails();\n            accessDetails.setClientId(decryptedObject.get(PROPERTIES).getAsJsonObject().get(CLIENT_ID).getAsString());\n            accessDetails.setClientSecret(decryptedObject.get(PROPERTIES).getAsJsonObject().get(CLIENT_SECRET).getAsString());\n            accessDetails.setRefreshToken(decryptedObject.get(PROPERTIES).getAsJsonObject().get(REFRESH_TOKEN).getAsString());\n        }\n        return accessDetails;\n    }\n\n    private static InputStream getDataFromHubspot(HubspotAccessDetails accessDetails, long offset, HubspotExtractDetails fetchTaskDetails) {\n        List<String> projectionList = fetchTaskDetails.getProjectionClause().stream()\n                .filter(fieldInfo -> StringUtils.isNotEmpty(fieldInfo.getName()))\n                .map(FieldInfo::getName)\n                .collect(Collectors.toList());\n        return getDataFromHubspot(accessDetails, offset, fetchTaskDetails, projectionList);\n    }\n\n    private static InputStream getDataFromHubspot(HubspotAccessDetails accessDetails, long offset, HubspotExtractDetails fetchTaskDetails, List<String> projectionList) {\n        GainsightHubspotFetchService fetchService = new GainsightHubspotFetchServiceImpl();\n        try {\n            return fetchService.getPaginatedEntityData(fetchTaskDetails.getExternalEntityName(), projectionList,\n                    accessDetails.getClientId(), accessDetails.getClientSecret(), accessDetails.getRefreshToken(),\n                    accessDetails.getAccessToken(), offset);\n        } catch (Exception ex) {\n            if (StringUtils.isNotEmpty(ex.getMessage()) && ex.getMessage().equals(\"Hubspot access token expired\")) {\n                LOGGER.error(\"Regenerating Hubspot access token...\");\n                GainsightHubspotChannelFactory gainsightHubspotChannelFactory = new GainsightHubspotChannelFactory();\n                try {\n                    accessDetails.setAccessToken(gainsightHubspotChannelFactory.getAccessToken(accessDetails.getClientId(), accessDetails.getClientSecret(), accessDetails.getRefreshToken()));\n                    return fetchService.getPaginatedEntityData(fetchTaskDetails.getExternalEntityName(), projectionList,\n                            accessDetails.getClientId(), accessDetails.getClientSecret(), accessDetails.getRefreshToken(),\n                            accessDetails.getAccessToken(), offset);\n                } catch (Exception e) {\n                    LOGGER.error(\"Error while Regenerating Hubspot access token. \", e);\n                    return null;\n                }\n            }\n            return null;\n        }\n    }\n\n    private static InputStream getDataFromHubspotLatestApi(HubspotAccessDetails accessDetails, String nextPageUrl, HubspotExtractDetails fetchTaskDetails) {\n        GainsightHubspotFetchService fetchService = new GainsightHubspotFetchServiceImpl();\n        List<String> projectionList = fetchTaskDetails.getProjectionClause().stream()\n                .filter(fieldInfo -> StringUtils.isNotEmpty(fieldInfo.getName()))\n                .map(FieldInfo::getName)\n                .collect(Collectors.toList());\n        try {\n            return fetchService.getPaginatedEntityDataLatest(fetchTaskDetails.getExternalEntityName(), projectionList,\n                    accessDetails.getClientId(), accessDetails.getClientSecret(), accessDetails.getRefreshToken(),\n                    accessDetails.getAccessToken(), nextPageUrl);\n        } catch (Exception ex) {\n            if (StringUtils.isNotEmpty(ex.getMessage()) && ex.getMessage().equals(\"Hubspot access token expired\")) {\n                LOGGER.error(\"Regenerating Hubspot access token...\");\n                GainsightHubspotChannelFactory gainsightHubspotChannelFactory = new GainsightHubspotChannelFactory();\n                try {\n                    accessDetails.setAccessToken(gainsightHubspotChannelFactory.getAccessToken(accessDetails.getClientId(), accessDetails.getClientSecret(), accessDetails.getRefreshToken()));\n                    return fetchService.getPaginatedEntityDataLatest(fetchTaskDetails.getExternalEntityName(), projectionList,\n                            accessDetails.getClientId(), accessDetails.getClientSecret(), accessDetails.getRefreshToken(),\n                            accessDetails.getAccessToken(), nextPageUrl);\n                } catch (Exception e) {\n                    LOGGER.error(\"Error while Regenerating Hubspot access token. \", e);\n                    return null;\n                }\n            }\n            return null;\n        }\n    }\n\n    private static Deque<File> readData(DPWorkflowJobDetailsDTO workflowJobDetails, ExternalTaskRequestContext externalTaskRequestContext, HubspotAccessDetails accessDetails, HubspotExtractDetails fetchTaskDetails) {\n        InputStream stream = null;\n        Deque<File> fileStack = new ArrayDeque<>();\n        try {\n            boolean shouldContinue;\n            String hasMoreKeyword = GSHubSpotEntityEnum.getHasMoreKeyWord(GSHubSpotEntityEnum.getInstance(fetchTaskDetails.getExternalEntityName()));\n            String offsetKeyword = GSHubSpotEntityEnum.getRetrievOffsetKeyWord(GSHubSpotEntityEnum.getInstance(fetchTaskDetails.getExternalEntityName()));\n            String pluralName = GSHubSpotEntityEnum.getPluralName(GSHubSpotEntityEnum.getInstance(fetchTaskDetails.getExternalEntityName()));\n            GainsightHubspotChannelFactory gainsightHubspotChannelFactory = new GainsightHubspotChannelFactory();\n            accessDetails.setAccessToken(gainsightHubspotChannelFactory.getAccessToken(accessDetails.getClientId(), accessDetails.getClientSecret(), accessDetails.getRefreshToken()));\n            long offset = Long.MIN_VALUE;\n            String nextPageUrl = null;\n            int counter = 0;\n            Optional<DPWorkflowTaskDetailsDTO> taskDetailsDTO = workflowJobDetails.getWorkflowDetails().getTasks().stream().\n                    filter(task -> task.getMetaData() != null && task.getMetaData().get(\"taskName\").toString().equalsIgnoreCase(HUBSPOT_API_EXTRACT)).findFirst();\n            String apiVersion = HUBSPOT_API_VERSION_LEGACY;\n            if (!ObjectUtils.isEmpty(taskDetailsDTO.get().getMetaData().get(HUBSPOT_API_VERSION))) {\n                apiVersion = taskDetailsDTO.get().getMetaData().get(HUBSPOT_API_VERSION).toString();\n            }\n            do {\n                LOGGER.info(\"Paginated api running for offset : {}, pagination api counter: {}, nextpageurl :{} , apiVersion : {} \", offset, counter++, nextPageUrl, apiVersion);\n                if (apiVersion.equalsIgnoreCase(HUBSPOT_API_VERSION_LEGACY)) {\n                    stream = getDataFromHubspot(accessDetails, offset, fetchTaskDetails);\n                    isNotNull(stream, GENERIC_SYSTEM_ERROR, \"No data fetched from external source\");\n                    File tempFile = getLocalFile(workflowJobDetails, externalTaskRequestContext, fileStack);\n                    offset = readDataAndStoreInFile(stream, hasMoreKeyword, offsetKeyword, pluralName, tempFile, fetchTaskDetails.getExternalEntityName());\n                } else {// New api Version V3\n                    stream = getDataFromHubspotLatestApi(accessDetails, nextPageUrl, fetchTaskDetails);\n                    isNotNull(stream, GENERIC_SYSTEM_ERROR, \"No data fetched from external source\");\n                    File tempFile = getLocalFile(workflowJobDetails, externalTaskRequestContext, fileStack);\n                    nextPageUrl = readDataAndStoreInFileLatestApi(stream, pluralName, tempFile, fetchTaskDetails.getExternalEntityName());\n                }\n                shouldContinue = offset != Long.MIN_VALUE || (StringUtils.isNotEmpty(nextPageUrl));\n            } while (shouldContinue && !Thread.currentThread().isInterrupted());\n        } catch (IOException ioEx) {\n            LOGGER.error(\"Failed during fetching data from hubspot.\", ioEx);\n        } catch (Exception e) {\n            LOGGER.error(\"Failed during fetching data from hubspot.\", e);\n        } finally {\n            IOUtils.closeQuietly(stream);\n        }\n        return fileStack;\n    }\n\n    private static long readDataAndStoreInFile(InputStream inputStream, String hasMoreKeyword, String offsetKeyword, String pluralName, File tempFile, String entityName) throws IOException {\n        long offset = Long.MIN_VALUE;\n        JsonObject jsonObject = null;\n        jsonObject = iterativelyPullDataAndStoreInLocal(inputStream, pluralName, tempFile, entityName, jsonObject);\n        offset = shouldContinue(hasMoreKeyword, offsetKeyword, offset, jsonObject);\n        return offset;\n    }\n\n    private static String readDataAndStoreInFileLatestApi(InputStream inputStream, String pluralName, File tempFile, String entityName) throws IOException {\n        String url = null;\n        JsonObject jsonObject = null;\n        jsonObject = iterativelyPullDataAndStoreInLocal(inputStream, \"results\", tempFile, entityName, jsonObject);\n        url = isAfter(url, jsonObject);\n        return url;\n    }\n\n    private static long shouldContinue(String hasMoreKeyword, String offsetKeyword, long offset, JsonObject jsonObject) {\n        if (jsonObject != null && jsonObject.get(hasMoreKeyword) != null && jsonObject.get(hasMoreKeyword).getAsBoolean()) {\n            offset = jsonObject.get(offsetKeyword).getAsLong();\n        }\n        return offset;\n    }\n\n    private static String isAfter(String url, JsonObject jsonObject) {\n        if (jsonObject != null && jsonObject.get(\"paging\") != null) {\n            url = jsonObject.getAsJsonObject(\"paging\").getAsJsonObject(\"next\").get(\"link\").getAsString();\n        }\n        return url;\n    }\n\n    private static JsonObject iterativelyPullDataAndStoreInLocal(InputStream inputStream, String pluralName, File tempFile, String entityName, JsonObject jsonObject) throws IOException {\n        JsonArray iterator = null;\n        try {\n            if (entityName.equalsIgnoreCase(GSHubSpotEntityEnum.labelName(GSHubSpotEntityEnum.OWNER)) && !pluralName.equalsIgnoreCase(\"results\")) {\n                iterator = new JsonParser().parse(IOUtils.toString(inputStream, Charset.defaultCharset())).getAsJsonArray();\n            } else {\n                jsonObject = new JsonParser().parse(IOUtils.toString(inputStream, Charset.defaultCharset())).getAsJsonObject();\n                iterator = jsonObject.getAsJsonArray(pluralName);\n            }\n        } catch (JsonParseException e) {\n            LOGGER.error(\"Exception occurred while parsing hubspot response to JSON object : \", e);\n            throw new DPSystemException(\"Exception occurred while parsing hubspot response to JSON object : \", e);\n        }\n        if (iterator != null)\n            iterator.iterator().forEachRemaining((JsonElement jsonElement) -> {\n                try {\n                    FileUtils.writeStringToFile(tempFile, jsonElement.getAsJsonObject().toString() + CARRIAGE_RETURN, StandardCharsets.UTF_8, true);\n                } catch (IOException e) {\n                    LOGGER.error(\"Exception occurred while parsing hubspot JSON response to temp file : \", e);\n                    throw new DPSystemException(\"Exception occurred while parsing hubspot JSON response to temp file : \", e);\n                }\n            });\n        return jsonObject;\n    }\n\n    private static File getLocalFile(DPWorkflowJobDetailsDTO workflowJobDetails, ExternalTaskRequestContext externalTaskRequestContext, Deque<File> fileStack) throws IOException {\n        if (fileStack.isEmpty() || fileStack.peek().length() >= FILE_SIZE_THRESHOLD_IN_BYTES) {\n            fileStack.push(File.createTempFile(DPUtils.getTempFilePath(workflowJobDetails.getTenantId(), workflowJobDetails.getJobId(), externalTaskRequestContext.getTaskId(), UUID.randomUUID().toString()), JSON_EXTENSION));\n        }\n        return fileStack.peek();\n    }\n}\n"}
2025-05-13 21:04:11 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:04:11 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:04:11 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:04:11 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    private HubspotExtractTask() {\n    }\n"}
2025-05-13 21:04:13 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:04:13 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:04:13 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:04:13 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    public static void main(String[] args) {\n        executeTask(ExternalTaskUtil.getExternalTaskRequestContext());\n    }\n"}
2025-05-13 21:04:14 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:04:14 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:04:14 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:04:14 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    public static void executeTask(ExternalTaskRequestContext externalTaskRequestContext) {\n        Stopwatch stopwatch = Stopwatch.createStarted();\n        LOGGER.debug(\"Request to hubspot fetch started !!\");\n        String jobId = externalTaskRequestContext.getJobId();\n        String taskId = externalTaskRequestContext.getTaskId();\n        List<File> uncompressedInputFiles = Lists.newArrayList();\n        try {\n            Map<String, String> metaData = externalTaskRequestContext.getMetaData();\n            DPWorkflowJobDetailsDTO workflowJobDetails = externalTaskRequestContext.getWorkflowJobDetails();\n            AuditMetadata auditMetadata = newInstance(workflowJobDetails.getTenantId(), workflowJobDetails.getJobId(), workflowJobDetails.getExternalId(), taskId, externalTaskRequestContext.getTaskName());\n            HubspotExtractDetails fetchTaskDetails = convertJsonToObject(metaData.get(HUBSPOT_EXTRACT_DETAILS_KEY), HubspotExtractDetails.class);\n            extractDataFromHubspot(externalTaskRequestContext, workflowJobDetails, fetchTaskDetails,\n                    auditMetadata, uncompressedInputFiles);\n\n            TaskResult taskResult = new TaskResult(fetchTaskDetails.getProjectionClause(), null);\n\n            ExternalExtractionTaskResult externalExtractionTaskResult = new ExternalExtractionTaskResult.ExternalExtractionTaskResultBuilder()\n                    .setTaskResult(taskResult)\n                    .setExtractedFiles(uncompressedInputFiles.stream().map(File::getAbsolutePath).collect(Collectors.toList()))\n                    .setJsonData(true)\n                    .setJsonFileContentType(JsonFileContentType.LINE_SEPARATED_OBJECTS)\n                    .setPushExtractedDataToS3(true)\n                    .setExcludedStrings(StringUtils.EMPTY)\n                    .build();\n            ExternalTaskUtil.saveExternalTaskResult(workflowJobDetails.getTenantId(), jobId, taskId, externalExtractionTaskResult);\n        } catch (Exception e) {\n            LOGGER.error(e.getMessage(), e);\n            throw new DPSystemException(msg(\"Error while fetching data from Hubspot\"), e);\n        } finally {\n            LOGGER.debug(\"Request to hubspot fetch completed in {} secs\", stopwatch.elapsed(TimeUnit.SECONDS));\n        }\n    }\n"}
2025-05-13 21:04:16 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:04:16 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:04:16 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:04:16 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    private static HubspotAccessDetails extractAccessDetails(JsonObject jsonObject) {\n        JsonObject decryptedObject = new JsonParser().parse(CryptUtil.decrypt(jsonObject.get(DATA).getAsJsonObject().get(VALUE).getAsString())).getAsJsonObject();\n        HubspotAccessDetails accessDetails = null;\n        if (!decryptedObject.isJsonNull()) {\n            accessDetails = new HubspotAccessDetails();\n            accessDetails.setClientId(decryptedObject.get(PROPERTIES).getAsJsonObject().get(CLIENT_ID).getAsString());\n            accessDetails.setClientSecret(decryptedObject.get(PROPERTIES).getAsJsonObject().get(CLIENT_SECRET).getAsString());\n            accessDetails.setRefreshToken(decryptedObject.get(PROPERTIES).getAsJsonObject().get(REFRESH_TOKEN).getAsString());\n        }\n        return accessDetails;\n    }\n"}
2025-05-13 21:04:17 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:04:17 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:04:17 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:04:17 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    private static InputStream getDataFromHubspot(HubspotAccessDetails accessDetails, long offset, HubspotExtractDetails fetchTaskDetails) {\n        List<String> projectionList = fetchTaskDetails.getProjectionClause().stream()\n                .filter(fieldInfo -> StringUtils.isNotEmpty(fieldInfo.getName()))\n                .map(FieldInfo::getName)\n                .collect(Collectors.toList());\n        return getDataFromHubspot(accessDetails, offset, fetchTaskDetails, projectionList);\n    }\n"}
2025-05-13 21:04:18 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:04:18 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:04:18 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:04:18 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    private static InputStream getDataFromHubspot(HubspotAccessDetails accessDetails, long offset, HubspotExtractDetails fetchTaskDetails, List<String> projectionList) {\n        GainsightHubspotFetchService fetchService = new GainsightHubspotFetchServiceImpl();\n        try {\n            return fetchService.getPaginatedEntityData(fetchTaskDetails.getExternalEntityName(), projectionList,\n                    accessDetails.getClientId(), accessDetails.getClientSecret(), accessDetails.getRefreshToken(),\n                    accessDetails.getAccessToken(), offset);\n        } catch (Exception ex) {\n            if (StringUtils.isNotEmpty(ex.getMessage()) && ex.getMessage().equals(\"Hubspot access token expired\")) {\n                LOGGER.error(\"Regenerating Hubspot access token...\");\n                GainsightHubspotChannelFactory gainsightHubspotChannelFactory = new GainsightHubspotChannelFactory();\n                try {\n                    accessDetails.setAccessToken(gainsightHubspotChannelFactory.getAccessToken(accessDetails.getClientId(), accessDetails.getClientSecret(), accessDetails.getRefreshToken()));\n                    return fetchService.getPaginatedEntityData(fetchTaskDetails.getExternalEntityName(), projectionList,\n                            accessDetails.getClientId(), accessDetails.getClientSecret(), accessDetails.getRefreshToken(),\n                            accessDetails.getAccessToken(), offset);\n                } catch (Exception e) {\n                    LOGGER.error(\"Error while Regenerating Hubspot access token. \", e);\n                    return null;\n                }\n            }\n            return null;\n        }\n    }\n"}
2025-05-13 21:04:20 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:04:20 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:04:20 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:04:20 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    private static InputStream getDataFromHubspotLatestApi(HubspotAccessDetails accessDetails, String nextPageUrl, HubspotExtractDetails fetchTaskDetails) {\n        GainsightHubspotFetchService fetchService = new GainsightHubspotFetchServiceImpl();\n        List<String> projectionList = fetchTaskDetails.getProjectionClause().stream()\n                .filter(fieldInfo -> StringUtils.isNotEmpty(fieldInfo.getName()))\n                .map(FieldInfo::getName)\n                .collect(Collectors.toList());\n        try {\n            return fetchService.getPaginatedEntityDataLatest(fetchTaskDetails.getExternalEntityName(), projectionList,\n                    accessDetails.getClientId(), accessDetails.getClientSecret(), accessDetails.getRefreshToken(),\n                    accessDetails.getAccessToken(), nextPageUrl);\n        } catch (Exception ex) {\n            if (StringUtils.isNotEmpty(ex.getMessage()) && ex.getMessage().equals(\"Hubspot access token expired\")) {\n                LOGGER.error(\"Regenerating Hubspot access token...\");\n                GainsightHubspotChannelFactory gainsightHubspotChannelFactory = new GainsightHubspotChannelFactory();\n                try {\n                    accessDetails.setAccessToken(gainsightHubspotChannelFactory.getAccessToken(accessDetails.getClientId(), accessDetails.getClientSecret(), accessDetails.getRefreshToken()));\n                    return fetchService.getPaginatedEntityDataLatest(fetchTaskDetails.getExternalEntityName(), projectionList,\n                            accessDetails.getClientId(), accessDetails.getClientSecret(), accessDetails.getRefreshToken(),\n                            accessDetails.getAccessToken(), nextPageUrl);\n                } catch (Exception e) {\n                    LOGGER.error(\"Error while Regenerating Hubspot access token. \", e);\n                    return null;\n                }\n            }\n            return null;\n        }\n    }\n"}
2025-05-13 21:04:21 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:04:21 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:04:21 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:04:21 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    private static Deque<File> readData(DPWorkflowJobDetailsDTO workflowJobDetails, ExternalTaskRequestContext externalTaskRequestContext, HubspotAccessDetails accessDetails, HubspotExtractDetails fetchTaskDetails) {\n        InputStream stream = null;\n        Deque<File> fileStack = new ArrayDeque<>();\n        try {\n            boolean shouldContinue;\n            String hasMoreKeyword = GSHubSpotEntityEnum.getHasMoreKeyWord(GSHubSpotEntityEnum.getInstance(fetchTaskDetails.getExternalEntityName()));\n            String offsetKeyword = GSHubSpotEntityEnum.getRetrievOffsetKeyWord(GSHubSpotEntityEnum.getInstance(fetchTaskDetails.getExternalEntityName()));\n            String pluralName = GSHubSpotEntityEnum.getPluralName(GSHubSpotEntityEnum.getInstance(fetchTaskDetails.getExternalEntityName()));\n            GainsightHubspotChannelFactory gainsightHubspotChannelFactory = new GainsightHubspotChannelFactory();\n            accessDetails.setAccessToken(gainsightHubspotChannelFactory.getAccessToken(accessDetails.getClientId(), accessDetails.getClientSecret(), accessDetails.getRefreshToken()));\n            long offset = Long.MIN_VALUE;\n            String nextPageUrl = null;\n            int counter = 0;\n            Optional<DPWorkflowTaskDetailsDTO> taskDetailsDTO = workflowJobDetails.getWorkflowDetails().getTasks().stream().\n                    filter(task -> task.getMetaData() != null && task.getMetaData().get(\"taskName\").toString().equalsIgnoreCase(HUBSPOT_API_EXTRACT)).findFirst();\n            String apiVersion = HUBSPOT_API_VERSION_LEGACY;\n            if (!ObjectUtils.isEmpty(taskDetailsDTO.get().getMetaData().get(HUBSPOT_API_VERSION))) {\n                apiVersion = taskDetailsDTO.get().getMetaData().get(HUBSPOT_API_VERSION).toString();\n            }\n            do {\n                LOGGER.info(\"Paginated api running for offset : {}, pagination api counter: {}, nextpageurl :{} , apiVersion : {} \", offset, counter++, nextPageUrl, apiVersion);\n                if (apiVersion.equalsIgnoreCase(HUBSPOT_API_VERSION_LEGACY)) {\n                    stream = getDataFromHubspot(accessDetails, offset, fetchTaskDetails);\n                    isNotNull(stream, GENERIC_SYSTEM_ERROR, \"No data fetched from external source\");\n                    File tempFile = getLocalFile(workflowJobDetails, externalTaskRequestContext, fileStack);\n                    offset = readDataAndStoreInFile(stream, hasMoreKeyword, offsetKeyword, pluralName, tempFile, fetchTaskDetails.getExternalEntityName());\n                } else {// New api Version V3\n                    stream = getDataFromHubspotLatestApi(accessDetails, nextPageUrl, fetchTaskDetails);\n                    isNotNull(stream, GENERIC_SYSTEM_ERROR, \"No data fetched from external source\");\n                    File tempFile = getLocalFile(workflowJobDetails, externalTaskRequestContext, fileStack);\n                    nextPageUrl = readDataAndStoreInFileLatestApi(stream, pluralName, tempFile, fetchTaskDetails.getExternalEntityName());\n                }\n                shouldContinue = offset != Long.MIN_VALUE || (StringUtils.isNotEmpty(nextPageUrl));\n            } while (shouldContinue && !Thread.currentThread().isInterrupted());\n        } catch (IOException ioEx) {\n            LOGGER.error(\"Failed during fetching data from hubspot.\", ioEx);\n        } catch (Exception e) {\n            LOGGER.error(\"Failed during fetching data from hubspot.\", e);\n        } finally {\n            IOUtils.closeQuietly(stream);\n        }\n        return fileStack;\n    }\n"}
2025-05-13 21:04:23 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:04:23 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:04:23 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:04:23 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    private static long readDataAndStoreInFile(InputStream inputStream, String hasMoreKeyword, String offsetKeyword, String pluralName, File tempFile, String entityName) throws IOException {\n        long offset = Long.MIN_VALUE;\n        JsonObject jsonObject = null;\n        jsonObject = iterativelyPullDataAndStoreInLocal(inputStream, pluralName, tempFile, entityName, jsonObject);\n        offset = shouldContinue(hasMoreKeyword, offsetKeyword, offset, jsonObject);\n        return offset;\n    }\n"}
2025-05-13 21:04:24 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:04:24 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:04:24 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:04:24 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    private static String readDataAndStoreInFileLatestApi(InputStream inputStream, String pluralName, File tempFile, String entityName) throws IOException {\n        String url = null;\n        JsonObject jsonObject = null;\n        jsonObject = iterativelyPullDataAndStoreInLocal(inputStream, \"results\", tempFile, entityName, jsonObject);\n        url = isAfter(url, jsonObject);\n        return url;\n    }\n"}
2025-05-13 21:04:25 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:04:25 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:04:25 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:04:25 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    private static long shouldContinue(String hasMoreKeyword, String offsetKeyword, long offset, JsonObject jsonObject) {\n        if (jsonObject != null && jsonObject.get(hasMoreKeyword) != null && jsonObject.get(hasMoreKeyword).getAsBoolean()) {\n            offset = jsonObject.get(offsetKeyword).getAsLong();\n        }\n        return offset;\n    }\n"}
2025-05-13 21:04:27 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:04:27 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:04:27 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:04:27 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    private static String isAfter(String url, JsonObject jsonObject) {\n        if (jsonObject != null && jsonObject.get(\"paging\") != null) {\n            url = jsonObject.getAsJsonObject(\"paging\").getAsJsonObject(\"next\").get(\"link\").getAsString();\n        }\n        return url;\n    }\n"}
2025-05-13 21:04:28 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:04:28 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:04:28 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:04:28 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    private static JsonObject iterativelyPullDataAndStoreInLocal(InputStream inputStream, String pluralName, File tempFile, String entityName, JsonObject jsonObject) throws IOException {\n        JsonArray iterator = null;\n        try {\n            if (entityName.equalsIgnoreCase(GSHubSpotEntityEnum.labelName(GSHubSpotEntityEnum.OWNER)) && !pluralName.equalsIgnoreCase(\"results\")) {\n                iterator = new JsonParser().parse(IOUtils.toString(inputStream, Charset.defaultCharset())).getAsJsonArray();\n            } else {\n                jsonObject = new JsonParser().parse(IOUtils.toString(inputStream, Charset.defaultCharset())).getAsJsonObject();\n                iterator = jsonObject.getAsJsonArray(pluralName);\n            }\n        } catch (JsonParseException e) {\n            LOGGER.error(\"Exception occurred while parsing hubspot response to JSON object : \", e);\n            throw new DPSystemException(\"Exception occurred while parsing hubspot response to JSON object : \", e);\n        }\n        if (iterator != null)\n            iterator.iterator().forEachRemaining((JsonElement jsonElement) -> {\n                try {\n                    FileUtils.writeStringToFile(tempFile, jsonElement.getAsJsonObject().toString() + CARRIAGE_RETURN, StandardCharsets.UTF_8, true);\n                } catch (IOException e) {\n                    LOGGER.error(\"Exception occurred while parsing hubspot JSON response to temp file : \", e);\n                    throw new DPSystemException(\"Exception occurred while parsing hubspot JSON response to temp file : \", e);\n                }\n            });\n        return jsonObject;\n    }\n"}
2025-05-13 21:04:29 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:04:29 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:04:29 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:04:29 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    private static File getLocalFile(DPWorkflowJobDetailsDTO workflowJobDetails, ExternalTaskRequestContext externalTaskRequestContext, Deque<File> fileStack) throws IOException {\n        if (fileStack.isEmpty() || fileStack.peek().length() >= FILE_SIZE_THRESHOLD_IN_BYTES) {\n            fileStack.push(File.createTempFile(DPUtils.getTempFilePath(workflowJobDetails.getTenantId(), workflowJobDetails.getJobId(), externalTaskRequestContext.getTaskId(), UUID.randomUUID().toString()), JSON_EXTENSION));\n        }\n        return fileStack.peek();\n    }\n"}
2025-05-13 21:04:31 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:04:31 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:04:31 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:04:31 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"public class HubspotExtractTask {\n    private static final Logger LOGGER = LoggerFactory.getLogger(HubspotExtractTask.class);\n\n    private static final String PROPERTIES = \"properties\";\n    private static final String CLIENT_ID = \"clientId\";\n    private static final String CLIENT_SECRET = \"clientSecret\";\n    private static final String REFRESH_TOKEN = \"refreshToken\";\n    private static final String JSON_EXTENSION = \".json\";\n    private static final String HUBSPOT_API_VERSION = \"hubspotApiVersion\";\n    private static final String HUBSPOT_API_VERSION_LEGACY = \"legacy\";\n    private static final String HUBSPOT_API_EXTRACT = \"hubspotExtract\";\n\n\n    private static final int FILE_SIZE_THRESHOLD_IN_BYTES = 209715200;\n    private static final String CONNECTOR_TYPE = \"hubspot\";\n    private static final String DATA = \"data\";\n    private static final String VALUE = \"value\";\n    private static final String CARRIAGE_RETURN = \"\\n\";\n\n\n    private HubspotExtractTask() {\n    }\n\n    /**\n     * External task for extracting data from Hubspot.\n     */\n\n    public static void main(String[] args) {\n        executeTask(ExternalTaskUtil.getExternalTaskRequestContext());\n    }\n\n    public static void executeTask(ExternalTaskRequestContext externalTaskRequestContext) {\n        Stopwatch stopwatch = Stopwatch.createStarted();\n        LOGGER.debug(\"Request to hubspot fetch started !!\");\n        String jobId = externalTaskRequestContext.getJobId();\n        String taskId = externalTaskRequestContext.getTaskId();\n        List<File> uncompressedInputFiles = Lists.newArrayList();\n        try {\n            Map<String, String> metaData = externalTaskRequestContext.getMetaData();\n            DPWorkflowJobDetailsDTO workflowJobDetails = externalTaskRequestContext.getWorkflowJobDetails();\n            AuditMetadata auditMetadata = newInstance(workflowJobDetails.getTenantId(), workflowJobDetails.getJobId(), workflowJobDetails.getExternalId(), taskId, externalTaskRequestContext.getTaskName());\n            HubspotExtractDetails fetchTaskDetails = convertJsonToObject(metaData.get(HUBSPOT_EXTRACT_DETAILS_KEY), HubspotExtractDetails.class);\n            extractDataFromHubspot(externalTaskRequestContext, workflowJobDetails, fetchTaskDetails,\n                    auditMetadata, uncompressedInputFiles);\n\n            TaskResult taskResult = new TaskResult(fetchTaskDetails.getProjectionClause(), null);\n\n            ExternalExtractionTaskResult externalExtractionTaskResult = new ExternalExtractionTaskResult.ExternalExtractionTaskResultBuilder()\n                    .setTaskResult(taskResult)\n                    .setExtractedFiles(uncompressedInputFiles.stream().map(File::getAbsolutePath).collect(Collectors.toList()))\n                    .setJsonData(true)\n                    .setJsonFileContentType(JsonFileContentType.LINE_SEPARATED_OBJECTS)\n                    .setPushExtractedDataToS3(true)\n                    .setExcludedStrings(StringUtils.EMPTY)\n                    .build();\n            ExternalTaskUtil.saveExternalTaskResult(workflowJobDetails.getTenantId(), jobId, taskId, externalExtractionTaskResult);\n        } catch (Exception e) {\n            LOGGER.error(e.getMessage(), e);\n            throw new DPSystemException(msg(\"Error while fetching data from Hubspot\"), e);\n        } finally {\n            LOGGER.debug(\"Request to hubspot fetch completed in {} secs\", stopwatch.elapsed(TimeUnit.SECONDS));\n        }\n    }\n\n    private static void extractDataFromHubspot(ExternalTaskRequestContext externalTaskRequestContext, DPWorkflowJobDetailsDTO workflowJobDetails,\n                                               HubspotExtractDetails fetchTaskDetails, AuditMetadata auditMetadata,\n                                               List<File> uncompressedInputFiles) throws Exception {\n        MDACalloutsService mdaCalloutsService = MDACalloutsService.createOrGetInstance(workflowJobDetails.getSystemToken(), TaskExecutorWorkflowUtils.getConfigSourceUrl(workflowJobDetails), auditMetadata);\n        JsonObject jsonObject = mdaCalloutsService.getConnectionDetailsFromConnectors(fetchTaskDetails.getConnectorId(), CONNECTOR_TYPE);\n        isNotNull(jsonObject, GENERIC_SYSTEM_ERROR, \"No connection details found for this connection\");\n        HubspotAccessDetails accessDetailsFromDB = extractAccessDetails(jsonObject);\n        uncompressedInputFiles.addAll(readData(workflowJobDetails, externalTaskRequestContext, accessDetailsFromDB, fetchTaskDetails));\n    }\n\n    private static HubspotAccessDetails extractAccessDetails(JsonObject jsonObject) {\n        JsonObject decryptedObject = new JsonParser().parse(CryptUtil.decrypt(jsonObject.get(DATA).getAsJsonObject().get(VALUE).getAsString())).getAsJsonObject();\n        HubspotAccessDetails accessDetails = null;\n        if (!decryptedObject.isJsonNull()) {\n            accessDetails = new HubspotAccessDetails();\n            accessDetails.setClientId(decryptedObject.get(PROPERTIES).getAsJsonObject().get(CLIENT_ID).getAsString());\n            accessDetails.setClientSecret(decryptedObject.get(PROPERTIES).getAsJsonObject().get(CLIENT_SECRET).getAsString());\n            accessDetails.setRefreshToken(decryptedObject.get(PROPERTIES).getAsJsonObject().get(REFRESH_TOKEN).getAsString());\n        }\n        return accessDetails;\n    }\n\n    private static InputStream getDataFromHubspot(HubspotAccessDetails accessDetails, long offset, HubspotExtractDetails fetchTaskDetails) {\n        List<String> projectionList = fetchTaskDetails.getProjectionClause().stream()\n                .filter(fieldInfo -> StringUtils.isNotEmpty(fieldInfo.getName()))\n                .map(FieldInfo::getName)\n                .collect(Collectors.toList());\n        return getDataFromHubspot(accessDetails, offset, fetchTaskDetails, projectionList);\n    }\n\n    private static InputStream getDataFromHubspot(HubspotAccessDetails accessDetails, long offset, HubspotExtractDetails fetchTaskDetails, List<String> projectionList) {\n        GainsightHubspotFetchService fetchService = new GainsightHubspotFetchServiceImpl();\n        try {\n            return fetchService.getPaginatedEntityData(fetchTaskDetails.getExternalEntityName(), projectionList,\n                    accessDetails.getClientId(), accessDetails.getClientSecret(), accessDetails.getRefreshToken(),\n                    accessDetails.getAccessToken(), offset);\n        } catch (Exception ex) {\n            if (StringUtils.isNotEmpty(ex.getMessage()) && ex.getMessage().equals(\"Hubspot access token expired\")) {\n                LOGGER.error(\"Regenerating Hubspot access token...\");\n                GainsightHubspotChannelFactory gainsightHubspotChannelFactory = new GainsightHubspotChannelFactory();\n                try {\n                    accessDetails.setAccessToken(gainsightHubspotChannelFactory.getAccessToken(accessDetails.getClientId(), accessDetails.getClientSecret(), accessDetails.getRefreshToken()));\n                    return fetchService.getPaginatedEntityData(fetchTaskDetails.getExternalEntityName(), projectionList,\n                            accessDetails.getClientId(), accessDetails.getClientSecret(), accessDetails.getRefreshToken(),\n                            accessDetails.getAccessToken(), offset);\n                } catch (Exception e) {\n                    LOGGER.error(\"Error while Regenerating Hubspot access token. \", e);\n                    return null;\n                }\n            }\n            return null;\n        }\n    }\n\n    private static InputStream getDataFromHubspotLatestApi(HubspotAccessDetails accessDetails, String nextPageUrl, HubspotExtractDetails fetchTaskDetails) {\n        GainsightHubspotFetchService fetchService = new GainsightHubspotFetchServiceImpl();\n        List<String> projectionList = fetchTaskDetails.getProjectionClause().stream()\n                .filter(fieldInfo -> StringUtils.isNotEmpty(fieldInfo.getName()))\n                .map(FieldInfo::getName)\n                .collect(Collectors.toList());\n        try {\n            return fetchService.getPaginatedEntityDataLatest(fetchTaskDetails.getExternalEntityName(), projectionList,\n                    accessDetails.getClientId(), accessDetails.getClientSecret(), accessDetails.getRefreshToken(),\n                    accessDetails.getAccessToken(), nextPageUrl);\n        } catch (Exception ex) {\n            if (StringUtils.isNotEmpty(ex.getMessage()) && ex.getMessage().equals(\"Hubspot access token expired\")) {\n                LOGGER.error(\"Regenerating Hubspot access token...\");\n                GainsightHubspotChannelFactory gainsightHubspotChannelFactory = new GainsightHubspotChannelFactory();\n                try {\n                    accessDetails.setAccessToken(gainsightHubspotChannelFactory.getAccessToken(accessDetails.getClientId(), accessDetails.getClientSecret(), accessDetails.getRefreshToken()));\n                    return fetchService.getPaginatedEntityDataLatest(fetchTaskDetails.getExternalEntityName(), projectionList,\n                            accessDetails.getClientId(), accessDetails.getClientSecret(), accessDetails.getRefreshToken(),\n                            accessDetails.getAccessToken(), nextPageUrl);\n                } catch (Exception e) {\n                    LOGGER.error(\"Error while Regenerating Hubspot access token. \", e);\n                    return null;\n                }\n            }\n            return null;\n        }\n    }\n\n    private static Deque<File> readData(DPWorkflowJobDetailsDTO workflowJobDetails, ExternalTaskRequestContext externalTaskRequestContext, HubspotAccessDetails accessDetails, HubspotExtractDetails fetchTaskDetails) {\n        InputStream stream = null;\n        Deque<File> fileStack = new ArrayDeque<>();\n        try {\n            boolean shouldContinue;\n            String hasMoreKeyword = GSHubSpotEntityEnum.getHasMoreKeyWord(GSHubSpotEntityEnum.getInstance(fetchTaskDetails.getExternalEntityName()));\n            String offsetKeyword = GSHubSpotEntityEnum.getRetrievOffsetKeyWord(GSHubSpotEntityEnum.getInstance(fetchTaskDetails.getExternalEntityName()));\n            String pluralName = GSHubSpotEntityEnum.getPluralName(GSHubSpotEntityEnum.getInstance(fetchTaskDetails.getExternalEntityName()));\n            GainsightHubspotChannelFactory gainsightHubspotChannelFactory = new GainsightHubspotChannelFactory();\n            accessDetails.setAccessToken(gainsightHubspotChannelFactory.getAccessToken(accessDetails.getClientId(), accessDetails.getClientSecret(), accessDetails.getRefreshToken()));\n            long offset = Long.MIN_VALUE;\n            String nextPageUrl = null;\n            int counter = 0;\n            Optional<DPWorkflowTaskDetailsDTO> taskDetailsDTO = workflowJobDetails.getWorkflowDetails().getTasks().stream().\n                    filter(task -> task.getMetaData() != null && task.getMetaData().get(\"taskName\").toString().equalsIgnoreCase(HUBSPOT_API_EXTRACT)).findFirst();\n            String apiVersion = HUBSPOT_API_VERSION_LEGACY;\n            if (!ObjectUtils.isEmpty(taskDetailsDTO.get().getMetaData().get(HUBSPOT_API_VERSION))) {\n                apiVersion = taskDetailsDTO.get().getMetaData().get(HUBSPOT_API_VERSION).toString();\n            }\n            do {\n                LOGGER.info(\"Paginated api running for offset : {}, pagination api counter: {}, nextpageurl :{} , apiVersion : {} \", offset, counter++, nextPageUrl, apiVersion);\n                if (apiVersion.equalsIgnoreCase(HUBSPOT_API_VERSION_LEGACY)) {\n                    stream = getDataFromHubspot(accessDetails, offset, fetchTaskDetails);\n                    isNotNull(stream, GENERIC_SYSTEM_ERROR, \"No data fetched from external source\");\n                    File tempFile = getLocalFile(workflowJobDetails, externalTaskRequestContext, fileStack);\n                    offset = readDataAndStoreInFile(stream, hasMoreKeyword, offsetKeyword, pluralName, tempFile, fetchTaskDetails.getExternalEntityName());\n                } else {// New api Version V3\n                    stream = getDataFromHubspotLatestApi(accessDetails, nextPageUrl, fetchTaskDetails);\n                    isNotNull(stream, GENERIC_SYSTEM_ERROR, \"No data fetched from external source\");\n                    File tempFile = getLocalFile(workflowJobDetails, externalTaskRequestContext, fileStack);\n                    nextPageUrl = readDataAndStoreInFileLatestApi(stream, pluralName, tempFile, fetchTaskDetails.getExternalEntityName());\n                }\n                shouldContinue = offset != Long.MIN_VALUE || (StringUtils.isNotEmpty(nextPageUrl));\n            } while (shouldContinue && !Thread.currentThread().isInterrupted());\n        } catch (IOException ioEx) {\n            LOGGER.error(\"Failed during fetching data from hubspot.\", ioEx);\n        } catch (Exception e) {\n            LOGGER.error(\"Failed during fetching data from hubspot.\", e);\n        } finally {\n            IOUtils.closeQuietly(stream);\n        }\n        return fileStack;\n    }\n\n    private static long readDataAndStoreInFile(InputStream inputStream, String hasMoreKeyword, String offsetKeyword, String pluralName, File tempFile, String entityName) throws IOException {\n        long offset = Long.MIN_VALUE;\n        JsonObject jsonObject = null;\n        jsonObject = iterativelyPullDataAndStoreInLocal(inputStream, pluralName, tempFile, entityName, jsonObject);\n        offset = shouldContinue(hasMoreKeyword, offsetKeyword, offset, jsonObject);\n        return offset;\n    }\n\n    private static String readDataAndStoreInFileLatestApi(InputStream inputStream, String pluralName, File tempFile, String entityName) throws IOException {\n        String url = null;\n        JsonObject jsonObject = null;\n        jsonObject = iterativelyPullDataAndStoreInLocal(inputStream, \"results\", tempFile, entityName, jsonObject);\n        url = isAfter(url, jsonObject);\n        return url;\n    }\n\n    private static long shouldContinue(String hasMoreKeyword, String offsetKeyword, long offset, JsonObject jsonObject) {\n        if (jsonObject != null && jsonObject.get(hasMoreKeyword) != null && jsonObject.get(hasMoreKeyword).getAsBoolean()) {\n            offset = jsonObject.get(offsetKeyword).getAsLong();\n        }\n        return offset;\n    }\n\n    private static String isAfter(String url, JsonObject jsonObject) {\n        if (jsonObject != null && jsonObject.get(\"paging\") != null) {\n            url = jsonObject.getAsJsonObject(\"paging\").getAsJsonObject(\"next\").get(\"link\").getAsString();\n        }\n        return url;\n    }\n\n    private static JsonObject iterativelyPullDataAndStoreInLocal(InputStream inputStream, String pluralName, File tempFile, String entityName, JsonObject jsonObject) throws IOException {\n        JsonArray iterator = null;\n        try {\n            if (entityName.equalsIgnoreCase(GSHubSpotEntityEnum.labelName(GSHubSpotEntityEnum.OWNER)) && !pluralName.equalsIgnoreCase(\"results\")) {\n                iterator = new JsonParser().parse(IOUtils.toString(inputStream, Charset.defaultCharset())).getAsJsonArray();\n            } else {\n                jsonObject = new JsonParser().parse(IOUtils.toString(inputStream, Charset.defaultCharset())).getAsJsonObject();\n                iterator = jsonObject.getAsJsonArray(pluralName);\n            }\n        } catch (JsonParseException e) {\n            LOGGER.error(\"Exception occurred while parsing hubspot response to JSON object : \", e);\n            throw new DPSystemException(\"Exception occurred while parsing hubspot response to JSON object : \", e);\n        }\n        if (iterator != null)\n            iterator.iterator().forEachRemaining((JsonElement jsonElement) -> {\n                try {\n                    FileUtils.writeStringToFile(tempFile, jsonElement.getAsJsonObject().toString() + CARRIAGE_RETURN, StandardCharsets.UTF_8, true);\n                } catch (IOException e) {\n                    LOGGER.error(\"Exception occurred while parsing hubspot JSON response to temp file : \", e);\n                    throw new DPSystemException(\"Exception occurred while parsing hubspot JSON response to temp file : \", e);\n                }\n            });\n        return jsonObject;\n    }\n\n    private static File getLocalFile(DPWorkflowJobDetailsDTO workflowJobDetails, ExternalTaskRequestContext externalTaskRequestContext, Deque<File> fileStack) throws IOException {\n        if (fileStack.isEmpty() || fileStack.peek().length() >= FILE_SIZE_THRESHOLD_IN_BYTES) {\n            fileStack.push(File.createTempFile(DPUtils.getTempFilePath(workflowJobDetails.getTenantId(), workflowJobDetails.getJobId(), externalTaskRequestContext.getTaskId(), UUID.randomUUID().toString()), JSON_EXTENSION));\n        }\n        return fileStack.peek();\n    }\n}\n"}
2025-05-13 21:04:32 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:04:33 [main] INFO  c.l.s.impl.HnswVectorStoreService - Saved index for namespace default to /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/vector-store/default/hnsw_index.bin
2025-05-13 21:04:33 [main] INFO  c.l.s.impl.HnswVectorStoreService - Saved metadata for namespace default to /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/vector-store/default/embedding_metadata.json
2025-05-13 21:04:33 [main] INFO  c.l.service.impl.BasicL3AgentService - Processed file: /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/code/dp_dynamic_tasks/hubspot-extraction-task/src/main/java/com/gainsight/services/external/hubspot/extraction/task/HubspotExtractTask.java with 16 chunks
2025-05-13 21:04:33 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:04:33 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:04:33 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"package com.gainsight.services.external.ipaas.staging.task;\n\nimport com.fasterxml.jackson.core.type.TypeReference;\nimport com.gainsight.integration.exception.externaltasks.ExternalTaskException;\nimport com.gainsight.integration.exception.externaltasks.ExternalTasksValidationCode;\nimport com.gainsight.integration.staging.beans.DatabaseConnectionRequest;\nimport com.gainsight.integration.staging.beans.IpaasStagingDetails;\nimport com.gainsight.integration.staging.beans.IpaasStagingFieldInfo;\nimport com.gainsight.integration.staging.beans.IpaasStagingLoadDetails;\nimport com.gainsight.integration.staging.services.IpaasStagingDao;\nimport com.gainsight.integration.staging.services.IpaasStagingDaoImpl;\nimport com.gainsight.integration.staging.services.IpaasStagingDetailsDao;\nimport com.gainsight.integration.staging.services.IpaasStagingDetailsDaoImpl;\nimport com.gainsight.integration.staging.utils.DatabaseConnectionPoolUtility;\nimport com.gainsight.services.dataprocessing.commons.cryptography.CryptUtil;\nimport com.gainsight.services.dataprocessing.commons.exception.DPSystemException;\nimport com.gainsight.services.dataprocessing.commons.exception.ValidationCode;\nimport com.gainsight.services.dataprocessing.commons.pojo.DataType;\nimport com.gainsight.services.dataprocessing.commons.pojo.fields.FieldInfo;\nimport com.gainsight.services.dataprocessing.commons.pojo.workflow.DPWorkflowJobDetailsDTO;\nimport com.gainsight.services.dataprocessing.commons.properties.DeploymentProperties;\nimport com.gainsight.services.dataprocessing.commons.system.Precondition;\nimport com.gainsight.services.dataprocessing.dataexternals.mda.MDACalloutsService;\nimport com.gainsight.services.dataprocessing.dataexternals.mda.MDACalloutsServiceImpl;\nimport com.gainsight.services.dataprocessing.dataprocessor.dagdataprocessor.pojo.ExternalTaskResult;\nimport com.gainsight.services.dataprocessing.dataprocessor.dagdataprocessor.pojo.TaskResult;\nimport com.gainsight.services.dataprocessing.external.task.ExternalTaskRequestContext;\nimport com.gainsight.services.dataprocessing.external.task.ExternalTaskUtil;\nimport com.gainsight.services.utilities.datahighway.dhcommons.pojo.base.connection.PNPConnectionInput;\nimport com.gainsight.services.utilities.datahighway.dhcommons.pojo.base.connection.PNPConnectionsInfo;\nimport com.gainsight.services.utilities.datahighway.dhcommons.pojo.base.connection.RelationalDBConnectionDetail;\nimport com.gainsight.services.utilities.datahighway.dhquerybuilder.constructs.custom.DateTimeProperties;\nimport com.google.common.base.Stopwatch;\nimport com.google.common.collect.Lists;\nimport org.apache.commons.collections4.CollectionUtils;\nimport org.apache.commons.dbcp2.BasicDataSource;\nimport org.apache.commons.io.FileUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.File;\nimport java.util.*;\nimport java.util.concurrent.TimeUnit;\nimport java.util.stream.Collectors;\n\nimport static com.gainsight.services.dataprocessing.commons.constants.Constants.MDA_GAINSIGHT_B2B_SECRET;\nimport static com.gainsight.services.dataprocessing.commons.utils.DPUtils.convertJsonToObject;\n\n/**\n * @author Manas Ranjan Sur (msur@gainsight.com)\n * created on 05-APR-2020\n * External Task for loading records to ipaas staging postgres tables.\n */\n\npublic class IpaasStagingLoadTask {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(IpaasStagingLoadTask.class);\n\n    public static final String IPAAS_STAGING_LOAD_DETAILS_KEY = \"ipaasStagingLoadDetails\";\n\n    public static void main(String[] args) {\n        executeTask(ExternalTaskUtil.getExternalTaskRequestContext());\n    }\n\n    private static void executeTask(ExternalTaskRequestContext externalTaskRequestContext) {\n        Stopwatch stopwatch = Stopwatch.createStarted();\n        String jobId = externalTaskRequestContext.getJobId();\n        String taskId = externalTaskRequestContext.getTaskId();\n        //Get workflowJobDetails of given jobId\n        DPWorkflowJobDetailsDTO workflowJobDetails = externalTaskRequestContext.getWorkflowJobDetails();\n        String tenantId = externalTaskRequestContext.getTenantId();\n        LOGGER.info(\"Request to ipaas staging load started !!  tId- {}, jobId- {}, taskId- {}\", tenantId, jobId, taskId);\n        List<File> inputFiles = Lists.newArrayList();\n        try {\n            Map<String, String> metaData = externalTaskRequestContext.getMetaData();\n\n\n            // Get source S3 path on which free form query needs to be executed and convert it to apache drill path\n            List<String> parents = convertJsonToObject(metaData.get(\"parents\"), new TypeReference<List<String>>() {\n            });\n            Precondition.isNotEmpty(parents, ValidationCode.GENERIC_SYSTEM_ERROR, \"Parents in metadata is empty!\");\n\n            IpaasStagingLoadDetails ipaasStagingLoadDetails =\n                    convertJsonToObject(metaData.get(IPAAS_STAGING_LOAD_DETAILS_KEY), IpaasStagingLoadDetails.class);\n\n            //fetch dp staging details\n            BasicDataSource dataSource = getIpaasStagingConnectionDataSource(workflowJobDetails, tenantId, jobId,\n                    taskId, ipaasStagingLoadDetails, externalTaskRequestContext);\n            IpaasStagingDetails ipaasStagingDetails = null;\n            if (ipaasStagingLoadDetails.getStagingConnectionInfo() != null) {\n                ipaasStagingDetails = stagingDetailsProcessing(workflowJobDetails, tenantId, jobId, taskId,\n                        ipaasStagingLoadDetails, dataSource);\n            }\n\n            IpaasStagingDao stagingDao = new IpaasStagingDaoImpl(dataSource);\n\n            //Download Ready csv File from parent task\n            LOGGER.info(\"Downloading parent task CSV file for tId- {}, jobId- {}, taskId- {}, staging details: {}\",\n                    tenantId, jobId, taskId, ipaasStagingDetails);\n\n            String directory = ExternalTaskUtil.downloadParentTaskResults(externalTaskRequestContext, parents.get(0));\n            LOGGER.info(\"Parent directory name for  tId- {}, jobId- {}, taskId- {}\", tenantId, jobId, taskId,\n                    parents.get(0), directory);\n            File folder = new File(directory);\n            inputFiles = Arrays.asList(folder.listFiles());\n            LOGGER.info(\"input file names  tId- {}, jobId- {}, taskId- {}\", tenantId, jobId, taskId,\n                    inputFiles.stream().map(i -> i.toString()).collect(Collectors.joining(\" , \")));\n\n            int recordsAffected = 0;\n            for (File file : inputFiles) {\n                recordsAffected += stagingDao.batchUpsert(ipaasStagingDetails, file, ipaasStagingLoadDetails.getTenantZoneId());\n            }\n\n            LOGGER.info(\"{} records affected for  tId- {}, jobId- {}, taskId- {}\", recordsAffected, tenantId, jobId, taskId);\n            List<FieldInfo> fieldInfos = Lists.newArrayList();\n            FieldInfo fieldInfo;\n            for (IpaasStagingFieldInfo ipaasStagingFieldInfo : ipaasStagingDetails.getFieldInfos()) {\n                fieldInfo = new FieldInfo();\n                fieldInfo.setName(ipaasStagingFieldInfo.getDbName());\n                fieldInfo.setFieldAlias(ipaasStagingFieldInfo.getDbName());\n                fieldInfo.setDataType(DataType.getDataType(ipaasStagingFieldInfo.getDataType()));\n                fieldInfos.add(fieldInfo);\n            }\n            TaskResult taskResult = new TaskResult(null, recordsAffected, fieldInfos, null);\n            ExternalTaskResult externalTaskResult = new ExternalTaskResult(taskResult, true);\n            ExternalTaskUtil.saveExternalTaskResult(externalTaskRequestContext, externalTaskResult);\n        } catch (Exception ex) {\n            LOGGER.error(\"Exception while executing IpaasStagingLoad external.  tId- {}, jobId- {}, taskId- {}  with error - {}\",\n                    tenantId, jobId, taskId, ex);\n            if (ex instanceof ExternalTaskException)\n                throw new ExternalTaskException(((ExternalTaskException) ex).getHttpStatus(),\n                        ((ExternalTaskException) ex).getErrorCode(), ((ExternalTaskException) ex).getErrorMessage(), ex.getMessage());\n            else if (ex instanceof DPSystemException)\n                throw new ExternalTaskException(500, ExternalTasksValidationCode.DP_SYSTEM_EXCPETION,\n                        String.format(\"Failing with DP system exception due to : %s\", ex));\n            else\n                throw new ExternalTaskException(500, ExternalTasksValidationCode.GENERIC_ERROR,\n                        String.format(\"Failing with some exception due to : %s\", ex));\n        } finally {\n            if (CollectionUtils.isNotEmpty(inputFiles)) {\n                inputFiles.forEach(FileUtils::deleteQuietly);\n            }\n            LOGGER.error(\"Request to ipaas staging load completed in {} secs for  tId- {}, jobId- {}, taskId- {}\",\n                    stopwatch.elapsed(TimeUnit.SECONDS), tenantId, jobId, taskId);\n        }\n    }\n\n\n    private static BasicDataSource getIpaasStagingConnectionDataSource(DPWorkflowJobDetailsDTO workflowJobDetails, String tenantId, String jobId,\n                                                                       String taskId, IpaasStagingLoadDetails ipaasStagingLoadDetails,\n                                                                       ExternalTaskRequestContext externalTaskRequestContext) {\n        String configSourceUrl = ExternalTaskUtil.getConfigSourceUrl(workflowJobDetails);\n        String gsB2BSecret = DeploymentProperties.getDeploymentProperties().getValue(MDA_GAINSIGHT_B2B_SECRET);\n        LOGGER.info(\"MDA call out to fetch ipaas staging postgres details started uc connectionId- {}, tId- {}, jobId- {}, taskId- {}\",\n                ipaasStagingLoadDetails.getStagingConnectionInfo().getConnectionId(), tenantId, jobId, taskId);\n        MDACalloutsService mdaCalloutsService = new MDACalloutsServiceImpl(gsB2BSecret, configSourceUrl);\n        PNPConnectionInput pnpConnectionInput = mdaCalloutsService.getConnectionDetails(\n                ipaasStagingLoadDetails.getStagingConnectionInfo().getConnectionId(), externalTaskRequestContext.getTenantId());\n\n        PNPConnectionsInfo pnpConnectionsInfo = pnpConnectionInput.getPnpConnectionsInfo();\n        RelationalDBConnectionDetail relationalDBConnectionDetail =\n                (RelationalDBConnectionDetail) pnpConnectionsInfo.getConnectionDetail();\n        LOGGER.info(\"Fetching ipaas staging postgres details ended. connectionId- {}, tId- {}, jobId- {}, taskId- {}\",\n                ipaasStagingLoadDetails.getStagingConnectionInfo().getConnectionId(), tenantId, jobId, taskId);\n        StringBuilder url = new StringBuilder();\n        url.append(CryptUtil.decrypt(relationalDBConnectionDetail.getHost())).append(\":\")\n                .append(CryptUtil.decrypt(relationalDBConnectionDetail.getPort()));\n        DatabaseConnectionRequest databaseConnectionRequest = new DatabaseConnectionRequest(\n                url.toString(),\n                CryptUtil.decrypt(relationalDBConnectionDetail.getDataBaseName()),\n                CryptUtil.decrypt(relationalDBConnectionDetail.getUser()),\n                CryptUtil.decrypt(relationalDBConnectionDetail.getPwd()),\n                Integer.parseInt(String.valueOf(pnpConnectionsInfo.getProperties().get(\"minIdle\"))),\n                Integer.parseInt(String.valueOf(pnpConnectionsInfo.getProperties().get(\"maxIdle\"))),\n                Integer.parseInt(String.valueOf(pnpConnectionsInfo.getProperties().get(\"initialSize\"))));\n        databaseConnectionRequest.setSslEnabled(relationalDBConnectionDetail.isSslEnabled());\n        return DatabaseConnectionPoolUtility.getOrCreateConnection(databaseConnectionRequest);\n    }\n\n    private static IpaasStagingDetails stagingDetailsProcessing(DPWorkflowJobDetailsDTO workflowJobDetails, String tenantId, String jobId,\n                                                                String taskId, IpaasStagingLoadDetails ipaasStagingLoadDetails,\n                                                                BasicDataSource dataSource) throws Exception {\n\n        IpaasStagingDetailsDao ipaasStagingDetailsDao = new IpaasStagingDetailsDaoImpl(dataSource);\n        LOGGER.info(\"fetching staging details.  tId- {}, jobId- {}, taskId- {}\", tenantId, jobId, taskId);\n        IpaasStagingDetails ipaasStagingDetails = ipaasStagingDetailsDao.findStagingDetails(workflowJobDetails.getTenantId(),\n                ipaasStagingLoadDetails.getTaskId(), ipaasStagingLoadDetails.getJobId());\n\n        IpaasStagingDao ipaasStagingDao = new IpaasStagingDaoImpl(dataSource);\n        if (ipaasStagingDetails == null) {\n            LOGGER.info(\"Preparing ipaas staging postgres details as No staging details found for tId- {}, jobId- {}, taskId- {}\",\n                    tenantId, jobId, taskId);\n            ipaasStagingDetails = prepareIpaasStagingDetailsFromExtractionDetails(\n                    workflowJobDetails.getTenantId(), ipaasStagingLoadDetails.getConnectionId(),\n                    ipaasStagingLoadDetails.getJobId(), ipaasStagingLoadDetails);\n            ipaasStagingDetailsDao.insert(ipaasStagingDetails);\n            LOGGER.info(\"Inserting staging details metadata  for tId- {}, jobId- {}, taskId- {}\", tenantId, jobId, taskId);\n            ipaasStagingDao.create(ipaasStagingDetails);\n            LOGGER.info(\"Created staging table for tId- {}, jobId- {}, taskId- {}\", tenantId, jobId, taskId);\n        }\n\n        //checking and updating field Infos & columns\n        if (!ipaasStagingDetails.isInSync() || !checkSyncStatusForStagingDetails(ipaasStagingDetails, ipaasStagingLoadDetails)\n                || isUpsertKeyChanged(ipaasStagingDetails, ipaasStagingLoadDetails.getUpsertkey())) {\n\n            LOGGER.info(\"full sync required . Hence changing from date in filter for jobId:{}, taskId:{}, tenantId:{}. \",\n                    jobId, taskId, workflowJobDetails.getTenantId());\n            List<IpaasStagingFieldInfo> ipaasStagingFieldInfos = updateFieldInfosInStagingDetails(ipaasStagingLoadDetails);\n            ipaasStagingDetails.setFieldInfos(ipaasStagingFieldInfos);\n            ipaasStagingDetailsDao.updateIpaasStagingFieldInfosByID(ipaasStagingDetails);\n            LOGGER.info(\"updating fieldinfo metadata in staging details for tId- {}, jobId- {}, taskId- {}\", tenantId, jobId, taskId);\n            ipaasStagingDao.dropAndCreate(ipaasStagingDetails);\n            LOGGER.info(\"re created staging table for tId- {}, jobId- {}, taskId- {}\", tenantId, jobId, taskId);\n            ipaasStagingDetails.setInSync(true);\n            ipaasStagingDetailsDao.updateInSyncByJobIdAndTaskId(ipaasStagingDetails);\n        }\n        return ipaasStagingDetails;\n    }\n\n    private static boolean isUpsertKeyChanged(IpaasStagingDetails ipaasStagingDetails, String newUpsertKey) {\n        boolean upsertKeyChanged = false;\n        if (CollectionUtils.isNotEmpty(ipaasStagingDetails.getFieldInfos()) && StringUtils.isNotEmpty(newUpsertKey)) {\n            Optional<IpaasStagingFieldInfo> ipaasStagingFieldInfo = ipaasStagingDetails.getFieldInfos().stream().filter(fieldInfo -> fieldInfo.isUpsertKey()).findFirst();\n            if (!ipaasStagingFieldInfo.isPresent() || !ipaasStagingFieldInfo.get().getFieldName().equalsIgnoreCase(newUpsertKey)) {\n                upsertKeyChanged = true;\n                LOGGER.info(\"new upsertKey selected. {}\", newUpsertKey);\n            }\n        }\n        return upsertKeyChanged;\n    }\n\n    private static IpaasStagingDetails prepareIpaasStagingDetailsFromExtractionDetails(String tenantId,\n                                                                                       String connectionId, String jobId,\n                                                                                       IpaasStagingLoadDetails ipaasStagingLoadDetails) {\n\n        IpaasStagingDetails ipaasStagingDetails = new IpaasStagingDetails();\n        List<IpaasStagingFieldInfo> ipaasStagingFieldInfos = new ArrayList<>();\n        ipaasStagingLoadDetails.getProjections().stream().forEach(i -> {\n            IpaasStagingFieldInfo ipaasStagingFieldInfo = new IpaasStagingFieldInfo();\n            ipaasStagingFieldInfo.setFieldName(i.getFieldAlias());\n            ipaasStagingFieldInfo.setDbName(i.getFieldAlias().toLowerCase());\n            ipaasStagingFieldInfo.setDataType(i.getDataType().getDataType());\n            if (i.getFieldAlias().equalsIgnoreCase(ipaasStagingLoadDetails.getUpsertkey())) {\n                ipaasStagingFieldInfo.setUpsertKey(true);\n            }\n            if (i.getDateTimeProperties() != null) {\n                DateTimeProperties dateTimeProperties = new DateTimeProperties();\n                if (StringUtils.isNotEmpty(i.getDateTimeProperties().getFormat())) {\n                    dateTimeProperties.setFormat(i.getDateTimeProperties().getFormat());\n                }\n                if (StringUtils.isNotEmpty(i.getDateTimeProperties().getTimeZoneId())) {\n                    dateTimeProperties.setTimeZoneId(i.getDateTimeProperties().getTimeZoneId());\n                }\n                ipaasStagingFieldInfo.setDateTimeProperties(dateTimeProperties);\n            }\n            ipaasStagingFieldInfos.add(ipaasStagingFieldInfo);\n        });\n        ipaasStagingDetails.setFieldInfos(ipaasStagingFieldInfos);\n        ipaasStagingDetails.setTenantId(tenantId);\n        ipaasStagingDetails.setConnectorJobId(jobId);\n        ipaasStagingDetails.setConnectionId(connectionId);\n        ipaasStagingDetails.setTaskId(ipaasStagingLoadDetails.getTaskId());\n        ipaasStagingDetails.setTableName(String.format(\"ips_%s_%s_%s\", tenantId.substring(0, tenantId.indexOf(\"-\")),\n                jobId.replaceAll(\"-\", \"\"),\n                ipaasStagingLoadDetails.getTaskId().replaceAll(\"-\", \"\")).toLowerCase());\n        ipaasStagingDetails.setInSync(true);\n        return ipaasStagingDetails;\n    }\n\n    private static List<IpaasStagingFieldInfo> updateFieldInfosInStagingDetails(IpaasStagingLoadDetails ipaasStagingLoadDetails) {\n\n        List<IpaasStagingFieldInfo> ipaasStagingFieldInfos = new ArrayList<>();\n        ipaasStagingLoadDetails.getProjections().stream().forEach(i -> {\n            IpaasStagingFieldInfo ipaasStagingFieldInfo = new IpaasStagingFieldInfo();\n            ipaasStagingFieldInfo.setFieldName(i.getFieldAlias());\n            ipaasStagingFieldInfo.setDbName(i.getFieldAlias().toLowerCase());\n            ipaasStagingFieldInfo.setDataType(i.getDataType().getDataType());\n            if (i.getFieldAlias().equalsIgnoreCase(ipaasStagingLoadDetails.getUpsertkey())) {\n                ipaasStagingFieldInfo.setUpsertKey(true);\n            }\n            if ((i.getDataType() == com.gainsight.services.utilities.datahighway.dhcommons.enums.datatype.DataType.DATE\n                    || i.getDataType() == com.gainsight.services.utilities.datahighway.dhcommons.enums.datatype.DataType.DATETIME)\n                    && i.getDateTimeProperties() != null) {\n                DateTimeProperties dateTimeProperties = new DateTimeProperties();\n                if (StringUtils.isNotEmpty(i.getDateTimeProperties().getFormat())) {\n                    dateTimeProperties.setFormat(i.getDateTimeProperties().getFormat());\n                }\n                if (StringUtils.isNotEmpty(i.getDateTimeProperties().getTimeZoneId())) {\n                    dateTimeProperties.setTimeZoneId(i.getDateTimeProperties().getTimeZoneId());\n                }\n                ipaasStagingFieldInfo.setDateTimeProperties(dateTimeProperties);\n            }\n            ipaasStagingFieldInfos.add(ipaasStagingFieldInfo);\n        });\n        return ipaasStagingFieldInfos;\n    }\n\n    private static boolean checkSyncStatusForStagingDetails(IpaasStagingDetails ipaasStagingDetails,\n                                                            IpaasStagingLoadDetails ipaasStagingLoadDetails) {\n        Set<String> sourceFieldNames = ipaasStagingLoadDetails.getProjections()\n                .stream().map(i -> i.getFieldAlias())\n                .collect(Collectors.toSet());\n\n        List<String> existingFieldNames = ipaasStagingDetails.getFieldInfos()\n                .stream().map(i -> i.getFieldName())\n                .collect(Collectors.toList());\n\n        return existingFieldNames.size() == sourceFieldNames.size() && existingFieldNames.containsAll(sourceFieldNames);\n\n    }\n}"}
2025-05-13 21:04:34 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:04:34 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:04:34 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:04:34 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    public static void main(String[] args) {\n        executeTask(ExternalTaskUtil.getExternalTaskRequestContext());\n    }\n"}
2025-05-13 21:04:36 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:04:36 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:04:36 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:04:36 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    private static void executeTask(ExternalTaskRequestContext externalTaskRequestContext) {\n        Stopwatch stopwatch = Stopwatch.createStarted();\n        String jobId = externalTaskRequestContext.getJobId();\n        String taskId = externalTaskRequestContext.getTaskId();\n        //Get workflowJobDetails of given jobId\n        DPWorkflowJobDetailsDTO workflowJobDetails = externalTaskRequestContext.getWorkflowJobDetails();\n        String tenantId = externalTaskRequestContext.getTenantId();\n        LOGGER.info(\"Request to ipaas staging load started !!  tId- {}, jobId- {}, taskId- {}\", tenantId, jobId, taskId);\n        List<File> inputFiles = Lists.newArrayList();\n        try {\n            Map<String, String> metaData = externalTaskRequestContext.getMetaData();\n\n\n            // Get source S3 path on which free form query needs to be executed and convert it to apache drill path\n            List<String> parents = convertJsonToObject(metaData.get(\"parents\"), new TypeReference<List<String>>() {\n            });\n            Precondition.isNotEmpty(parents, ValidationCode.GENERIC_SYSTEM_ERROR, \"Parents in metadata is empty!\");\n\n            IpaasStagingLoadDetails ipaasStagingLoadDetails =\n                    convertJsonToObject(metaData.get(IPAAS_STAGING_LOAD_DETAILS_KEY), IpaasStagingLoadDetails.class);\n\n            //fetch dp staging details\n            BasicDataSource dataSource = getIpaasStagingConnectionDataSource(workflowJobDetails, tenantId, jobId,\n                    taskId, ipaasStagingLoadDetails, externalTaskRequestContext);\n            IpaasStagingDetails ipaasStagingDetails = null;\n            if (ipaasStagingLoadDetails.getStagingConnectionInfo() != null) {\n                ipaasStagingDetails = stagingDetailsProcessing(workflowJobDetails, tenantId, jobId, taskId,\n                        ipaasStagingLoadDetails, dataSource);\n            }\n\n            IpaasStagingDao stagingDao = new IpaasStagingDaoImpl(dataSource);\n\n            //Download Ready csv File from parent task\n            LOGGER.info(\"Downloading parent task CSV file for tId- {}, jobId- {}, taskId- {}, staging details: {}\",\n                    tenantId, jobId, taskId, ipaasStagingDetails);\n\n            String directory = ExternalTaskUtil.downloadParentTaskResults(externalTaskRequestContext, parents.get(0));\n            LOGGER.info(\"Parent directory name for  tId- {}, jobId- {}, taskId- {}\", tenantId, jobId, taskId,\n                    parents.get(0), directory);\n            File folder = new File(directory);\n            inputFiles = Arrays.asList(folder.listFiles());\n            LOGGER.info(\"input file names  tId- {}, jobId- {}, taskId- {}\", tenantId, jobId, taskId,\n                    inputFiles.stream().map(i -> i.toString()).collect(Collectors.joining(\" , \")));\n\n            int recordsAffected = 0;\n            for (File file : inputFiles) {\n                recordsAffected += stagingDao.batchUpsert(ipaasStagingDetails, file, ipaasStagingLoadDetails.getTenantZoneId());\n            }\n\n            LOGGER.info(\"{} records affected for  tId- {}, jobId- {}, taskId- {}\", recordsAffected, tenantId, jobId, taskId);\n            List<FieldInfo> fieldInfos = Lists.newArrayList();\n            FieldInfo fieldInfo;\n            for (IpaasStagingFieldInfo ipaasStagingFieldInfo : ipaasStagingDetails.getFieldInfos()) {\n                fieldInfo = new FieldInfo();\n                fieldInfo.setName(ipaasStagingFieldInfo.getDbName());\n                fieldInfo.setFieldAlias(ipaasStagingFieldInfo.getDbName());\n                fieldInfo.setDataType(DataType.getDataType(ipaasStagingFieldInfo.getDataType()));\n                fieldInfos.add(fieldInfo);\n            }\n            TaskResult taskResult = new TaskResult(null, recordsAffected, fieldInfos, null);\n            ExternalTaskResult externalTaskResult = new ExternalTaskResult(taskResult, true);\n            ExternalTaskUtil.saveExternalTaskResult(externalTaskRequestContext, externalTaskResult);\n        } catch (Exception ex) {\n            LOGGER.error(\"Exception while executing IpaasStagingLoad external.  tId- {}, jobId- {}, taskId- {}  with error - {}\",\n                    tenantId, jobId, taskId, ex);\n            if (ex instanceof ExternalTaskException)\n                throw new ExternalTaskException(((ExternalTaskException) ex).getHttpStatus(),\n                        ((ExternalTaskException) ex).getErrorCode(), ((ExternalTaskException) ex).getErrorMessage(), ex.getMessage());\n            else if (ex instanceof DPSystemException)\n                throw new ExternalTaskException(500, ExternalTasksValidationCode.DP_SYSTEM_EXCPETION,\n                        String.format(\"Failing with DP system exception due to : %s\", ex));\n            else\n                throw new ExternalTaskException(500, ExternalTasksValidationCode.GENERIC_ERROR,\n                        String.format(\"Failing with some exception due to : %s\", ex));\n        } finally {\n            if (CollectionUtils.isNotEmpty(inputFiles)) {\n                inputFiles.forEach(FileUtils::deleteQuietly);\n            }\n            LOGGER.error(\"Request to ipaas staging load completed in {} secs for  tId- {}, jobId- {}, taskId- {}\",\n                    stopwatch.elapsed(TimeUnit.SECONDS), tenantId, jobId, taskId);\n        }\n    }\n"}
2025-05-13 21:04:37 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:04:37 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:04:37 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:04:37 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    private static boolean isUpsertKeyChanged(IpaasStagingDetails ipaasStagingDetails, String newUpsertKey) {\n        boolean upsertKeyChanged = false;\n        if (CollectionUtils.isNotEmpty(ipaasStagingDetails.getFieldInfos()) && StringUtils.isNotEmpty(newUpsertKey)) {\n            Optional<IpaasStagingFieldInfo> ipaasStagingFieldInfo = ipaasStagingDetails.getFieldInfos().stream().filter(fieldInfo -> fieldInfo.isUpsertKey()).findFirst();\n            if (!ipaasStagingFieldInfo.isPresent() || !ipaasStagingFieldInfo.get().getFieldName().equalsIgnoreCase(newUpsertKey)) {\n                upsertKeyChanged = true;\n                LOGGER.info(\"new upsertKey selected. {}\", newUpsertKey);\n            }\n        }\n        return upsertKeyChanged;\n    }\n"}
2025-05-13 21:04:38 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:04:38 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:04:38 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:04:38 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"    private static List<IpaasStagingFieldInfo> updateFieldInfosInStagingDetails(IpaasStagingLoadDetails ipaasStagingLoadDetails) {\n\n        List<IpaasStagingFieldInfo> ipaasStagingFieldInfos = new ArrayList<>();\n        ipaasStagingLoadDetails.getProjections().stream().forEach(i -> {\n            IpaasStagingFieldInfo ipaasStagingFieldInfo = new IpaasStagingFieldInfo();\n            ipaasStagingFieldInfo.setFieldName(i.getFieldAlias());\n            ipaasStagingFieldInfo.setDbName(i.getFieldAlias().toLowerCase());\n            ipaasStagingFieldInfo.setDataType(i.getDataType().getDataType());\n            if (i.getFieldAlias().equalsIgnoreCase(ipaasStagingLoadDetails.getUpsertkey())) {\n                ipaasStagingFieldInfo.setUpsertKey(true);\n            }\n            if ((i.getDataType() == com.gainsight.services.utilities.datahighway.dhcommons.enums.datatype.DataType.DATE\n                    || i.getDataType() == com.gainsight.services.utilities.datahighway.dhcommons.enums.datatype.DataType.DATETIME)\n                    && i.getDateTimeProperties() != null) {\n                DateTimeProperties dateTimeProperties = new DateTimeProperties();\n                if (StringUtils.isNotEmpty(i.getDateTimeProperties().getFormat())) {\n                    dateTimeProperties.setFormat(i.getDateTimeProperties().getFormat());\n                }\n                if (StringUtils.isNotEmpty(i.getDateTimeProperties().getTimeZoneId())) {\n                    dateTimeProperties.setTimeZoneId(i.getDateTimeProperties().getTimeZoneId());\n                }\n                ipaasStagingFieldInfo.setDateTimeProperties(dateTimeProperties);\n            }\n            ipaasStagingFieldInfos.add(ipaasStagingFieldInfo);\n        });\n        return ipaasStagingFieldInfos;\n    }\n"}
2025-05-13 21:04:40 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:04:40 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Making embedding API call to URL: https://stage-ds-gpt.gainsightapp.net/external/gpt/get_embedding
2025-05-13 21:04:40 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Headers: Content-Type=application/json, accept=application/json, access_key=0f3cc87a-e362-11ed-bd92-325096b39f47
2025-05-13 21:04:40 [main] DEBUG c.l.s.impl.HnswVectorStoreService - Request body: {"modelVersion":"1","model":"text-embedding-3-large","text":"public class IpaasStagingLoadTask {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(IpaasStagingLoadTask.class);\n\n    public static final String IPAAS_STAGING_LOAD_DETAILS_KEY = \"ipaasStagingLoadDetails\";\n\n    public static void main(String[] args) {\n        executeTask(ExternalTaskUtil.getExternalTaskRequestContext());\n    }\n\n    private static void executeTask(ExternalTaskRequestContext externalTaskRequestContext) {\n        Stopwatch stopwatch = Stopwatch.createStarted();\n        String jobId = externalTaskRequestContext.getJobId();\n        String taskId = externalTaskRequestContext.getTaskId();\n        //Get workflowJobDetails of given jobId\n        DPWorkflowJobDetailsDTO workflowJobDetails = externalTaskRequestContext.getWorkflowJobDetails();\n        String tenantId = externalTaskRequestContext.getTenantId();\n        LOGGER.info(\"Request to ipaas staging load started !!  tId- {}, jobId- {}, taskId- {}\", tenantId, jobId, taskId);\n        List<File> inputFiles = Lists.newArrayList();\n        try {\n            Map<String, String> metaData = externalTaskRequestContext.getMetaData();\n\n\n            // Get source S3 path on which free form query needs to be executed and convert it to apache drill path\n            List<String> parents = convertJsonToObject(metaData.get(\"parents\"), new TypeReference<List<String>>() {\n            });\n            Precondition.isNotEmpty(parents, ValidationCode.GENERIC_SYSTEM_ERROR, \"Parents in metadata is empty!\");\n\n            IpaasStagingLoadDetails ipaasStagingLoadDetails =\n                    convertJsonToObject(metaData.get(IPAAS_STAGING_LOAD_DETAILS_KEY), IpaasStagingLoadDetails.class);\n\n            //fetch dp staging details\n            BasicDataSource dataSource = getIpaasStagingConnectionDataSource(workflowJobDetails, tenantId, jobId,\n                    taskId, ipaasStagingLoadDetails, externalTaskRequestContext);\n            IpaasStagingDetails ipaasStagingDetails = null;\n            if (ipaasStagingLoadDetails.getStagingConnectionInfo() != null) {\n                ipaasStagingDetails = stagingDetailsProcessing(workflowJobDetails, tenantId, jobId, taskId,\n                        ipaasStagingLoadDetails, dataSource);\n            }\n\n            IpaasStagingDao stagingDao = new IpaasStagingDaoImpl(dataSource);\n\n            //Download Ready csv File from parent task\n            LOGGER.info(\"Downloading parent task CSV file for tId- {}, jobId- {}, taskId- {}, staging details: {}\",\n                    tenantId, jobId, taskId, ipaasStagingDetails);\n\n            String directory = ExternalTaskUtil.downloadParentTaskResults(externalTaskRequestContext, parents.get(0));\n            LOGGER.info(\"Parent directory name for  tId- {}, jobId- {}, taskId- {}\", tenantId, jobId, taskId,\n                    parents.get(0), directory);\n            File folder = new File(directory);\n            inputFiles = Arrays.asList(folder.listFiles());\n            LOGGER.info(\"input file names  tId- {}, jobId- {}, taskId- {}\", tenantId, jobId, taskId,\n                    inputFiles.stream().map(i -> i.toString()).collect(Collectors.joining(\" , \")));\n\n            int recordsAffected = 0;\n            for (File file : inputFiles) {\n                recordsAffected += stagingDao.batchUpsert(ipaasStagingDetails, file, ipaasStagingLoadDetails.getTenantZoneId());\n            }\n\n            LOGGER.info(\"{} records affected for  tId- {}, jobId- {}, taskId- {}\", recordsAffected, tenantId, jobId, taskId);\n            List<FieldInfo> fieldInfos = Lists.newArrayList();\n            FieldInfo fieldInfo;\n            for (IpaasStagingFieldInfo ipaasStagingFieldInfo : ipaasStagingDetails.getFieldInfos()) {\n                fieldInfo = new FieldInfo();\n                fieldInfo.setName(ipaasStagingFieldInfo.getDbName());\n                fieldInfo.setFieldAlias(ipaasStagingFieldInfo.getDbName());\n                fieldInfo.setDataType(DataType.getDataType(ipaasStagingFieldInfo.getDataType()));\n                fieldInfos.add(fieldInfo);\n            }\n            TaskResult taskResult = new TaskResult(null, recordsAffected, fieldInfos, null);\n            ExternalTaskResult externalTaskResult = new ExternalTaskResult(taskResult, true);\n            ExternalTaskUtil.saveExternalTaskResult(externalTaskRequestContext, externalTaskResult);\n        } catch (Exception ex) {\n            LOGGER.error(\"Exception while executing IpaasStagingLoad external.  tId- {}, jobId- {}, taskId- {}  with error - {}\",\n                    tenantId, jobId, taskId, ex);\n            if (ex instanceof ExternalTaskException)\n                throw new ExternalTaskException(((ExternalTaskException) ex).getHttpStatus(),\n                        ((ExternalTaskException) ex).getErrorCode(), ((ExternalTaskException) ex).getErrorMessage(), ex.getMessage());\n            else if (ex instanceof DPSystemException)\n                throw new ExternalTaskException(500, ExternalTasksValidationCode.DP_SYSTEM_EXCPETION,\n                        String.format(\"Failing with DP system exception due to : %s\", ex));\n            else\n                throw new ExternalTaskException(500, ExternalTasksValidationCode.GENERIC_ERROR,\n                        String.format(\"Failing with some exception due to : %s\", ex));\n        } finally {\n            if (CollectionUtils.isNotEmpty(inputFiles)) {\n                inputFiles.forEach(FileUtils::deleteQuietly);\n            }\n            LOGGER.error(\"Request to ipaas staging load completed in {} secs for  tId- {}, jobId- {}, taskId- {}\",\n                    stopwatch.elapsed(TimeUnit.SECONDS), tenantId, jobId, taskId);\n        }\n    }\n\n\n    private static BasicDataSource getIpaasStagingConnectionDataSource(DPWorkflowJobDetailsDTO workflowJobDetails, String tenantId, String jobId,\n                                                                       String taskId, IpaasStagingLoadDetails ipaasStagingLoadDetails,\n                                                                       ExternalTaskRequestContext externalTaskRequestContext) {\n        String configSourceUrl = ExternalTaskUtil.getConfigSourceUrl(workflowJobDetails);\n        String gsB2BSecret = DeploymentProperties.getDeploymentProperties().getValue(MDA_GAINSIGHT_B2B_SECRET);\n        LOGGER.info(\"MDA call out to fetch ipaas staging postgres details started uc connectionId- {}, tId- {}, jobId- {}, taskId- {}\",\n                ipaasStagingLoadDetails.getStagingConnectionInfo().getConnectionId(), tenantId, jobId, taskId);\n        MDACalloutsService mdaCalloutsService = new MDACalloutsServiceImpl(gsB2BSecret, configSourceUrl);\n        PNPConnectionInput pnpConnectionInput = mdaCalloutsService.getConnectionDetails(\n                ipaasStagingLoadDetails.getStagingConnectionInfo().getConnectionId(), externalTaskRequestContext.getTenantId());\n\n        PNPConnectionsInfo pnpConnectionsInfo = pnpConnectionInput.getPnpConnectionsInfo();\n        RelationalDBConnectionDetail relationalDBConnectionDetail =\n                (RelationalDBConnectionDetail) pnpConnectionsInfo.getConnectionDetail();\n        LOGGER.info(\"Fetching ipaas staging postgres details ended. connectionId- {}, tId- {}, jobId- {}, taskId- {}\",\n                ipaasStagingLoadDetails.getStagingConnectionInfo().getConnectionId(), tenantId, jobId, taskId);\n        StringBuilder url = new StringBuilder();\n        url.append(CryptUtil.decrypt(relationalDBConnectionDetail.getHost())).append(\":\")\n                .append(CryptUtil.decrypt(relationalDBConnectionDetail.getPort()));\n        DatabaseConnectionRequest databaseConnectionRequest = new DatabaseConnectionRequest(\n                url.toString(),\n                CryptUtil.decrypt(relationalDBConnectionDetail.getDataBaseName()),\n                CryptUtil.decrypt(relationalDBConnectionDetail.getUser()),\n                CryptUtil.decrypt(relationalDBConnectionDetail.getPwd()),\n                Integer.parseInt(String.valueOf(pnpConnectionsInfo.getProperties().get(\"minIdle\"))),\n                Integer.parseInt(String.valueOf(pnpConnectionsInfo.getProperties().get(\"maxIdle\"))),\n                Integer.parseInt(String.valueOf(pnpConnectionsInfo.getProperties().get(\"initialSize\"))));\n        databaseConnectionRequest.setSslEnabled(relationalDBConnectionDetail.isSslEnabled());\n        return DatabaseConnectionPoolUtility.getOrCreateConnection(databaseConnectionRequest);\n    }\n\n    private static IpaasStagingDetails stagingDetailsProcessing(DPWorkflowJobDetailsDTO workflowJobDetails, String tenantId, String jobId,\n                                                                String taskId, IpaasStagingLoadDetails ipaasStagingLoadDetails,\n                                                                BasicDataSource dataSource) throws Exception {\n\n        IpaasStagingDetailsDao ipaasStagingDetailsDao = new IpaasStagingDetailsDaoImpl(dataSource);\n        LOGGER.info(\"fetching staging details.  tId- {}, jobId- {}, taskId- {}\", tenantId, jobId, taskId);\n        IpaasStagingDetails ipaasStagingDetails = ipaasStagingDetailsDao.findStagingDetails(workflowJobDetails.getTenantId(),\n                ipaasStagingLoadDetails.getTaskId(), ipaasStagingLoadDetails.getJobId());\n\n        IpaasStagingDao ipaasStagingDao = new IpaasStagingDaoImpl(dataSource);\n        if (ipaasStagingDetails == null) {\n            LOGGER.info(\"Preparing ipaas staging postgres details as No staging details found for tId- {}, jobId- {}, taskId- {}\",\n                    tenantId, jobId, taskId);\n            ipaasStagingDetails = prepareIpaasStagingDetailsFromExtractionDetails(\n                    workflowJobDetails.getTenantId(), ipaasStagingLoadDetails.getConnectionId(),\n                    ipaasStagingLoadDetails.getJobId(), ipaasStagingLoadDetails);\n            ipaasStagingDetailsDao.insert(ipaasStagingDetails);\n            LOGGER.info(\"Inserting staging details metadata  for tId- {}, jobId- {}, taskId- {}\", tenantId, jobId, taskId);\n            ipaasStagingDao.create(ipaasStagingDetails);\n            LOGGER.info(\"Created staging table for tId- {}, jobId- {}, taskId- {}\", tenantId, jobId, taskId);\n        }\n\n        //checking and updating field Infos & columns\n        if (!ipaasStagingDetails.isInSync() || !checkSyncStatusForStagingDetails(ipaasStagingDetails, ipaasStagingLoadDetails)\n                || isUpsertKeyChanged(ipaasStagingDetails, ipaasStagingLoadDetails.getUpsertkey())) {\n\n            LOGGER.info(\"full sync required . Hence changing from date in filter for jobId:{}, taskId:{}, tenantId:{}. \",\n                    jobId, taskId, workflowJobDetails.getTenantId());\n            List<IpaasStagingFieldInfo> ipaasStagingFieldInfos = updateFieldInfosInStagingDetails(ipaasStagingLoadDetails);\n            ipaasStagingDetails.setFieldInfos(ipaasStagingFieldInfos);\n            ipaasStagingDetailsDao.updateIpaasStagingFieldInfosByID(ipaasStagingDetails);\n            LOGGER.info(\"updating fieldinfo metadata in staging details for tId- {}, jobId- {}, taskId- {}\", tenantId, jobId, taskId);\n            ipaasStagingDao.dropAndCreate(ipaasStagingDetails);\n            LOGGER.info(\"re created staging table for tId- {}, jobId- {}, taskId- {}\", tenantId, jobId, taskId);\n            ipaasStagingDetails.setInSync(true);\n            ipaasStagingDetailsDao.updateInSyncByJobIdAndTaskId(ipaasStagingDetails);\n        }\n        return ipaasStagingDetails;\n    }\n\n    private static boolean isUpsertKeyChanged(IpaasStagingDetails ipaasStagingDetails, String newUpsertKey) {\n        boolean upsertKeyChanged = false;\n        if (CollectionUtils.isNotEmpty(ipaasStagingDetails.getFieldInfos()) && StringUtils.isNotEmpty(newUpsertKey)) {\n            Optional<IpaasStagingFieldInfo> ipaasStagingFieldInfo = ipaasStagingDetails.getFieldInfos().stream().filter(fieldInfo -> fieldInfo.isUpsertKey()).findFirst();\n            if (!ipaasStagingFieldInfo.isPresent() || !ipaasStagingFieldInfo.get().getFieldName().equalsIgnoreCase(newUpsertKey)) {\n                upsertKeyChanged = true;\n                LOGGER.info(\"new upsertKey selected. {}\", newUpsertKey);\n            }\n        }\n        return upsertKeyChanged;\n    }\n\n    private static IpaasStagingDetails prepareIpaasStagingDetailsFromExtractionDetails(String tenantId,\n                                                                                       String connectionId, String jobId,\n                                                                                       IpaasStagingLoadDetails ipaasStagingLoadDetails) {\n\n        IpaasStagingDetails ipaasStagingDetails = new IpaasStagingDetails();\n        List<IpaasStagingFieldInfo> ipaasStagingFieldInfos = new ArrayList<>();\n        ipaasStagingLoadDetails.getProjections().stream().forEach(i -> {\n            IpaasStagingFieldInfo ipaasStagingFieldInfo = new IpaasStagingFieldInfo();\n            ipaasStagingFieldInfo.setFieldName(i.getFieldAlias());\n            ipaasStagingFieldInfo.setDbName(i.getFieldAlias().toLowerCase());\n            ipaasStagingFieldInfo.setDataType(i.getDataType().getDataType());\n            if (i.getFieldAlias().equalsIgnoreCase(ipaasStagingLoadDetails.getUpsertkey())) {\n                ipaasStagingFieldInfo.setUpsertKey(true);\n            }\n            if (i.getDateTimeProperties() != null) {\n                DateTimeProperties dateTimeProperties = new DateTimeProperties();\n                if (StringUtils.isNotEmpty(i.getDateTimeProperties().getFormat())) {\n                    dateTimeProperties.setFormat(i.getDateTimeProperties().getFormat());\n                }\n                if (StringUtils.isNotEmpty(i.getDateTimeProperties().getTimeZoneId())) {\n                    dateTimeProperties.setTimeZoneId(i.getDateTimeProperties().getTimeZoneId());\n                }\n                ipaasStagingFieldInfo.setDateTimeProperties(dateTimeProperties);\n            }\n            ipaasStagingFieldInfos.add(ipaasStagingFieldInfo);\n        });\n        ipaasStagingDetails.setFieldInfos(ipaasStagingFieldInfos);\n        ipaasStagingDetails.setTenantId(tenantId);\n        ipaasStagingDetails.setConnectorJobId(jobId);\n        ipaasStagingDetails.setConnectionId(connectionId);\n        ipaasStagingDetails.setTaskId(ipaasStagingLoadDetails.getTaskId());\n        ipaasStagingDetails.setTableName(String.format(\"ips_%s_%s_%s\", tenantId.substring(0, tenantId.indexOf(\"-\")),\n                jobId.replaceAll(\"-\", \"\"),\n                ipaasStagingLoadDetails.getTaskId().replaceAll(\"-\", \"\")).toLowerCase());\n        ipaasStagingDetails.setInSync(true);\n        return ipaasStagingDetails;\n    }\n\n    private static List<IpaasStagingFieldInfo> updateFieldInfosInStagingDetails(IpaasStagingLoadDetails ipaasStagingLoadDetails) {\n\n        List<IpaasStagingFieldInfo> ipaasStagingFieldInfos = new ArrayList<>();\n        ipaasStagingLoadDetails.getProjections().stream().forEach(i -> {\n            IpaasStagingFieldInfo ipaasStagingFieldInfo = new IpaasStagingFieldInfo();\n            ipaasStagingFieldInfo.setFieldName(i.getFieldAlias());\n            ipaasStagingFieldInfo.setDbName(i.getFieldAlias().toLowerCase());\n            ipaasStagingFieldInfo.setDataType(i.getDataType().getDataType());\n            if (i.getFieldAlias().equalsIgnoreCase(ipaasStagingLoadDetails.getUpsertkey())) {\n                ipaasStagingFieldInfo.setUpsertKey(true);\n            }\n            if ((i.getDataType() == com.gainsight.services.utilities.datahighway.dhcommons.enums.datatype.DataType.DATE\n                    || i.getDataType() == com.gainsight.services.utilities.datahighway.dhcommons.enums.datatype.DataType.DATETIME)\n                    && i.getDateTimeProperties() != null) {\n                DateTimeProperties dateTimeProperties = new DateTimeProperties();\n                if (StringUtils.isNotEmpty(i.getDateTimeProperties().getFormat())) {\n                    dateTimeProperties.setFormat(i.getDateTimeProperties().getFormat());\n                }\n                if (StringUtils.isNotEmpty(i.getDateTimeProperties().getTimeZoneId())) {\n                    dateTimeProperties.setTimeZoneId(i.getDateTimeProperties().getTimeZoneId());\n                }\n                ipaasStagingFieldInfo.setDateTimeProperties(dateTimeProperties);\n            }\n            ipaasStagingFieldInfos.add(ipaasStagingFieldInfo);\n        });\n        return ipaasStagingFieldInfos;\n    }\n\n    private static boolean checkSyncStatusForStagingDetails(IpaasStagingDetails ipaasStagingDetails,\n                                                            IpaasStagingLoadDetails ipaasStagingLoadDetails) {\n        Set<String> sourceFieldNames = ipaasStagingLoadDetails.getProjections()\n                .stream().map(i -> i.getFieldAlias())\n                .collect(Collectors.toSet());\n\n        List<String> existingFieldNames = ipaasStagingDetails.getFieldInfos()\n                .stream().map(i -> i.getFieldName())\n                .collect(Collectors.toList());\n\n        return existingFieldNames.size() == sourceFieldNames.size() && existingFieldNames.containsAll(sourceFieldNames);\n\n    }\n}\n"}
2025-05-13 21:04:41 [main] INFO  c.l.s.impl.HnswVectorStoreService - Retrieved embedding with 3072 dimensions from API
2025-05-13 21:04:41 [main] INFO  c.l.service.impl.BasicL3AgentService - Processed file: /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/code/dp_dynamic_tasks/ipaas-staging-load/src/main/java/com/gainsight/services/external/ipaas/staging/task/IpaasStagingLoadTask.java with 6 chunks
2025-05-13 21:04:41 [main] INFO  c.l.service.impl.BasicL3AgentService - Embedding generation completed. Processed 22 files, 211 chunks, 211 successful, 0 failed, in 302992 ms
2025-05-13 21:04:41 [main] INFO  c.l.cli.EmbeddingGenerationRunner - Embedding generation completed
2025-05-13 21:04:41 [main] INFO  c.l.cli.EmbeddingGenerationRunner - Files processed: 22
2025-05-13 21:04:41 [main] INFO  c.l.cli.EmbeddingGenerationRunner - Total chunks: 211
2025-05-13 21:04:41 [main] INFO  c.l.cli.EmbeddingGenerationRunner - Successful embeddings: 211
2025-05-13 21:04:41 [main] INFO  c.l.cli.EmbeddingGenerationRunner - Failed embeddings: 0
2025-05-13 21:04:41 [main] INFO  c.l.cli.EmbeddingGenerationRunner - Processing time (ms): 302992
2025-05-13 21:04:42 [main] INFO  o.a.catalina.core.StandardService - Stopping service [Tomcat]
2025-05-13 21:04:42 [main] INFO  c.l.s.i.InMemoryKnowledgeGraphService - Saved knowledge graph to /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/knowledge-graph/knowledge_graph.bin
2025-05-13 21:04:42 [main] INFO  c.l.s.impl.HnswVectorStoreService - Saved index for namespace default to /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/vector-store/default/hnsw_index.bin
2025-05-13 21:04:42 [main] INFO  c.l.s.impl.HnswVectorStoreService - Saved metadata for namespace default to /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/vector-store/default/embedding_metadata.json
2025-05-13 21:04:42 [main] INFO  c.l.s.impl.HnswVectorStoreService - Saved 189 embedding failures to /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/vector-store/embedding_failures.json
2025-05-13 21:04:42 [main] INFO  c.l.s.impl.HnswVectorStoreService - Saved 1 repository namespaces
2025-05-13 21:09:52 [main] INFO  com.l3agent.Application - Starting Application using Java 21.0.1 with PID 13914 (/Users/psambaraju/Desktop/cursorProjects/l3AgentNew/target/classes started by psambaraju in /Users/psambaraju/Desktop/cursorProjects/l3AgentNew)
2025-05-13 21:09:52 [main] DEBUG com.l3agent.Application - Running with Spring Boot v3.1.3, Spring v6.0.11
2025-05-13 21:09:52 [main] INFO  com.l3agent.Application - The following 1 profile is active: "nodb"
2025-05-13 21:09:52 [main] INFO  o.s.b.w.e.tomcat.TomcatWebServer - Tomcat initialized with port(s): 8080 (http)
2025-05-13 21:09:52 [main] INFO  o.a.catalina.core.StandardService - Starting service [Tomcat]
2025-05-13 21:09:52 [main] INFO  o.a.catalina.core.StandardEngine - Starting Servlet engine: [Apache Tomcat/10.1.12]
2025-05-13 21:09:52 [main] INFO  o.a.c.c.C.[.[localhost].[/l3agent] - Initializing Spring embedded WebApplicationContext
2025-05-13 21:09:52 [main] INFO  o.s.b.w.s.c.ServletWebServerApplicationContext - Root WebApplicationContext: initialization completed in 638 ms
2025-05-13 21:09:52 [main] DEBUG c.l.s.impl.FileBasedTicketService - Loaded ticket TICKET-1234 from ./data/tickets/TICKET-1234.json
2025-05-13 21:09:52 [main] INFO  c.l.s.impl.HnswVectorStoreService - Loaded 1 repository namespaces
2025-05-13 21:09:52 [main] INFO  c.l.s.impl.HnswVectorStoreService - Loaded index for namespace default from /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/vector-store/default/hnsw_index.bin
2025-05-13 21:09:52 [main] INFO  c.l.s.impl.HnswVectorStoreService - Loaded metadata for 206 embeddings in namespace default
2025-05-13 21:09:52 [main] INFO  c.l.s.impl.HnswVectorStoreService - Loaded existing vector store for namespace default with 206 embeddings
2025-05-13 21:09:52 [main] INFO  c.l.s.impl.HnswVectorStoreService - Loaded 189 embedding failures
2025-05-13 21:09:52 [main] DEBUG c.l.s.i.FileBasedKnowledgeBaseService - Loaded article: KB001 - Resolving NullPointerException in TaskProcessor
2025-05-13 21:09:52 [main] DEBUG c.l.s.i.FileBasedKnowledgeBaseService - Loaded article: KB002 - Troubleshooting Salesforce API Connection Timeouts
2025-05-13 21:09:52 [main] DEBUG c.l.s.i.FileBasedKnowledgeBaseService - Loaded article: KB003 - Resolving Database Connection Issues in Gainsight Adapter
2025-05-13 21:09:52 [main] INFO  c.l.s.i.FileBasedKnowledgeBaseService - Loaded 3 knowledge articles
2025-05-13 21:09:53 [main] INFO  c.l.service.impl.GainsightLLMService - Gainsight LLM service initialized with default model: gpt-4o (version: 2024-05-13)
2025-05-13 21:09:53 [main] INFO  c.l.r.NullLLMMetadataRepository - Using NullLLMMetadataRepository - database operations will be no-ops
2025-05-13 21:09:53 [main] INFO  com.l3agent.config.LLMConfiguration - Using Gainsight LLM service
2025-05-13 21:09:53 [main] INFO  c.l.s.i.InMemoryKnowledgeGraphService - Loaded knowledge graph from /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/knowledge-graph/knowledge_graph.bin
2025-05-13 21:09:53 [main] INFO  c.l.s.i.InMemoryKnowledgeGraphService - Loaded existing knowledge graph with 0 entities and 0 relationships
2025-05-13 21:09:53 [main] INFO  c.l.s.i.FileBasedCodeRepositoryService - Code repository service initialized with directory: ./data/code
2025-05-13 21:09:53 [main] INFO  c.l.s.i.FileBasedCodeRepositoryService - Found repository: gs-integrations
2025-05-13 21:09:53 [main] INFO  c.l.s.i.FileBasedCodeRepositoryService - Found repository: dp_dynamic_tasks
2025-05-13 21:09:53 [main] INFO  c.l.s.i.FileBasedCodeRepositoryService - Found repository: gs-duct
2025-05-13 21:09:53 [main] INFO  c.l.s.i.FileBasedCodeRepositoryService - Found repository: data
2025-05-13 21:09:53 [main] INFO  c.l.s.i.FileBasedCodeRepositoryService - Found repository: gainsight-adapter
2025-05-13 21:09:53 [main] INFO  o.s.b.w.e.tomcat.TomcatWebServer - Tomcat started on port(s): 8080 (http) with context path '/l3agent'
2025-05-13 21:09:53 [main] INFO  com.l3agent.Application - Started Application in 1.508 seconds (process running for 1.731)
2025-05-13 21:14:28 [SpringApplicationShutdownHook] INFO  c.l.s.i.InMemoryKnowledgeGraphService - Saved knowledge graph to /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/knowledge-graph/knowledge_graph.bin
2025-05-13 21:14:28 [SpringApplicationShutdownHook] INFO  c.l.s.impl.HnswVectorStoreService - Saved index for namespace default to /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/vector-store/default/hnsw_index.bin
2025-05-13 21:14:28 [SpringApplicationShutdownHook] INFO  c.l.s.impl.HnswVectorStoreService - Saved metadata for namespace default to /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/vector-store/default/embedding_metadata.json
2025-05-13 21:14:28 [SpringApplicationShutdownHook] INFO  c.l.s.impl.HnswVectorStoreService - Saved 189 embedding failures to /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/vector-store/embedding_failures.json
2025-05-13 21:14:28 [SpringApplicationShutdownHook] INFO  c.l.s.impl.HnswVectorStoreService - Saved 1 repository namespaces
2025-05-13 21:14:35 [main] INFO  com.l3agent.Application - Starting Application using Java 21.0.1 with PID 19087 (/Users/psambaraju/Desktop/cursorProjects/l3AgentNew/target/classes started by psambaraju in /Users/psambaraju/Desktop/cursorProjects/l3AgentNew)
2025-05-13 21:14:35 [main] DEBUG com.l3agent.Application - Running with Spring Boot v3.1.3, Spring v6.0.11
2025-05-13 21:14:35 [main] INFO  com.l3agent.Application - The following 1 profile is active: "nodb"
2025-05-13 21:14:36 [main] INFO  o.s.b.w.e.tomcat.TomcatWebServer - Tomcat initialized with port(s): 8080 (http)
2025-05-13 21:14:36 [main] INFO  o.a.catalina.core.StandardService - Starting service [Tomcat]
2025-05-13 21:14:36 [main] INFO  o.a.catalina.core.StandardEngine - Starting Servlet engine: [Apache Tomcat/10.1.12]
2025-05-13 21:14:36 [main] INFO  o.a.c.c.C.[.[localhost].[/l3agent] - Initializing Spring embedded WebApplicationContext
2025-05-13 21:14:36 [main] INFO  o.s.b.w.s.c.ServletWebServerApplicationContext - Root WebApplicationContext: initialization completed in 651 ms
2025-05-13 21:14:36 [main] DEBUG c.l.s.impl.FileBasedTicketService - Loaded ticket TICKET-1234 from ./data/tickets/TICKET-1234.json
2025-05-13 21:14:36 [main] INFO  c.l.s.impl.HnswVectorStoreService - Loaded 1 repository namespaces
2025-05-13 21:14:36 [main] INFO  c.l.s.impl.HnswVectorStoreService - Loaded index for namespace default from /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/vector-store/default/hnsw_index.bin
2025-05-13 21:14:36 [main] INFO  c.l.s.impl.HnswVectorStoreService - Loaded metadata for 206 embeddings in namespace default
2025-05-13 21:14:36 [main] INFO  c.l.s.impl.HnswVectorStoreService - Loaded existing vector store for namespace default with 206 embeddings
2025-05-13 21:14:36 [main] INFO  c.l.s.impl.HnswVectorStoreService - Loaded 189 embedding failures
2025-05-13 21:14:36 [main] DEBUG c.l.s.i.FileBasedKnowledgeBaseService - Loaded article: KB001 - Resolving NullPointerException in TaskProcessor
2025-05-13 21:14:36 [main] DEBUG c.l.s.i.FileBasedKnowledgeBaseService - Loaded article: KB002 - Troubleshooting Salesforce API Connection Timeouts
2025-05-13 21:14:36 [main] DEBUG c.l.s.i.FileBasedKnowledgeBaseService - Loaded article: KB003 - Resolving Database Connection Issues in Gainsight Adapter
2025-05-13 21:14:36 [main] INFO  c.l.s.i.FileBasedKnowledgeBaseService - Loaded 3 knowledge articles
2025-05-13 21:14:36 [main] INFO  c.l.service.impl.GainsightLLMService - Gainsight LLM service initialized with default model: gpt-4o (version: 2024-05-13)
2025-05-13 21:14:36 [main] INFO  c.l.r.NullLLMMetadataRepository - Using NullLLMMetadataRepository - database operations will be no-ops
2025-05-13 21:14:36 [main] INFO  com.l3agent.config.LLMConfiguration - Using Gainsight LLM service
2025-05-13 21:14:36 [main] INFO  c.l.s.i.InMemoryKnowledgeGraphService - Loaded knowledge graph from /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/knowledge-graph/knowledge_graph.bin
2025-05-13 21:14:36 [main] INFO  c.l.s.i.InMemoryKnowledgeGraphService - Loaded existing knowledge graph with 0 entities and 0 relationships
2025-05-13 21:14:36 [main] INFO  c.l.s.i.FileBasedCodeRepositoryService - Code repository service initialized with directory: ./data/code
2025-05-13 21:14:36 [main] INFO  c.l.s.i.FileBasedCodeRepositoryService - Found repository: gs-integrations
2025-05-13 21:14:36 [main] INFO  c.l.s.i.FileBasedCodeRepositoryService - Found repository: dp_dynamic_tasks
2025-05-13 21:14:36 [main] INFO  c.l.s.i.FileBasedCodeRepositoryService - Found repository: gs-duct
2025-05-13 21:14:36 [main] INFO  c.l.s.i.FileBasedCodeRepositoryService - Found repository: data
2025-05-13 21:14:36 [main] INFO  c.l.s.i.FileBasedCodeRepositoryService - Found repository: gainsight-adapter
2025-05-13 21:14:36 [main] INFO  o.s.b.w.e.tomcat.TomcatWebServer - Tomcat started on port(s): 8080 (http) with context path '/l3agent'
2025-05-13 21:14:36 [main] INFO  com.l3agent.Application - Started Application in 1.384 seconds (process running for 1.6)
2025-05-13 21:14:45 [SpringApplicationShutdownHook] INFO  c.l.s.i.InMemoryKnowledgeGraphService - Saved knowledge graph to /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/knowledge-graph/knowledge_graph.bin
2025-05-13 21:14:45 [SpringApplicationShutdownHook] INFO  c.l.s.impl.HnswVectorStoreService - Saved index for namespace default to /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/vector-store/default/hnsw_index.bin
2025-05-13 21:14:45 [SpringApplicationShutdownHook] INFO  c.l.s.impl.HnswVectorStoreService - Saved metadata for namespace default to /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/vector-store/default/embedding_metadata.json
2025-05-13 21:14:45 [SpringApplicationShutdownHook] INFO  c.l.s.impl.HnswVectorStoreService - Saved 189 embedding failures to /Users/psambaraju/Desktop/cursorProjects/l3AgentNew/./data/vector-store/embedding_failures.json
2025-05-13 21:14:45 [SpringApplicationShutdownHook] INFO  c.l.s.impl.HnswVectorStoreService - Saved 1 repository namespaces
